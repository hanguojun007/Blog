<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="dcterms.date" content="2025-10-13">
<title>10 Resampling for Evaluating Performance</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../Books/Tidy Modeling with R/9 Judging Model Effectiveness.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2bc269ba33bfe0c9779ec90686b7c52e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": true,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "Search",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script><script src="../../site_libs/kePrint-0.0.1/kePrint.js"></script><link href="../../site_libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script><link rel="stylesheet" href="../../styles.css">
</head>
<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="navbar navbar-expand-lg " data-bs-theme="dark"><div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">RSSPtho</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
<li class="nav-item">
    <a class="nav-link active" href="../../index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-books" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Books</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-books">
<li>
    <a class="dropdown-item" href="../../Books/ggplot2/index.html">
 <span class="dropdown-text">ggplot2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Books/R4DS2/index.html">
 <span class="dropdown-text">R for Data Science(2e)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Books/Tidy Modeling with R/index.html">
 <span class="dropdown-text">Tidy Modeling with R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Books/Advanced R(2e)/index.html">
 <span class="dropdown-text">Advanced R(2e)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Books/quarto/Project Basics.html">
 <span class="dropdown-text">Quarto</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../Books/Js4R/00 Preface.qmd">
 <span class="dropdown-text">Js4R</span></a>
  </li>  
    </ul>
</li>
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
</ul>
<div class="quarto-navbar-tools">
    <a href="https://github.com/hanguojun007/Blog" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../Books/Tidy Modeling with R/10 Resampling for Evaluating Performance.html">10 Resampling for Evaluating Performance</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hello World</span></a>
  </div>
</li>
        <li class="sidebar-item">
 <span class="menu-text">Introduction</span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/1 Software for modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1 Software for modeling</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/2 A Tidyverse Primer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2 A Tidyverse Primer</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/3 A Review of R Modeling Fundamentals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3 A Review of R Modeling Fundamentals</span></a>
  </div>
</li>
        <li class="sidebar-item">
 <span class="menu-text">Moduling Basics</span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/4 The Ames Housing Data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">4 The Ames Housing Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/5 Spending our Data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5 Spending our Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/6 Fitting Models with parsnip.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6 Fitting Models with parsnip</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/7 A Model Workflow.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">7 A Model Workflow</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/8 Feature Engineering with recipes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">8 Feature Engineering with recipes</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/9 Judging Model Effectiveness.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">9 Judging Model Effectiveness</span></a>
  </div>
</li>
        <li class="sidebar-item">
 <span class="menu-text">Tools For Creating Effective Models</span>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../Books/Tidy Modeling with R/10 Resampling for Evaluating Performance.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">10 Resampling for Evaluating Performance</span></a>
  </div>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">On this page</h2>
   
  <ul>
<li><a href="#the-resubstitution-approach" id="toc-the-resubstitution-approach" class="nav-link active" data-scroll-target="#the-resubstitution-approach">The Resubstitution Approach</a></li>
  <li>
<a href="#resampling-methods" id="toc-resampling-methods" class="nav-link" data-scroll-target="#resampling-methods">Resampling Methods</a>
  <ul class="collapse">
<li><a href="#cross-validation" id="toc-cross-validation" class="nav-link" data-scroll-target="#cross-validation">Cross-validation</a></li>
  <li><a href="#validation-sets" id="toc-validation-sets" class="nav-link" data-scroll-target="#validation-sets">Validation sets</a></li>
  <li><a href="#bootstrapping" id="toc-bootstrapping" class="nav-link" data-scroll-target="#bootstrapping">Bootstrapping</a></li>
  <li><a href="#rolling-forecasting-origin-resampling" id="toc-rolling-forecasting-origin-resampling" class="nav-link" data-scroll-target="#rolling-forecasting-origin-resampling">Rolling forecasting origin resampling</a></li>
  </ul>
</li>
  <li><a href="#estimating-performance" id="toc-estimating-performance" class="nav-link" data-scroll-target="#estimating-performance">Estimating Performance</a></li>
  <li><a href="#parallel-processing" id="toc-parallel-processing" class="nav-link" data-scroll-target="#parallel-processing">Parallel Processing</a></li>
  <li><a href="#saving-the-resampled-objects" id="toc-saving-the-resampled-objects" class="nav-link" data-scroll-target="#saving-the-resampled-objects">Saving the Resampled Objects</a></li>
  <li><a href="#chapter-summary" id="toc-chapter-summary" class="nav-link" data-scroll-target="#chapter-summary">Chapter Summary</a></li>
  </ul></nav>
    <div class="quarto-margin-footer"><div class="margin-footer-item">
<p><img src="../..\logo.jpg" class="conditional-footer img-fluid" width="200"></p>
</div></div></div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><div class="quarto-title">
<h1 class="title">10 Resampling for Evaluating Performance</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 13, 2025</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">October 18, 2025</p>
    </div>
  </div>
    
  </div>
  


</header><p>我们已经介绍了评估模型性能时必须综合考虑的几个方面。第9章描述了用于衡量模型性能的统计量。第5章引入了数据使用的概念，并且我们建议使用测试集来获得无偏的性能估计。然而，我们通常需要在使用测试集之前了解一个甚至多个模型的性能（测试集只能使用一次?）。通常情况下，在第一次评估模型性能之前，我们无法决定使用哪个最终模型来处理测试集。我们对可靠地衡量性能的需求与我们可用的数据拆分（训练集和测试集）之间存在差距。</p>
<p>在本章中，我们将介绍一种名为<strong>重采样</strong>的方法，它能够填补这一空白。重采样得出的性能估计值可以像测试集得出的估计值一样，推广到新数据。下一章将通过展示用于比较重采样结果的统计方法，对本章内容进行补充。</p>
<p>为了充分理解重抽样的价值，让我们首先来看一下<strong>重代入</strong>法（这种方法常常会失败）。</p>
<section id="the-resubstitution-approach" class="level2"><h2 class="anchored" data-anchor-id="the-resubstitution-approach">The Resubstitution Approach</h2>
<p>所谓重带入，就是使用用于训练的相同数据（训练集而非测试集或新数据）来衡量性能。让我们再次使用Ames房价数据来演示这些概念。</p>
<p>第8.8节总结了Ames数据分析的当前状态：包括一个名为<code>ames_rec</code>的recipe对象、一个线性模型，以及一个使用该recipe对象和模型的工作流，名为<code>lm_wflow</code>，这个工作流在训练集上进行了拟合，得到了<code>lm_fit</code>。</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidymodels.tidymodels.org">tidymodels</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; ── Attaching packages ─────────────────────────────────── tidymodels 1.4.1 ──</span></span>
<span><span class="co">#&gt; ✔ broom        1.0.9     ✔ recipes      1.3.1</span></span>
<span><span class="co">#&gt; ✔ dials        1.4.2     ✔ rsample      1.3.1</span></span>
<span><span class="co">#&gt; ✔ dplyr        1.1.4     ✔ tailor       0.1.0</span></span>
<span><span class="co">#&gt; ✔ ggplot2      3.5.2     ✔ tidyr        1.3.1</span></span>
<span><span class="co">#&gt; ✔ infer        1.0.9     ✔ tune         2.0.0</span></span>
<span><span class="co">#&gt; ✔ modeldata    1.5.1     ✔ workflows    1.3.0</span></span>
<span><span class="co">#&gt; ✔ parsnip      1.3.3     ✔ workflowsets 1.1.1</span></span>
<span><span class="co">#&gt; ✔ purrr        1.1.0     ✔ yardstick    1.3.2</span></span>
<span><span class="co">#&gt; ── Conflicts ────────────────────────────────────── tidymodels_conflicts() ──</span></span>
<span><span class="co">#&gt; ✖ purrr::discard() masks scales::discard()</span></span>
<span><span class="co">#&gt; ✖ dplyr::filter()  masks stats::filter()</span></span>
<span><span class="co">#&gt; ✖ dplyr::lag()     masks stats::lag()</span></span>
<span><span class="co">#&gt; ✖ recipes::step()  masks stats::step()</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">ames</span><span class="op">)</span></span>
<span><span class="va">ames</span> <span class="op">&lt;-</span> <span class="fu">mutate</span><span class="op">(</span><span class="va">ames</span>, Sale_Price <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">Sale_Price</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">502</span><span class="op">)</span></span>
<span><span class="va">ames_split</span> <span class="op">&lt;-</span> <span class="fu">initial_split</span><span class="op">(</span><span class="va">ames</span>, prop <span class="op">=</span> <span class="fl">0.80</span>, strata <span class="op">=</span> <span class="va">Sale_Price</span><span class="op">)</span></span>
<span><span class="va">ames_train</span> <span class="op">&lt;-</span> <span class="fu">training</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span><span class="va">ames_test</span> <span class="op">&lt;-</span> <span class="fu">testing</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span></span>
<span><span class="va">ames_rec</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">recipe</span><span class="op">(</span><span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span></span>
<span>    <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span>, data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_log</span><span class="op">(</span><span class="va">Gr_Liv_Area</span>, base <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_other</span><span class="op">(</span><span class="va">Neighborhood</span>, threshold <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_dummy</span><span class="op">(</span><span class="fu">all_nominal_predictors</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_interact</span><span class="op">(</span><span class="op">~</span> <span class="va">Gr_Liv_Area</span><span class="op">:</span><span class="fu">starts_with</span><span class="op">(</span><span class="st">"Bldg_Type_"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_ns</span><span class="op">(</span><span class="va">Latitude</span>, <span class="va">Longitude</span>, deg_free <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_model</span> <span class="op">&lt;-</span> <span class="fu">linear_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">set_engine</span><span class="op">(</span><span class="st">"lm"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_wflow</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">lm_model</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_recipe</span><span class="op">(</span><span class="va">ames_rec</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_fit</span> <span class="op">&lt;-</span> <span class="fu">fit</span><span class="op">(</span><span class="va">lm_wflow</span>, <span class="va">ames_train</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>为了与这个线性模型进行比较，我们可以拟合另一种类型的模型——<strong>随机森林</strong>。随机森林是一种树集成方法，其运作方式是从训练集的略有不同的版本（下采样获得）中训练大量决策树（Breiman，2001a），组合这些树构成集成模型。在预测新样本时，每个决策树都会做出独立的预测，这些预测会被平均，以形成新数据点的最终集成预测。随机森林模型非常强大，它们能够非常精准地模拟潜在的数据模式。虽然这种模型在计算上可能较为密集，但维护成本极低；几乎不需要进行预处理（如附录A中所记载）。</p>
<p>使用与线性模型相同的预测变量集（不包含额外的预处理步骤），我们可以通过”ranger”引擎（来自 <strong>ranger</strong> R包）将随机森林模型拟合到训练集。该模型无需预处理，因此可以使用一个简单的公式：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">rf_model</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">rand_forest</span><span class="op">(</span>trees <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">"ranger"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">"regression"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_wflow</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_formula</span><span class="op">(</span></span>
<span>    <span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span></span>
<span>      <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span></span>
<span>  <span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">rf_model</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_fit</span> <span class="op">&lt;-</span> <span class="va">rf_wflow</span> <span class="op">%&gt;%</span> <span class="fu">fit</span><span class="op">(</span>data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>我们应该如何比较线性模型和随机森林模型呢？为了演示，我们将对训练集进行预测，以生成所谓的表观度量或重代入度量。以下函数用于生成预测并格式化结果：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">estimate_perf</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">model</span>, <span class="va">dat</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="co"># Capture the names of the `model` and `dat` objects</span></span>
<span>  <span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/match.call.html">match.call</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="va">obj_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">cl</span><span class="op">$</span><span class="va">model</span><span class="op">)</span></span>
<span>  <span class="va">data_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/character.html">as.character</a></span><span class="op">(</span><span class="va">cl</span><span class="op">$</span><span class="va">dat</span><span class="op">)</span></span>
<span>  <span class="va">data_name</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/grep.html">gsub</a></span><span class="op">(</span><span class="st">"ames_"</span>, <span class="st">""</span>, <span class="va">data_name</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co"># Estimate these metrics:</span></span>
<span>  <span class="va">reg_metrics</span> <span class="op">&lt;-</span> <span class="fu">metric_set</span><span class="op">(</span><span class="va">rmse</span>, <span class="va">rsq</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">model</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu">bind_cols</span><span class="op">(</span><span class="va">dat</span> <span class="op">%&gt;%</span> <span class="fu">select</span><span class="op">(</span><span class="va">Sale_Price</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu">reg_metrics</span><span class="op">(</span><span class="va">Sale_Price</span>, <span class="va">.pred</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu">select</span><span class="op">(</span><span class="op">-</span><span class="va">.estimator</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>    <span class="fu">mutate</span><span class="op">(</span>object <span class="op">=</span> <span class="va">obj_name</span>, data <span class="op">=</span> <span class="va">data_name</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>重代入统计量计算均方根误差（RMSE）和决定系数（<span class="math inline">\(R_2\)</span>）如下：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">rf_fit</span>, <span class="va">ames_train</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 4</span></span>
<span><span class="co">#&gt;   .metric .estimate object data </span></span>
<span><span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;</span></span>
<span><span class="co">#&gt; 1 rmse       0.0364 rf_fit train</span></span>
<span><span class="co">#&gt; 2 rsq        0.960  rf_fit train</span></span>
<span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">lm_fit</span>, <span class="va">ames_train</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 4</span></span>
<span><span class="co">#&gt;   .metric .estimate object data </span></span>
<span><span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;</span></span>
<span><span class="co">#&gt; 1 rmse       0.0754 lm_fit train</span></span>
<span><span class="co">#&gt; 2 rsq        0.816  lm_fit train</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>基于重代入的结果，随机森林在预测销售价格方面的能力要强得多；其均方根误差（RMSE）估计值比线性回归好两倍。如果我们需要在这两个模型中为价格预测问题做出选择，我们可能会选择随机森林。但如果将随机森林模型应用到测试集进行最终验证时：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">estimate_perf</span><span class="op">(</span><span class="va">rf_fit</span>, <span class="va">ames_test</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 4</span></span>
<span><span class="co">#&gt;   .metric .estimate object data </span></span>
<span><span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;</span></span>
<span><span class="co">#&gt; 1 rmse       0.0701 rf_fit test </span></span>
<span><span class="co">#&gt; 2 rsq        0.853  rf_fit test</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>测试集的均方根误差（RMSE）估计值比训练集的差很多！这是为什么呢？</p>
<p>在统计学中，有一类<strong>低偏差模型</strong>，它们能够从数据中学习复杂的趋势。所谓偏差是指数据中真实的模式（或关系）与模型能够模拟的模式（或关系）之间的差异。许多黑箱机器学习模型具有低偏差特征，它们能够再现复杂的关系；其他模型（如线性/逻辑回归、判别分析等）的适应性较差，被认为是<strong>高偏差模型</strong>。对于低偏差模型而言，其高度的预测能力有时会导致模型几乎记住训练集数据（过拟合）。举一个明显的例子，k=1的最近邻模型，无论在其他数据集上实际表现如何，它总能对训练集做出完美的预测；随机森林模型也类似。对训练集重新预测总会得出对性能的人为乐观估计。</p>
<p>对于这两个模型， <a href="#tbl-10.1" class="quarto-xref">Table&nbsp;1</a> 总结了训练集和测试集的均方根误差（RMSE）估计值。注意，由于线性回归模型的复杂度有限，它在训练集和测试集上的表现是一致的。</p>
<div id="tbl-10.1" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure"><figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-10.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Performance statistics for training and test sets.
</figcaption><div aria-describedby="tbl-10.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="table cell caption-top table-sm table-striped small">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th" style="text-align: left; empty-cells: hide; border-bottom: hidden;"></th>
<th colspan="2" data-quarto-table-cell-role="th" style="text-align: center; border-bottom: hidden; padding-bottom: 0; padding-left: 3px; padding-right: 3px;"><div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
RMSE Estimates
</div></th>
</tr>
<tr class="even">
<th style="text-align: left;" data-quarto-table-cell-role="th">object</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">train</th>
<th style="text-align: right;" data-quarto-table-cell-role="th">test</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">lm_fit</td>
<td style="text-align: right;">0.0754450</td>
<td style="text-align: right;">0.0736297</td>
</tr>
<tr class="even">
<td style="text-align: left;">rf_fit</td>
<td style="text-align: right;">0.0364254</td>
<td style="text-align: right;">0.0700734</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>以上的例子说明：重新预测训练集会导致对模型性能的估计过于乐观，这在大多数模型中都不是一个好主意。如果不能立即使用测试集，且重新预测训练集又不是个好主意，那该怎么办呢？重采样方法，如交叉验证或验证集，就是解决办法。</p>
</section><section id="resampling-methods" class="level2"><h2 class="anchored" data-anchor-id="resampling-methods">Resampling Methods</h2>
<p>重采样方法是一种经验模拟系统，它模拟使用部分数据进行建模、使用不同数据进行评估的过程。大多数重采样方法都是迭代式的，这意味着该过程会重复多次。 <a href="#fig-10.1" class="quarto-xref">Figure&nbsp;1</a> 展示了重采样方法的大致运作方式。</p>
<div id="fig-10.1" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/resampling.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Data splitting scheme from the initial data split to resampling
</figcaption></figure>
</div>
<p>正如你在 <a href="#fig-10.1" class="quarto-xref">Figure&nbsp;1</a> 中所看到的，重抽样仅在训练集上进行，测试集不参与其中。在重抽样的每一次迭代中，数据会被划分为两个子样本：</p>
<ul>
<li><p>分析集（analysis set）：用来训练模型</p></li>
<li><p>评估集（assessment set）：用来评估模型</p></li>
</ul>
<p>这两个子样本在某种程度上类似于训练集和测试集。为了避免混淆，我们使用新的术语——分析集和评估集，两者是互斥的。假设进行20次重抽样迭代，这意味着在分析集上拟合20个独立的模型，而相应的评估集则会产生20组性能统计数据。一个模型的最终性能估计值是这20个统计数据的平均值。这个平均值具有非常好的泛化特性，远优于重新代入估计值。不同的重采样方法会有不同的创建分析集和评估集的方法。下一节将定义几种常用的重采样方法，并讨论它们的优缺点。</p>
<section id="cross-validation" class="level3"><h3 class="anchored" data-anchor-id="cross-validation">Cross-validation</h3>
<p>交叉验证（Cross-validation）是一种成熟的重抽样方法。虽然它有多种变体，但最常见的交叉验证方法是 <strong><em>V</em></strong> <strong>折交叉验证</strong>——数据被随机划分为 <em>V</em> 个大小大致相等的集合（称为折）。 <a href="#fig-10.2" class="quarto-xref">Figure&nbsp;2</a> 展示了 <em>V</em> = 3 的情况：对包含30个训练集样本点的数据，进行折随机分配。图中的数字是样本编号，颜色代表它们被随机分配的折数。分层抽样也是一种分配折数的方法（在5.1节中已讨论过）。</p>
<div id="fig-10.2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/three-CV.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: V-fold cross-validation randomly assigns data to folds
</figcaption></figure>
</div>
<p>对于三折交叉验证，重采样的三次迭代如 <a href="#fig-10.3" class="quarto-xref">Figure&nbsp;3</a> 所示。在每次迭代中，留出一折用作评估集，其余折用作分析集，三折迭代三次，产生三个模型和三组性能统计数据。即，当 <em>V</em> = n 时，分析集占训练集的 (n-1)/n，每个评估集都是不同的 1/n ，最终的重抽样性能估计值是 <em>V</em> 次重复的平均值。</p>
<div id="fig-10.3" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/three-CV-iter.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: V-fold cross-validation data usage
</figcaption></figure>
</div>
<p>此处使用 <em>V</em> = 3 仅为说明交叉验证是一个不错的选择，在实践中，最常用的 <em>V</em> 值是5或10。因为较大的 <em>V</em> 值会导致重采样估计的偏差较小，但方差较大；较小的 <em>V</em> 值则相反——偏差较大，但方差较小。我们通常倾向于将10折交叉验证作为默认选择，因为在大多数情况下，它的规模足以产生良好的结果。</p>
<p>主要输入是训练集和折数 <em>V</em>（默认值为10），生成的对象包含两列：</p>
<ul>
<li>
<code>splits</code>列，包含关于如何分割数据的信息（类似于用于创建初始训练/测试分区的对象）。</li>
<li>
<code>id</code>列，包含折的标识符。</li>
</ul>
<p>虽然<code>splits</code>的每一行都嵌入了整个训练集的副本，但不会在内存中复制数据。打印tibble格式的数据框会显示每一项的频数：<code>[2107/235]</code>表示分析集大约有2000个样本，评估集有235个样本。</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1001</span><span class="op">)</span></span>
<span><span class="va">ames_folds</span> <span class="op">&lt;-</span> <span class="fu">rsample</span><span class="fu">::</span><span class="fu"><a href="https://rsample.tidymodels.org/reference/vfold_cv.html">vfold_cv</a></span><span class="op">(</span><span class="va">ames_train</span>, v <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">ames_folds</span></span>
<span><span class="co">#&gt; #  10-fold cross-validation </span></span>
<span><span class="co">#&gt; # A tibble: 10 × 2</span></span>
<span><span class="co">#&gt;   splits             id    </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt; </span></span>
<span><span class="co">#&gt; 1 &lt;split [2107/235]&gt; Fold01</span></span>
<span><span class="co">#&gt; 2 &lt;split [2107/235]&gt; Fold02</span></span>
<span><span class="co">#&gt; 3 &lt;split [2108/234]&gt; Fold03</span></span>
<span><span class="co">#&gt; 4 &lt;split [2108/234]&gt; Fold04</span></span>
<span><span class="co">#&gt; 5 &lt;split [2108/234]&gt; Fold05</span></span>
<span><span class="co">#&gt; 6 &lt;split [2108/234]&gt; Fold06</span></span>
<span><span class="co">#&gt; # ℹ 4 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>需要手动检索分区数据时，可以使用<code>analysis()</code>和<code>assessment()</code>函数，会返回相应的数据框：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># For the first fold:</span></span>
<span><span class="va">ames_folds</span><span class="op">$</span><span class="va">splits</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">analysis</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 2107   74</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>tidymodels系列包（例如tune包）包含更高级的用户API，因此像<code>analysis()</code>这样的函数通常不需要用于日常工作。10.3节演示了一个在这些重抽样上拟合模型的函数。</p>
<p>交叉验证有多种变体，我们将介绍其中最重要的几种。</p>
<section id="repeated-cross-validation" class="level4"><h4 class="anchored" data-anchor-id="repeated-cross-validation">Repeated cross-validation</h4>
<p>交叉验证最重要的变体是<strong>重复 <em>V</em> 折交叉验证</strong>。根据数据规模或其他特征，V折交叉验证产生的重采样估计可能会有过大的噪声。与许多统计问题一样，减少噪声的一种方法是收集更多数据。对于交叉验证来说，这意味着要获取超过 <em>V</em> 个统计量，然后取平均值。为此，我们只需要重复执行 <em>R</em> 次 <em>V</em> 折交叉验证，就可以获取 <em>V × R</em> 个统计量来得出最终的重抽样估计值。根据中心极限定理，只要我们拥有相对于 <em>V × R</em> 而言足够多的数据，每个模型的汇总统计量就会趋向于正态分布。</p>
<p>考虑Ames数据集，如果选择均方根误差（RMSE）作为统计量，我们可以将该估计值的标准差记为 <span class="math inline">\(\sigma\)</span> 。对于简单的10折交叉验证，平均RMSE的标准误为 <span class="math inline">\(\sigma/\sqrt{10}\)</span> 。如果这一结果噪声过大，重复交叉验证可以将标准误降至 <span class="math inline">\(\sigma/\sqrt{10R}\)</span> 。对于具有 <em>R</em> 次重复的10折交叉验证， <a href="#fig-10.4" class="quarto-xref">Figure&nbsp;4</a> 展示了标准误随重复次数增加而快速降低的情况。</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-10.4" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="10-Resampling-for-Evaluating-Performance_files/figure-html/fig-10.4-1.png" class="img-fluid figure-img" width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Relationship between the relative variance in performance estimates versus the number of cross-validation repeats
</figcaption></figure>
</div>
</div>
</div>
<p>更多的重复次数对标准误差的影响往往较小。然而，如果<span class="math inline">\(\sigma\)</span>的基线值大得不切实际，那么重复次数增加所带来的边际效益递减可能仍然值得额外的计算成本。</p>
<p>创建重复项，可以使用<code>vfold_v()</code>中的参数<code>repeats</code>：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">vfold_cv</span><span class="op">(</span><span class="va">ames_train</span>, v <span class="op">=</span> <span class="fl">10</span>, repeats <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="co">#&gt; #  10-fold cross-validation repeated 5 times </span></span>
<span><span class="co">#&gt; # A tibble: 50 × 3</span></span>
<span><span class="co">#&gt;   splits             id      id2   </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;   &lt;chr&gt; </span></span>
<span><span class="co">#&gt; 1 &lt;split [2107/235]&gt; Repeat1 Fold01</span></span>
<span><span class="co">#&gt; 2 &lt;split [2107/235]&gt; Repeat1 Fold02</span></span>
<span><span class="co">#&gt; 3 &lt;split [2108/234]&gt; Repeat1 Fold03</span></span>
<span><span class="co">#&gt; 4 &lt;split [2108/234]&gt; Repeat1 Fold04</span></span>
<span><span class="co">#&gt; 5 &lt;split [2108/234]&gt; Repeat1 Fold05</span></span>
<span><span class="co">#&gt; 6 &lt;split [2108/234]&gt; Repeat1 Fold06</span></span>
<span><span class="co">#&gt; # ℹ 44 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section><section id="leave-one-out-cross-validation" class="level4"><h4 class="anchored" data-anchor-id="leave-one-out-cross-validation">Leave-one-out cross-validation</h4>
<p>交叉验证的一种变体是<strong>留一法</strong>（leave-one-out，LOO）交叉验证。如果有n个训练集样本，就会使用训练集中的n-1行数据拟合n个模型。每个模型都会对那个被排除的单一数据点进行预测。在重采样结束时，这n个预测结果会被汇总，以生成一个单一的性能统计量。留一法与几乎所有其他方法相比都存在不足，除了样本量极小的情况外，留一法的计算量过大，而且可能不具备良好的统计特性。尽管rsample包中包含一个<code>loo_cv()</code>函数，但这些对象通常并未整合到更广泛的tidymodels框架中。</p>
</section><section id="monte-carlo-cross-validation" class="level4"><h4 class="anchored" data-anchor-id="monte-carlo-cross-validation">Monte Carlo cross-validation</h4>
<p>另一种V折交叉验证的变体是<strong>蒙特卡洛交叉验证</strong>（Monte Carlo cross-validation，MCCV，Xu和Liang（2001））。与V折交叉验证类似，它将固定比例的数据分配给评估集。不同之处在于，每次分配都是随机选择，导致评估集间并非相互排斥。使用<code>mc_cv()</code>函数创建该重采样对象：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">mc_cv</span><span class="op">(</span><span class="va">ames_train</span>, prop <span class="op">=</span> <span class="fl">9</span> <span class="op">/</span> <span class="fl">10</span>, times <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="co">#&gt; # Monte Carlo cross-validation (0.9/0.1) with 20 resamples </span></span>
<span><span class="co">#&gt; # A tibble: 20 × 2</span></span>
<span><span class="co">#&gt;   splits             id        </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;     </span></span>
<span><span class="co">#&gt; 1 &lt;split [2107/235]&gt; Resample01</span></span>
<span><span class="co">#&gt; 2 &lt;split [2107/235]&gt; Resample02</span></span>
<span><span class="co">#&gt; 3 &lt;split [2107/235]&gt; Resample03</span></span>
<span><span class="co">#&gt; 4 &lt;split [2107/235]&gt; Resample04</span></span>
<span><span class="co">#&gt; 5 &lt;split [2107/235]&gt; Resample05</span></span>
<span><span class="co">#&gt; 6 &lt;split [2107/235]&gt; Resample06</span></span>
<span><span class="co">#&gt; # ℹ 14 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section></section><section id="validation-sets" class="level3"><h3 class="anchored" data-anchor-id="validation-sets">Validation sets</h3>
<p>在第5.2节中，我们简要讨论过，验证集是一个单独划分出来的数据集，用于独立于测试集评估模型性能，如 <a href="#fig-10.5" class="quarto-xref">Figure&nbsp;5</a> 。</p>
<div id="fig-10.5" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/validation.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.5-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: A three-way initial split into training, testing, and validation sets
</figcaption></figure>
</div>
<p>当原始数据量非常大时，通常会使用验证集，因为在这种情况下，一个大型的单一分区可能足以描述模型性能，而无需进行多次重采样迭代。借助rsample包，验证集可以像其他任何重抽样对象一样被调用；不同之处仅在于它只有一次迭代。<a href="#fig-10.6" class="quarto-xref">Figure&nbsp;6</a> 展示了这种方案。</p>
<div id="fig-10.6" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/validation-alt.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: A two-way initial split into training and testing with an additional validation set split on the training set
</figcaption></figure>
</div>
<p>使用<code>validation_set()</code>函数，可以将第5.2节代码中<code>initial_validation_split()</code>的结果转换为一个与<code>vfold_cv()</code>等函数生成的结果类似的对象：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Previously:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">52</span><span class="op">)</span></span>
<span><span class="co"># To put 60% into training, 20% in validation, and 20% in testing:</span></span>
<span><span class="va">ames_val_split</span> <span class="op">&lt;-</span> <span class="fu">initial_validation_split</span><span class="op">(</span><span class="va">ames</span>, prop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.6</span>, <span class="fl">0.2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">ames_val_split</span></span>
<span><span class="co">#&gt; &lt;Training/Validation/Testing/Total&gt;</span></span>
<span><span class="co">#&gt; &lt;1758/586/586/2930&gt;</span></span>
<span></span>
<span><span class="co"># Object used for resampling:</span></span>
<span><span class="va">val_set</span> <span class="op">&lt;-</span> <span class="fu">validation_set</span><span class="op">(</span><span class="va">ames_val_split</span><span class="op">)</span></span>
<span><span class="va">val_set</span></span>
<span><span class="co">#&gt; # A tibble: 1 × 2</span></span>
<span><span class="co">#&gt;   splits             id        </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;     </span></span>
<span><span class="co">#&gt; 1 &lt;split [1758/586]&gt; validation</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>正如你将在第10.3节中看到的，<code>fit_resamples()</code>函数将用于通过重采样计算准确的性能估计。<code>val_set</code>对象可以在该函数和其他函数中使用，尽管它只是数据的一次“重采样”。</p>
</section><section id="bootstrapping" class="level3"><h3 class="anchored" data-anchor-id="bootstrapping">Bootstrapping</h3>
<p><strong>自助重采样</strong>最初是用来近似（难以理论推导）统计量的抽样分布（Davison 和 Hinkley，1997），将其用于估计模型性能是该方法的次要应用。</p>
<p>训练集的自助重采样结果是一个与训练集大小相同但通过有放回抽样得到的样本。这意味着一些训练集数据点会被多次选入分析集，且每个数据点至少被选入分析集一次的概率为63.2%；评估集包含所有未被选入分析集的训练集样本（平均而言，占训练集的36.8%）。在自助重采样中，评估集通常被称为袋外样本。</p>
<div class="callout callout-style-default callout-note callout-titled" title="63.8%的由来">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>63.8%的由来
</div>
</div>
<div class="callout-body-container callout-body">
<p>假设有 n 个样本，则每个样本被抽到的概率是 <span class="math inline">\(\frac{1}{n}\)</span>，没有被抽到概率是 <span class="math inline">\(1-\frac{1}{n}\)</span>，重复抽取 n 次都没抽到某个样本的概率为 <span class="math inline">\((1-\frac{1}{n})^n\)</span>。推导极限：</p>
<p><span class="math inline">\(lim_{n\to\infty} (1-\frac{1}{n})^n = \frac{1}{e} \approx 0.3679\)</span></p>
<p>可以看到一次都没抽到的概率是36.8%，至少一次被抽中的概率是63.2%。</p>
</div>
</div>
<p>对于一个包含30个样本的训练集，<a href="#fig-10.7" class="quarto-xref">Figure&nbsp;7</a> 展示了三个自助抽样样本的示意图。请注意，评估集的大小各不相同。</p>
<div id="fig-10.7" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/bootstraps.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Bootstrapping data usage
</figcaption></figure>
</div>
<p>创建自助法重抽样可以使用<code><a href="https://rsample.tidymodels.org/reference/bootstraps.html">rsample::bootstraps()</a></code>函数：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">bootstraps</span><span class="op">(</span><span class="va">ames_train</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="co">#&gt; # Bootstrap sampling </span></span>
<span><span class="co">#&gt; # A tibble: 5 × 2</span></span>
<span><span class="co">#&gt;   splits             id        </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;     </span></span>
<span><span class="co">#&gt; 1 &lt;split [2342/867]&gt; Bootstrap1</span></span>
<span><span class="co">#&gt; 2 &lt;split [2342/869]&gt; Bootstrap2</span></span>
<span><span class="co">#&gt; 3 &lt;split [2342/859]&gt; Bootstrap3</span></span>
<span><span class="co">#&gt; 4 &lt;split [2342/858]&gt; Bootstrap4</span></span>
<span><span class="co">#&gt; 5 &lt;split [2342/873]&gt; Bootstrap5</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>自助重抽样产生的性能估计值的方差非常小（与交叉验证不同），但存在显著的悲观偏差。这意味着，如果一个模型的真实准确率是90%，自助重抽样得出的估计值会低于90%。这种偏差的大小无法通过经验来精度确定，同时，偏差的大小会随着性能指标的范围而变化。例如，当准确率为90%时，其偏差很可能与准确率为70%时的偏差不同。</p>
<p>自助法也被用于许多模型内部。例如，前面提到的随机森林模型包含1000棵独立的决策树，每棵树都是训练集不同自助样本的产物。</p>
</section><section id="rolling-forecasting-origin-resampling" class="level3"><h3 class="anchored" data-anchor-id="rolling-forecasting-origin-resampling">Rolling forecasting origin resampling</h3>
<p>当数据具有很强的时间成分时，重采样方法需要考虑到，模型要估计数据中的季节性和其他时间趋势。从训练集中随机抽样的技术可能会破坏模型估计这些模式的能力。</p>
<p><strong>滚动预测起点重采样</strong>（Rolling forecast origin resampling，Hyndman 和 Athanasopoulos，2018）是一种解决上述问题的方法，该方法模拟了时间序列数据在实际中通常的划分方式，即使用历史数据估计模型，并使用最新数据评估模型。对于这种类型的重采样，需要指定初始分析集和评估集的大小以及每次迭代的偏移量，然后程序从序列的头部开始按照指定大小生成分析集和评估集，然后按照偏移量向尾部移动。</p>
<p>举例来说，对一个包含15个样本的训练集进行重采样，其中分析集为8个样本，评估集为3个样本，每次偏移1个样本。这种配置会产生5个重采样样本，如@fig-10.8 所示。</p>
<div id="fig-10.8" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/rolling.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.8-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Data usage for rolling forecasting origin resampling
</figcaption></figure>
</div>
<p>以下是该方法的两种不同配置：</p>
<ul>
<li><p>分析集可以累积增长（而非保持相同大小）。在第一个初始分析集之后，可以积累新样本，而不丢弃早期数据。</p></li>
<li><p>偏移量不必为1。例如，对于大型数据集，偏移量可以是一周或一个月，而非一天。</p></li>
</ul>
<p>对于一年的数据，假设分析集大小为6组30天的数据，评估集大小为30天的数据，偏移量为29天。<code>rolling_origin()</code>函数的设置如下：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">time_slices</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">tibble</span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">365</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">rolling_origin</span><span class="op">(</span>initial <span class="op">=</span> <span class="fl">6</span> <span class="op">*</span> <span class="fl">30</span>, assess <span class="op">=</span> <span class="fl">30</span>, skip <span class="op">=</span> <span class="fl">29</span>, cumulative <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data_range</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">summarize</span><span class="op">(</span><span class="va">x</span>, first <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, last <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu">map_dfr</span><span class="op">(</span><span class="va">time_slices</span><span class="op">$</span><span class="va">splits</span>, <span class="op">~</span> <span class="fu">analysis</span><span class="op">(</span><span class="va">.x</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">data_range</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 6 × 2</span></span>
<span><span class="co">#&gt;   first  last</span></span>
<span><span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1     1   180</span></span>
<span><span class="co">#&gt; 2    31   210</span></span>
<span><span class="co">#&gt; 3    61   240</span></span>
<span><span class="co">#&gt; 4    91   270</span></span>
<span><span class="co">#&gt; 5   121   300</span></span>
<span><span class="co">#&gt; 6   151   330</span></span>
<span><span class="fu">map_dfr</span><span class="op">(</span><span class="va">time_slices</span><span class="op">$</span><span class="va">splits</span>, <span class="op">~</span> <span class="fu">assessment</span><span class="op">(</span><span class="va">.x</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">data_range</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 6 × 2</span></span>
<span><span class="co">#&gt;   first  last</span></span>
<span><span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1   181   210</span></span>
<span><span class="co">#&gt; 2   211   240</span></span>
<span><span class="co">#&gt; 3   241   270</span></span>
<span><span class="co">#&gt; 4   271   300</span></span>
<span><span class="co">#&gt; 5   301   330</span></span>
<span><span class="co">#&gt; 6   331   360</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section></section><section id="estimating-performance" class="level2"><h2 class="anchored" data-anchor-id="estimating-performance">Estimating Performance</h2>
<p>上面的重采样的流程可以总结为：</p>
<ol type="1">
<li><p>根据分析数据生成预处理，将预处理应用于分析集，并使用这些经过处理的数据来拟合模型。</p></li>
<li><p>将预处理应用于评估集，生成评估集的预测，用以估计模型在新数据上的性能。</p></li>
<li><p>重复1，2两步，最终取所有性能的平均值。</p></li>
</ol>
<p>其中第2步的执行需要使用<code><a href="https://tune.tidymodels.org/reference/fit_resamples.html">tune::fit_resamples()</a></code>。该函数类似于<code>fit()</code>，但它没有<code>data</code>参数，类似的参数是<code>resamples</code>，需要提供一个包含多个重采样样本的<code>rset</code>对象。有分别针对<code>model_spec</code>和<code>workflow</code>的接口：</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">model_spec</span> <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span><span class="va">formula</span>,  <span class="va">resamples</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="va">model_spec</span> <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span><span class="va">recipe</span>,   <span class="va">resamples</span>, <span class="va">...</span><span class="op">)</span></span>
<span><span class="va">workflow</span>   <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span>          <span class="va">resamples</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>其他可选参数：</p>
<ul>
<li><p><code>metrics</code>：<code><a href="https://yardstick.tidymodels.org/reference/metric_set.html">yardstick::metric_set()</a></code>定义的一组性能统计指标。默认情况下，回归模型使用RMSE和<span class="math inline">\(R^2\)</span>，而分类模型计算ROC曲线下面积和总体准确率。请注意，此选择还定义了在模型评估过程中生成哪些预测。对于分类，如果只要求准确率，则不会为评估集生成类别概率估计值（因为不需要）。</p></li>
<li><p><code>control</code>：由<code>control_resamples()</code>创建的包含各种选项的列表。</p></li>
</ul>
<p><code>control_resamples()</code>的控制参数包括：</p>
<ul>
<li><p><code>verbose</code>：用于打印日志的逻辑值。</p></li>
<li><p><code>event_level</code>：二分类时定义那一个类被视为“事件”或“阳性”。</p></li>
<li><p><code>extract</code>：用于从每个模型迭代中保留对象的函数（本章后续会讨论）。</p></li>
<li><p><code>save_pred</code>：用于保存评估集预测结果的逻辑值。</p></li>
<li><p><code>save_workflow</code>：用于保存工作流的逻辑值。</p></li>
<li><p><code>allow_par</code>： 用于启用并行执行的逻辑值。</p></li>
<li><p><code>pkgs</code>：并行运行时需要加载的包列表。</p></li>
<li><p><code>parallel_over</code>：控制并行处理的执行方式，可选“resamples”或“everything”。</p></li>
</ul>
<p>让我们重新考虑一下包含在<code>rf_wflow</code>对象中的随机森林模型，设置保存这些预测结果，以便可视化模型拟合情况和残差：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">keep_pred</span> <span class="op">&lt;-</span> <span class="fu">control_resamples</span><span class="op">(</span>save_pred <span class="op">=</span> <span class="cn">TRUE</span>, save_workflow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1003</span><span class="op">)</span></span>
<span><span class="va">rf_res</span> <span class="op">&lt;-</span></span>
<span>  <span class="va">rf_wflow</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">ames_folds</span>, control <span class="op">=</span> <span class="va">keep_pred</span><span class="op">)</span></span>
<span><span class="va">rf_res</span></span>
<span><span class="co">#&gt; # Resampling results</span></span>
<span><span class="co">#&gt; # 10-fold cross-validation </span></span>
<span><span class="co">#&gt; # A tibble: 10 × 5</span></span>
<span><span class="co">#&gt;   splits             id     .metrics         .notes           .predictions</span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;           &lt;list&gt;      </span></span>
<span><span class="co">#&gt; 1 &lt;split [2107/235]&gt; Fold01 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; 2 &lt;split [2107/235]&gt; Fold02 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; 3 &lt;split [2108/234]&gt; Fold03 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; 4 &lt;split [2108/234]&gt; Fold04 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; 5 &lt;split [2108/234]&gt; Fold05 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; 6 &lt;split [2108/234]&gt; Fold06 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt;    </span></span>
<span><span class="co">#&gt; # ℹ 4 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>返回值是一个与输入的重抽样数据类似的tibble，并附带一些额外的列：</p>
<ul>
<li><p><code>.metrics</code>：保存评估集性能统计数据。</p></li>
<li><p><code>.notes</code>：记录重抽样过程中产生的任何警告或错误。请注意，错误不会终止后续的重抽样执行。</p></li>
<li><p><code>.predictions</code>：保存评估集预测结果，在<code>save_pred = TRUE</code>时存在。</p></li>
</ul>
<p>虽然这些列表列可能看起来令人望而生畏，但可以使用tidyr或tidymodels提供的便捷函数轻松重构它们。例如，<code>collect_metrics()</code>可以返回性能指标结果：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="fu">collect_metrics</span><span class="op">(</span><span class="va">rf_res</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 6</span></span>
<span><span class="co">#&gt;   .metric .estimator   mean     n std_err .config        </span></span>
<span><span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;          </span></span>
<span><span class="co">#&gt; 1 rmse    standard   0.0720    10 0.00306 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 2 rsq     standard   0.832     10 0.0107  pre0_mod0_post0</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>这些是对各个重采样的性能评估结果取平均值后的计值。要获取每个重采样的性能评估结果，请使用选项<code>summarize = FALSE</code>。请注意，这些性能估计值比第10.1节中的重代入估计值要现实得多！</p>
<p><code>collect_predictions()</code>可以获取评估集预测结果：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">assess_res</span> <span class="op">&lt;-</span> <span class="fu">collect_predictions</span><span class="op">(</span><span class="va">rf_res</span><span class="op">)</span></span>
<span><span class="va">assess_res</span></span>
<span><span class="co">#&gt; # A tibble: 2,342 × 5</span></span>
<span><span class="co">#&gt;   .pred id     Sale_Price  .row .config        </span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;          </span></span>
<span><span class="co">#&gt; 1  5.10 Fold01       5.09    10 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 2  4.92 Fold01       4.90    27 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 3  5.21 Fold01       5.08    47 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 4  5.13 Fold01       5.10    52 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 5  5.13 Fold01       5.10    59 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 6  5.13 Fold01       5.11    63 pre0_mod0_post0</span></span>
<span><span class="co">#&gt; # ℹ 2,336 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>预测列名遵循第6章中讨论的parsnip模型约定，以确保一致性和易用性。原始结果列始终使用源数据中的原始列名。<code>.row</code>列是一个整数，与原始训练集的行相匹配，这样这些结果就可以正确排列并与原始数据连接起来。</p>
<p>对于某些重抽样方法，例如自助法或重复交叉验证，原始训练集中的每一行会有多个预测结果。要获得汇总值（重复预测的平均值），请使用<code>collect_predictions(object, summarize = TRUE)</code>。由于本分析采用了10折交叉验证，因此每个训练集样本都有一个独特的预测值。这些数据可以生成有用的模型图表，以了解模型可能在哪些地方出现了问题。例如，<a href="#fig-10.9" class="quarto-xref">Figure&nbsp;9</a> 对比了原始值和预测值（类似于图9.2）：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">assess_res</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">ggplot</span><span class="op">(</span><span class="fu">aes</span><span class="op">(</span>x <span class="op">=</span> <span class="va">Sale_Price</span>, y <span class="op">=</span> <span class="va">.pred</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_point</span><span class="op">(</span>alpha <span class="op">=</span> <span class="fl">.15</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">geom_abline</span><span class="op">(</span>color <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">coord_obs_pred</span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ylab</span><span class="op">(</span><span class="st">"Predicted"</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output-display">
<div id="fig-10.9" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure"><div aria-describedby="fig-10.9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="10-Resampling-for-Evaluating-Performance_files/figure-html/fig-10.9-1.png" class="img-fluid figure-img" width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-10.9-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Out-of-sample observed versus predicted values for an Ames regression model, using log-10 units on both axes
</figcaption></figure>
</div>
</div>
</div>
<p>训练集中有两栋房屋的实际售价较低，但模型对它们的预测价格却明显过高。这两栋房屋是哪两栋呢？让我们从<code>assess_res</code>的结果中找找答案：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">over_predicted</span> <span class="op">&lt;-</span></span>
<span>  <span class="va">assess_res</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">mutate</span><span class="op">(</span>residual <span class="op">=</span> <span class="va">Sale_Price</span> <span class="op">-</span> <span class="va">.pred</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">arrange</span><span class="op">(</span><span class="fu">desc</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">residual</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">slice</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">over_predicted</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 6</span></span>
<span><span class="co">#&gt;   .pred id     Sale_Price  .row .config         residual</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;              &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1  4.96 Fold09       4.11    32 pre0_mod0_post0   -0.857</span></span>
<span><span class="co">#&gt; 2  4.93 Fold08       4.12   317 pre0_mod0_post0   -0.813</span></span>
<span></span>
<span><span class="va">ames_train</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">slice</span><span class="op">(</span><span class="va">over_predicted</span><span class="op">$</span><span class="va">.row</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">select</span><span class="op">(</span><span class="va">Gr_Liv_Area</span>, <span class="va">Neighborhood</span>, <span class="va">Year_Built</span>, <span class="va">Bedroom_AbvGr</span>, <span class="va">Full_Bath</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 5</span></span>
<span><span class="co">#&gt;   Gr_Liv_Area Neighborhood           Year_Built Bedroom_AbvGr Full_Bath</span></span>
<span><span class="co">#&gt;         &lt;int&gt; &lt;fct&gt;                       &lt;int&gt;         &lt;int&gt;     &lt;int&gt;</span></span>
<span><span class="co">#&gt; 1         832 Old_Town                     1923             2         1</span></span>
<span><span class="co">#&gt; 2         733 Iowa_DOT_and_Rail_Road       1952             2         1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>识别出这类表现极其糟糕的样本，有助于我们跟进并调查这些特定预测为何会如此糟糕。</p>
<p>让我们回到整体的房屋情况。我们如何使用验证集而不是交叉验证呢？从我们之前的rsample对象来看：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">val_res</span> <span class="op">&lt;-</span> <span class="va">rf_wflow</span> <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">val_set</span><span class="op">)</span></span>
<span><span class="va">val_res</span></span>
<span><span class="co">#&gt; # Resampling results</span></span>
<span><span class="co">#&gt; # Validation Set (0.75/0.25) </span></span>
<span><span class="co">#&gt; # A tibble: 1 × 4</span></span>
<span><span class="co">#&gt;   splits             id         .metrics         .notes          </span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;      &lt;list&gt;           &lt;list&gt;          </span></span>
<span><span class="co">#&gt; 1 &lt;split [1758/586]&gt; validation &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt;</span></span>
<span></span>
<span><span class="fu">collect_metrics</span><span class="op">(</span><span class="va">val_res</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 2 × 6</span></span>
<span><span class="co">#&gt;   .metric .estimator   mean     n std_err .config        </span></span>
<span><span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;          </span></span>
<span><span class="co">#&gt; 1 rmse    standard   0.0724     1      NA pre0_mod0_post0</span></span>
<span><span class="co">#&gt; 2 rsq     standard   0.824      1      NA pre0_mod0_post0</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>这些结果也比性能的重代入估计值更接近测试集结果。</p>
<p>在这些分析中，重抽样结果与测试集结果非常接近。这两种估计值往往具有良好的相关性。然而，这可能是随机因素导致的。在创建重抽样之前，<code>55</code>这个种子值固定了随机数。试着更改这个值并重新运行分析，以研究重抽样估计值是否也与测试集结果匹配。</p>
</section><section id="parallel-processing" class="level2"><h2 class="anchored" data-anchor-id="parallel-processing">Parallel Processing</h2>
<p>重抽样的每一次评估彼此独立，这类计算极易并行化，都可以毫无问题地同时运行。<strong>tune</strong>包使用<strong>foreach</strong>包来实施并行计算。根据所选技术的不同，这些计算可以分配到同一台计算机的不同处理器上，也可以分配到不同的计算机上。</p>
<p>对于在单台计算机上进行的计算，可能的工作进程数量由<strong>parallel</strong>包决定：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># The number of physical cores in the hardware:</span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 12</span></span>
<span></span>
<span><span class="co"># The number of possible independent processes that can</span></span>
<span><span class="co"># be simultaneously used:</span></span>
<span><span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 24</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>这两个数值之间的差异与计算机的处理器有关。例如，大多数英特尔处理器采用超线程技术，即为每个物理核心创建两个虚拟核心。虽然这些额外的资源能够提升性能，但并行处理所带来的大部分速度提升都出现在处理过程使用的核心数量少于物理核心数量的情况下。</p>
<p>对于<code>fit_resamples()</code>以及tune中的其他函数，当用户注册了并行后端包时，就会进行并行处理。这些R包定义了如何执行并行处理。在Unix和macOS操作系统上，并行计算的一种方法是通过分叉线程（forking threads）。要启用此功能，请加载<strong>doMC</strong>包，并使用foreach注册并行核心的数量：</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># Unix and macOS only</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">doMC</span><span class="op">)</span></span>
<span><span class="fu">registerDoMC</span><span class="op">(</span>cores <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Now run fit_resamples()...</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>这会指示<code>fit_resamples()</code>在两个核心上各运行一半的计算。要将计算重置为顺序处理可以使用<code>registerDoSEQ()</code>。</p>
<p>另一种并行化计算的方法是使用网络套接字。<strong>doParallel</strong>包支持这种方法（所有操作系统都可使用）：</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="co"># All operating systems</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RevolutionAnalytics/doparallel">doParallel</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create a cluster object and then register:</span></span>
<span><span class="va">cl</span> <span class="op">&lt;-</span> <span class="fu">makePSOCKcluster</span><span class="op">(</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu">registerDoParallel</span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Now run fit_resamples()`...</span></span>
<span></span>
<span><span class="fu">stopCluster</span><span class="op">(</span><span class="va">cl</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>另一个并行处理的R包是<strong>future</strong>包。与foreach包类似，它提供了一个并行处理框架。该包通过<strong>doFuture</strong>包与foreach结合使用。（为foreach提供并行后端的R包都以”do”为前缀开头）。</p>
<p>使用tune包进行并行处理时，在前几个核心的情况下往往能带来线性的速度提升。这意味着，使用两个核心时，计算速度会快一倍。根据数据和模型类型的不同，在使用四到五个核心之后，线性速度提升的效果会减弱。使用更多的核心仍然会减少完成任务所需的时间，只是额外核心带来的回报会递减。</p>
<p>让我们用关于并行性的最后一点说明来结束。对于这些技术中的每一种，内存需求会随着所使用的额外核心数量而倍增。例如，如果当前数据集在内存中为2GB，且使用了3个核心，那么总内存需求就是8GB（每个工作进程2GB，再加上原始的2GB）。使用过多的核心可能会导致计算（以及计算机）显著变慢。</p>
</section><section id="saving-the-resampled-objects" class="level2"><h2 class="anchored" data-anchor-id="saving-the-resampled-objects">Saving the Resampled Objects</h2>
<p>重抽样过程中创建的模型不会被保留。这些模型的训练目的是评估性能，在我们计算出性能统计数据后，通常就不再需要它们了。如果某种特定的建模方法被证明是我们数据集的最佳选择，那么最好的做法是再次对整个训练集进行拟合，这样就能利用更多的数据来估计模型参数。</p>
<p>虽然重抽样过程中创建的这些模型不会被保存，但有一种方法可以保留它们或其部分组件——为<code>control_resamples()</code>函数的<code>extract</code>参数提供一个接受单个参数的函数。执行时，无论你是否向<code>fit_resamples()</code>提供了工作流，<code>x</code>都会生成一个拟合好的工作流对象。回想一下，workflows包中包含一些函数，能够提取这些对象的不同组件（例如模型、配方等）。</p>
<p>让我们使用第8章中的recipe对象来拟合一个线性回归模型：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">ames_rec</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">recipe</span><span class="op">(</span><span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span></span>
<span>    <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span>, data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_other</span><span class="op">(</span><span class="va">Neighborhood</span>, threshold <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_dummy</span><span class="op">(</span><span class="fu">all_nominal_predictors</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_interact</span><span class="op">(</span><span class="op">~</span> <span class="va">Gr_Liv_Area</span><span class="op">:</span><span class="fu">starts_with</span><span class="op">(</span><span class="st">"Bldg_Type_"</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_ns</span><span class="op">(</span><span class="va">Latitude</span>, <span class="va">Longitude</span>, deg_free <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_wflow</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_recipe</span><span class="op">(</span><span class="va">ames_rec</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="fu">linear_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">set_engine</span><span class="op">(</span><span class="st">"lm"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_fit</span> <span class="op">&lt;-</span> <span class="va">lm_wflow</span> <span class="op">%&gt;%</span> <span class="fu">fit</span><span class="op">(</span>data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Select the recipe:</span></span>
<span><span class="fu">extract_recipe</span><span class="op">(</span><span class="va">lm_fit</span>, estimated <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ── Recipe ───────────────────────────────────────────────────────────────────</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ── Inputs</span></span>
<span><span class="co">#&gt; Number of variables by role</span></span>
<span><span class="co">#&gt; outcome:   1</span></span>
<span><span class="co">#&gt; predictor: 6</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ── Training information</span></span>
<span><span class="co">#&gt; Training data contained 2342 data points and no incomplete rows.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; ── Operations</span></span>
<span><span class="co">#&gt; • Collapsing factor levels for: Neighborhood | Trained</span></span>
<span><span class="co">#&gt; • Dummy variables from: Neighborhood Bldg_Type | Trained</span></span>
<span><span class="co">#&gt; • Interactions with: Gr_Liv_Area:Bldg_Type_TwoFmCon, ... | Trained</span></span>
<span><span class="co">#&gt; • Natural splines on: Latitude Longitude | Trained</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>我们可以从工作流中保存拟合模型对象的线性模型系数：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">get_model</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu">extract_fit_parsnip</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">tidy</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Test it using:</span></span>
<span><span class="co"># get_model(lm_fit)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>现在让我们将这个函数应用到这10个重抽样拟合结果上。提取函数的结果被包装在一个列表对象中，并以tibble的形式返回：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">ctrl</span> <span class="op">&lt;-</span> <span class="fu">control_resamples</span><span class="op">(</span>extract <span class="op">=</span> <span class="va">get_model</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_res</span> <span class="op">&lt;-</span> <span class="va">lm_wflow</span> <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">ames_folds</span>, control <span class="op">=</span> <span class="va">ctrl</span><span class="op">)</span></span>
<span><span class="va">lm_res</span></span>
<span><span class="co">#&gt; # Resampling results</span></span>
<span><span class="co">#&gt; # 10-fold cross-validation </span></span>
<span><span class="co">#&gt; # A tibble: 10 × 5</span></span>
<span><span class="co">#&gt;   splits             id     .metrics         .notes           .extracts</span></span>
<span><span class="co">#&gt;   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;           &lt;list&gt;   </span></span>
<span><span class="co">#&gt; 1 &lt;split [2107/235]&gt; Fold01 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; 2 &lt;split [2107/235]&gt; Fold02 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; 3 &lt;split [2108/234]&gt; Fold03 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; 4 &lt;split [2108/234]&gt; Fold04 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; 5 &lt;split [2108/234]&gt; Fold05 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; 6 &lt;split [2108/234]&gt; Fold06 &lt;tibble [2 × 4]&gt; &lt;tibble [0 × 4]&gt; &lt;tibble&gt; </span></span>
<span><span class="co">#&gt; # ℹ 4 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>现在有一个包含嵌套 tibble 的.extracts 列。这些包含什么内容呢？让我们通过子集化来一探究竟。</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">lm_res</span><span class="op">$</span><span class="va">.extracts</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="co">#&gt; # A tibble: 1 × 2</span></span>
<span><span class="co">#&gt;   .extracts         .config        </span></span>
<span><span class="co">#&gt;   &lt;list&gt;            &lt;chr&gt;          </span></span>
<span><span class="co">#&gt; 1 &lt;tibble [73 × 5]&gt; pre0_mod0_post0</span></span>
<span></span>
<span><span class="co"># To get the results</span></span>
<span><span class="va">lm_res</span><span class="op">$</span><span class="va">.extracts</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt; # A tibble: 73 × 5</span></span>
<span><span class="co">#&gt;   term                        estimate  std.error statistic   p.value</span></span>
<span><span class="co">#&gt;   &lt;chr&gt;                          &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1 (Intercept)                 1.48     0.320         4.62   4.11e-  6</span></span>
<span><span class="co">#&gt; 2 Gr_Liv_Area                 0.000158 0.00000476   33.2    9.72e-194</span></span>
<span><span class="co">#&gt; 3 Year_Built                  0.00180  0.000149     12.1    1.57e- 32</span></span>
<span><span class="co">#&gt; 4 Neighborhood_College_Creek -0.00163  0.0373       -0.0438 9.65e-  1</span></span>
<span><span class="co">#&gt; 5 Neighborhood_Old_Town      -0.0757   0.0138       -5.47   4.92e-  8</span></span>
<span><span class="co">#&gt; 6 Neighborhood_Edwards       -0.109    0.0310       -3.53   4.21e-  4</span></span>
<span><span class="co">#&gt; # ℹ 67 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>这看起来可能是一种复杂的保存模型结果的方法。然而，<code>extract</code>十分灵活，它并不假设用户每个重抽样只保存一个tibble。例如，<code>tidy()</code>方法既可以在配方上运行，也可以在模型上运行。在这种情况下，会返回一个包含两个 tibble 的列表。</p>
<p>对于我们这个更简单的示例，所有结果都可以使用以下方式进行扁平化处理和收集：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="va">all_coef</span> <span class="op">&lt;-</span> <span class="fu">map_dfr</span><span class="op">(</span><span class="va">lm_res</span><span class="op">$</span><span class="va">.extracts</span>, <span class="op">~</span> <span class="va">.x</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># Show the replicates for a single predictor:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/filter.html">filter</a></span><span class="op">(</span><span class="va">all_coef</span>, <span class="va">term</span> <span class="op">==</span> <span class="st">"Year_Built"</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 10 × 5</span></span>
<span><span class="co">#&gt;   term       estimate std.error statistic  p.value</span></span>
<span><span class="co">#&gt;   &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1 Year_Built  0.00180  0.000149      12.1 1.57e-32</span></span>
<span><span class="co">#&gt; 2 Year_Built  0.00180  0.000151      12.0 6.45e-32</span></span>
<span><span class="co">#&gt; 3 Year_Built  0.00185  0.000150      12.3 1.00e-33</span></span>
<span><span class="co">#&gt; 4 Year_Built  0.00183  0.000147      12.5 1.90e-34</span></span>
<span><span class="co">#&gt; 5 Year_Built  0.00184  0.000150      12.2 2.47e-33</span></span>
<span><span class="co">#&gt; 6 Year_Built  0.00180  0.000150      12.0 3.35e-32</span></span>
<span><span class="co">#&gt; # ℹ 4 more rows</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>第13章和第14章讨论了一套用于模型调优的函数。它们的接口与<code>fit_resamples()</code>类似，并且这里描述的许多功能也适用于这些函数。</p>
</section><section id="chapter-summary" class="level2"><h2 class="anchored" data-anchor-id="chapter-summary">Chapter Summary</h2>
<p>本章介绍了数据分析的基本工具之一，即衡量模型结果的性能和变异性的能力。重抽样使我们能够在不使用测试集的情况下确定模型的运行效果。</p>
<p>介绍了tune包中的一个重要函数，名为<code>fit_resamples()</code>。该函数的接口在后续描述模型调优工具的章节中也会用到。</p>
<p>到目前为止，针对Ames数据的分析代码如下：</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="downlit sourceCode r code-with-copy"><code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidymodels.tidymodels.org">tidymodels</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">ames</span><span class="op">)</span></span>
<span><span class="va">ames</span> <span class="op">&lt;-</span> <span class="fu">mutate</span><span class="op">(</span><span class="va">ames</span>, Sale_Price <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log10</a></span><span class="op">(</span><span class="va">Sale_Price</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">502</span><span class="op">)</span></span>
<span><span class="va">ames_split</span> <span class="op">&lt;-</span> <span class="fu">initial_split</span><span class="op">(</span><span class="va">ames</span>, prop <span class="op">=</span> <span class="fl">0.80</span>, strata <span class="op">=</span> <span class="va">Sale_Price</span><span class="op">)</span></span>
<span><span class="va">ames_train</span> <span class="op">&lt;-</span> <span class="fu">training</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span><span class="va">ames_test</span>  <span class="op">&lt;-</span>  <span class="fu">testing</span><span class="op">(</span><span class="va">ames_split</span><span class="op">)</span></span>
<span></span>
<span><span class="va">ames_rec</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">recipe</span><span class="op">(</span><span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span></span>
<span>           <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span>, data <span class="op">=</span> <span class="va">ames_train</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_log</span><span class="op">(</span><span class="va">Gr_Liv_Area</span>, base <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_other</span><span class="op">(</span><span class="va">Neighborhood</span>, threshold <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_dummy</span><span class="op">(</span><span class="fu">all_nominal_predictors</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_interact</span><span class="op">(</span> <span class="op">~</span> <span class="va">Gr_Liv_Area</span><span class="op">:</span><span class="fu">starts_with</span><span class="op">(</span><span class="st">"Bldg_Type_"</span><span class="op">)</span> <span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">step_ns</span><span class="op">(</span><span class="va">Latitude</span>, <span class="va">Longitude</span>, deg_free <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_model</span> <span class="op">&lt;-</span> <span class="fu">linear_reg</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">set_engine</span><span class="op">(</span><span class="st">"lm"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_wflow</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">lm_model</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_recipe</span><span class="op">(</span><span class="va">ames_rec</span><span class="op">)</span></span>
<span></span>
<span><span class="va">lm_fit</span> <span class="op">&lt;-</span> <span class="fu">fit</span><span class="op">(</span><span class="va">lm_wflow</span>, <span class="va">ames_train</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_model</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">rand_forest</span><span class="op">(</span>trees <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_engine</span><span class="op">(</span><span class="st">"ranger"</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">set_mode</span><span class="op">(</span><span class="st">"regression"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">rf_wflow</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu">workflow</span><span class="op">(</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_formula</span><span class="op">(</span></span>
<span>    <span class="va">Sale_Price</span> <span class="op">~</span> <span class="va">Neighborhood</span> <span class="op">+</span> <span class="va">Gr_Liv_Area</span> <span class="op">+</span> <span class="va">Year_Built</span> <span class="op">+</span> <span class="va">Bldg_Type</span> <span class="op">+</span></span>
<span>      <span class="va">Latitude</span> <span class="op">+</span> <span class="va">Longitude</span><span class="op">)</span> <span class="op">%&gt;%</span></span>
<span>  <span class="fu">add_model</span><span class="op">(</span><span class="va">rf_model</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1001</span><span class="op">)</span></span>
<span><span class="va">ames_folds</span> <span class="op">&lt;-</span> <span class="fu">vfold_cv</span><span class="op">(</span><span class="va">ames_train</span>, v <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="va">keep_pred</span> <span class="op">&lt;-</span> <span class="fu">control_resamples</span><span class="op">(</span>save_pred <span class="op">=</span> <span class="cn">TRUE</span>, save_workflow <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span><span class="op">(</span><span class="fl">1003</span><span class="op">)</span></span>
<span><span class="va">rf_res</span> <span class="op">&lt;-</span> <span class="va">rf_wflow</span> <span class="op">%&gt;%</span> <span class="fu">fit_resamples</span><span class="op">(</span>resamples <span class="op">=</span> <span class="va">ames_folds</span>, control <span class="op">=</span> <span class="va">keep_pred</span><span class="op">)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>


</section><a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><script src="https://utteranc.es/client.js" repo="hanguojun007/Blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../../Books/Tidy Modeling with R/9 Judging Model Effectiveness.html" class="pagination-link" aria-label="9 Judging Model Effectiveness">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">9 Judging Model Effectiveness</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>