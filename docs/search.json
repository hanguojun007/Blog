[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "欢迎来到 RSSPtho，这里有\n\n读书笔记\n工作经验\n流程搭建\nshiny软件\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "一名拥有2年工作经验的生物信息工程师。我对R语言充满热情，致力于使用R语言解决生命科学中的数据。\n\n\n\n中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)\n\n\n\n硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)\n\n\n\n\n\n\nR\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "about.html#工作经历",
    "href": "about.html#工作经历",
    "title": "About me",
    "section": "",
    "text": "中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)"
  },
  {
    "objectID": "about.html#教育经历",
    "href": "about.html#教育经历",
    "title": "About me",
    "section": "",
    "text": "硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)"
  },
  {
    "objectID": "about.html#技能",
    "href": "about.html#技能",
    "title": "About me",
    "section": "",
    "text": "R\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "Books/ggplot2/index.html",
    "href": "Books/ggplot2/index.html",
    "title": "index",
    "section": "",
    "text": "test\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "title": "1 Software for modeling",
    "section": "",
    "text": "模型是能一种能描述系统之间的关系的数学工具，它能够还原或简化关系。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "title": "1 Software for modeling",
    "section": "建模软件的基础",
    "text": "建模软件的基础\n\n用户友好，轻松产生实践。\n科学的方法论，发现隐藏的错误。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "title": "1 Software for modeling",
    "section": "模型类型",
    "text": "模型类型\n\n描述模型\n\n\n推理模型\n假设检验法\n\n\n预测模型\n动力学模型\n经验驱动模型"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "title": "1 Software for modeling",
    "section": "模型类型间的联系",
    "text": "模型类型间的联系"
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html",
    "href": "Books/R4DS2/27 A field guide to base R.html",
    "title": "27 A field guide to base R",
    "section": "",
    "text": "本章介绍一些base R中的重要函数：\n\n提取多个元素——[\n提取单个元素——[&$\napply家族\nfor循环\nPlot\n\n\nlibrary(tidyverse)",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "title": "27 A field guide to base R",
    "section": "提取向量",
    "text": "提取向量\n五种常见情景：\n\n正整数表示元素位置提取，重复提取生成重复元素的向量。\n\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n\n负整数表示删除对应位置的元素。\n\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n\n逻辑向量提取值为TRUE的元素；关于NA的处理与dplyr::filter()不同，前者保留，后者不保留。\n\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# All non-missing values of x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# All even (or missing!) values of x\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\n\n字符串向量提取有name属性的向量元素。\n\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\n\nnothing–x[]返回完整的对象，在后面对data.frame提取时有用。",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "title": "27 A field guide to base R",
    "section": "提取数据框",
    "text": "提取数据框\n使用df[rows, cols]提取数据框中对应的行或列；其中rows和cols与上面的使用方法一致。\n\ndf &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"e\", \"f\"),\n  z = runif(3)\n)\n\n# Select first row and second column\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Select all rows and columns x and y\ndf[, c(\"x\", \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Select rows where `x` is greater than 1 and all columns\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\ndata.frame格式与tibble格式的数据框在使用[上的唯一区别是：当df[,cols]中的cols只有一个元素时，data.frame格式返回向量，而tibble格式仍返回tibble。\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\ndata.frame格式使用drop参数，可以避免降维。\n\ndf1[, \"x\", drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr 中的等价操作",
    "text": "dplyr 中的等价操作\n在dplyr包中有几个verb等价于[的特例：\n\nfilter()：等价于按行使用逻辑向量提取，但对于NA的处理不同，filter()不保留NA，而[保留。\n\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA),\n  y = letters[1:5],\n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n# same as\ndf[!is.na(df$x) & df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\ndf[which(df$x &gt; 1), ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n\narrange()：等价于按行使用正整数向量提取，向量通常由order()生成。\n\n\ndf |&gt; arrange(x, y)\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n# same as\ndf[order(df$x, df$y), ]\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n\nselect() & relocate()：等价于按列使用字符向量提取。\n\n\ndf |&gt; select(x, z)\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290\n\n# same as\ndf[, c(\"x\", \"z\")]\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "href": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "title": "27 A field guide to base R",
    "section": "Data Frames",
    "text": "Data Frames\n[[和$用来提取数据框中的某列；[[可以通过位置或name属性提取，而$只能通过name属性提取。\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# by position\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# by name\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\ndplyr包提取了pull()函数，它等价于[[和$。\n\ntb |&gt; pull(x)\n#&gt; [1] 1 2 3 4",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "href": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "title": "27 A field guide to base R",
    "section": "Tibbles",
    "text": "Tibbles\ndata.frame与tibble在使用$时有着显著的不同；前者遵循部分匹配原则，后者使用精确匹配原则。\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x1\n#&gt; [1] 1\ntb$z\n#&gt; NULL",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr::mutate的等价操作",
    "text": "dplyr::mutate的等价操作\n下面是使用with(),within()和transform()进行等价操作的例子。\n\n\ndata(diamonds, package = \"ggplot2\")\n\n# Most straightforward\ndiamonds$ppc &lt;- diamonds$price / diamonds$carat\n\n# Avoid repeating diamonds\ndiamonds$ppc &lt;- with(diamonds, price / carat)\n\n# The inspiration for dplyr's mutate\ndiamonds &lt;- transform(diamonds, ppc = price / carat)\ndiamonds &lt;- diamonds |&gt; transform(ppc = price / carat)\n\n# Similar to transform(), but uses assignment rather argument matching\n# (can also use = here, since = is equivalent to &lt;- outside of a function call)\ndiamonds &lt;- within(diamonds, {\n  ppc &lt;- price / carat\n})\ndiamonds &lt;- diamonds |&gt; within({\n  ppc &lt;- price / carat\n})\n\n# Protect against partial matching\ndiamonds$ppc &lt;- diamonds[[\"price\"]] / diamonds[[\"carat\"]]\ndiamonds$ppc &lt;- diamonds[, \"price\"] / diamonds[, \"carat\"]\n\n# FORBIDDEN\nattach(diamonds)\ndiamonds$ppc &lt;- price / carat",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#lists",
    "href": "Books/R4DS2/27 A field guide to base R.html#lists",
    "title": "27 A field guide to base R",
    "section": "lists",
    "text": "lists\n[，[[和$都可以提取list中的元素，但[保留原list层级，而[[和$不保留。\n\nl &lt;- list(\n  a = 1:3,\n  b = \"a string\",\n  c = pi,\n  d = list(-1, -5)\n)\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\n两者的差异如下图所示：",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/Advanced R/index.html",
    "href": "Books/Advanced R/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Advanced R的学习笔记。\n原文见：Advanced R\n本书主要包含两方面：\n\nR 语言底层逻辑\n高级编程技巧\n\n下面是全文概览：\n\n第1章：简介。\n第2-8章：R语言基础概念。\n第9-11章：函数编程。\n第12~16章：面向对象编程。\n第17~21章：元编程。\n第22-25章：高级编程技巧。\n\n本书适合在不同阶段，根本不同需求阅读不同章节。\n本书中的练习题解决方案：Advanced R Solutions\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html",
    "href": "Books/Advanced R/3 Vectors.html",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#introduction",
    "href": "Books/Advanced R/3 Vectors.html#introduction",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#atomic-vectors",
    "href": "Books/Advanced R/3 Vectors.html#atomic-vectors",
    "title": "3 Vectors",
    "section": "Atomic vectors",
    "text": "Atomic vectors\nR 中有四类常见的atomic向量：integer、double、character、logical。下面是这四类向量之间的关系图。还有两类不常见的：complex和raw，前者表示复数，后者表示二级制数据。\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \" \"\n        D\n        E\n        F\n        G\n    end\n\n\n\n\n\n\n\nScalars\n上述四种atomic向量都有各自的语法：\n\nlogical：只能使用TRUE/T和FALSE/F。\ndouble：有三种形式：十进制、科学技术法和十六进制；还有三个特殊的符号：NaN、Inf和-Inf。\ninteger：形式同double，但是必须添加L后缀。\ncharacter：使用双引号或单引号包裹，\\进行转义。\n\n\n\nMaking longer vectors with c()\n使用c()函数可以创建长向量，使用typeof()查看对象的类型。\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\ntypeof(lgl_var)\n#&gt; [1] \"logical\"\ntypeof(int_var)\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n#&gt; [1] \"double\"\ntypeof(chr_var)\n#&gt; [1] \"character\"\n\n\n\nMissing values\nNA是not applicable的缩写，表示缺失值。缺失值有一定的‘传染性’：许多包含NA的计算会返回NA。\n\nNA &gt; 5\n#&gt; [1] NA\n10 * NA\n#&gt; [1] NA\n!NA\n#&gt; [1] NA\n\n但有一些特例：\n\nNA^0\n#&gt; [1] 1\nNA | TRUE\n#&gt; [1] TRUE\nNA & FALSE\n#&gt; [1] FALSE\n\n使用is.na()判断是否是NA，而不是==。\n\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n#&gt; [1] NA NA NA NA\nis.na(x)\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n理论上讲：存在四种NA类型，分别对应上述的四种atomic向量：NA(logical)、NA_integer_(integer)、NA_real_(double)、NA_character(character)。但平常使用无需强调，R会自动强制转换。NA默认表示logical是因为下面的强制转换顺序。\n\n\nCoercion\n如上所述，当atomic向量中的元素类型不一致时，R会自动强制转换类型。转换的顺序次序为：character → double → integer → logical。例如，c(\"a\", 1)的结果是c(\"a\", \"1\")。\n\nc(\"a\", 1)\n#&gt; [1] \"a\" \"1\"\n\n强制转换的背后是as.*()函数，例如as.logical()、as.integer()、as.double()、as.character()。转换失败会生成警告信息和缺失值。\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\nTesting\nR 中由类似判断是否是缺失值is.na()的其他函数，但是要小心使用。is.logical()、is.integer()、is.double()、is.character()这四个函数的用法与is.na()相同；is.vector()、is.atomic()、is.numeric()的用法则大不相同。\n\nis.vector()：根据mode参数，判断是否属于atomic向量、list、或expression，同时不能有除name外的其他属性。\nis.atomic()：判断是否属于atomic向量，NULL返回FALSE。\nis.numeric()：属于double、integer或任何可视为数值的向量。\n\n具体细节可以查看R文档。\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#attributes",
    "href": "Books/Advanced R/3 Vectors.html#attributes",
    "title": "3 Vectors",
    "section": "Attributes",
    "text": "Attributes\n\nGetting and setting\n属性可以看作是由键值对构成，附属于对象的元信息。可以使用attr(),attributes(),structure()来提取或设置对象的属性。\n\n# 单独设置\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n# 批量设置\na &lt;- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n属性极易丢失，但有两个例外，通常会保留：name,dim；保留属性需要使用S3面向对象系统。\n\nattributes(a[1])\n#&gt; NULL\nattributes(sum(a))\n#&gt; NULL\n\n\n\nNames\n有三种为向量设定name属性的方法。去除name属性有两种方法.\n\n# When creating it:\nx &lt;- c(a = 1, b = 2, c = 3)\nx\n#&gt; a b c \n#&gt; 1 2 3\nx &lt;- unname(x)\nx\n#&gt; [1] 1 2 3\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\nx\n#&gt; a b c \n#&gt; 1 2 3\nnames(x) &lt;- NULL\nx\n#&gt; [1] 1 2 3\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\nx\n#&gt; a b c \n#&gt; 1 2 3\n\n在创建name属性时，应当保持name唯一且不为缺失值。需要注意这不是R的强制要求。\n\n\nDimensions\natomic向量添加dim属性，就可以生成二维matrix或多维array。在R中可以使用matrix(),array()或dim()来生成。\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\natomic向量的许多函数都对matrix和array进行了推广。\n\n\n\nVector\nMatrix\nArray\n\n\n\n\nnames()\nrownames(),colnames()\ndimnames()\n\n\nlength()\nnrow(),ncol()\ndim()\n\n\nc()\nrbind(),cbind()\nabind::abind()\n\n\n-\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n不能简单地将没有维度的atomic向量视作只有1行或1列的矩阵、1维的数组，因为函数对它们的处理结果是不一样的。\n\nstr(1:3) # 1d vector\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3)) # \"array\" vector\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\nExercises\n\ncomment属性比较特殊，不会被print打印出来，只能使用attr()或attributes()来提取。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#s3-atomic-vectors",
    "href": "Books/Advanced R/3 Vectors.html#s3-atomic-vectors",
    "title": "3 Vectors",
    "section": "S3 atomic vectors",
    "text": "S3 atomic vectors\nclass是另外一个重要的属性，它赋予了对象S3面向对象的能力。每个S3对象由base type构建（base type内容见12章）。本节主要讨论下面四种S3 atomic vectors：\n\nfactor：分类数据。\nDate：日期数据。\nPOSIXct：日期时间数据。\ndifftime：持续时间数据。\n\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \"base atomic\"\n        D\n        E\n        F\n        G\n    end\n    H[factor] --&gt; E\n    I[POSIXct] --&gt; F\n    J[Date] --&gt; F\n    subgraph \"S3 atomic\"\n        H\n        I\n        J\n    end\n\n\n\n\n\n\n\nFactors\nfactor 是在integer类型向量基础上，添加class = fcator和levels两个属性构成。\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\nfactor 有一个变体——ordered factor，它的属性levels具有了顺次意义，例如：low,medium,high等。\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nbase R 中的函数如read.csv(),data.frame()会自动将字符串转换为factor，这种行为很没有道理，因为有时数据中不可能包含全部的level。可以通过stringsAsFactors = FALSE来禁用这种行为。\n\n\nDates\nDate 是在double类型向量基础上，添加class = Date属性构成。去除属性后，可以看到原来的double向量。\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n#&gt; [1] \"double\"\nattributes(today)\n#&gt; $class\n#&gt; [1] \"Date\"\n\n# 底层double向量，思考一下这个数字的含义？\nunclass(today)\n#&gt; [1] 20181\n\n\n\nDate-times\nbase R 提供了两种储存 date-time 的数据格式：POSIXct和POSIXlt。这里我们只关注POSIXct，因为它构建于double类型向上，且在数据框中广泛应用。POSIXct有两个属性：class = POSIXct和tzone。\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#&gt; [1] \"double\"\nattributes(now_ct)\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntzone属性值控制date-time的显示形式，不改变其本质的double数值。\n\nnew_ct &lt;- structure(now_ct, tzone = \"Asia/Tokyo\")\nnew_ct\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nunclass(now_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\nunclass(new_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"Asia/Tokyo\"\n\n\n\nDurations\ndurations 表示date或date-time之间的持续时间，它是在double类型向量基础上，添加class = difftime属性构成，同时有属性units，表示持续时间的单位。\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n#&gt; [1] \"double\"\n#&gt; [1] \"double\"\nattributes(one_week_1)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n#&gt; [1] \"double\"\nattributes(one_week_2)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nExercises\n\n仔细观察下面三个因子的不同。\n\n\n# 数据和level同时反转\nf1 &lt;- factor(letters)\nf1\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\nlevels(f1) &lt;- rev(levels(f1))\nf1\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\n\n# 仅数据反转\nf2 &lt;- rev(factor(letters))\nf2\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f2)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1\n\n# 仅level反转\nf3 &lt;- factor(letters, levels = rev(letters))\nf3\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f3)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#lists",
    "href": "Books/Advanced R/3 Vectors.html#lists",
    "title": "3 Vectors",
    "section": "Lists",
    "text": "Lists\n虽然看起来list中的元素是不同，诚如前章所述，list中的元素有其自己的内存地址，也就是说，list中的元素本质是相同的，只是其索引的内容类型不同。\n\nCreating\n使用函数list()创建list。\n\nl1 &lt;- list(\n  1:3,\n  \"a\",\n  c(TRUE, FALSE, TRUE),\n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#&gt; [1] \"list\"\n\nstr(l1)\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\n如上所述，list的元素只是索引，所以list的实际内存大小可能与你的期望相差甚远。\n\nlobstr::obj_size(mtcars)\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#&gt; 7.29 kB\n\nlist 中的元素可以是其他的list。\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\n\n前面讲到函数c()要求元素类型一致，否则执行强制转换；当list和其他atomic向量使用c()合并时，atomic向量会被强制添加到list中。\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n\n\n\nTesting and coercion\n\n使用typeof()查看是否为list。\n使用as.list()强制转换为list。\n使用unlist()强制转换为atomic向量。\n\n\n# 注意as.list的不同\nl6 &lt;- list(1:3)\nl6\n#&gt; [[1]]\n#&gt; [1] 1 2 3\n\ntypeof(l6)\n#&gt; [1] \"list\"\n\nas.list(1:3)\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\n\nMatrices and arrays\natomic向量添加dim属性后创建出matrix，list添加dim属性后可以创建此出list-matrix、list-array。这些数据结构可以使得处理特殊数据时更加灵活。\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n#&gt; [1] 1 2 3\n\n\n\nExercises\n\n使用[函数提取元素时，当超出范围，atomic向量返回NA，list返回NULL。\n\n\n# Subsetting atomic vectors\n(1:2)[3]\n#&gt; [1] NA\n(1:2)[NA]\n#&gt; [1] NA NA\n\n# Subsetting lists\nas.list(1:2)[3]\n#&gt; [[1]]\n#&gt; NULL\nas.list(1:2)[NA]\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#data-frames-and-tibbles",
    "href": "Books/Advanced R/3 Vectors.html#data-frames-and-tibbles",
    "title": "3 Vectors",
    "section": "Data frames and tibbles",
    "text": "Data frames and tibbles\n最重要的两个以list为基础构建的S3 对象是：data.frame和tibble。\n\n\n\n\n\ngraph BT\n    B[List] --&gt; A(Vector)\n    D[data.frame] --&gt; B(List)\n    C[tibble] --&gt; B(List)\n\n\n\n\n\n\ndataframe有三个属性names、class = data.frame、row.names。names是list本身的属性，表示为有name的list，在dataframe中表示列名；row.names表示行名。同时dataframe要求list中的每个元素长度都相等。作用于list的函数如names()，作用于dataframe时返回的是列名，等价于colnames()、length()返回的是列数，等价于ncol()。\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#&gt; [1] \"list\"\n\nattributes(df1)\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nnames(df1)\n#&gt; [1] \"x\" \"y\"\nlength(df1)\n#&gt; [1] 2\n\ntibble由R包tibble提供，是对dataframe的一种补充，二者由唯一的不同是属性class，tibble有其自己独特的类tbl_df,tbl。类的不同赋予了tibble格式在某些行为上与dataframe有着巨大的差别。下面会详细介绍二者的不同。\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#&gt; [1] \"list\"\n\nattributes(df2)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\n\nCreating\n在使用data.frame()和tibble()函数创建dataframe或tibble时，主要有下面四点不同：\n\n列为字符串时，是否自动转换为因子：在R 4.0.0之前的版本，data.frame()函数默认stringsAsFactors = TRUE，而tibble()函数始终不会将字符串转换为因子。\n\n\ndf1 &lt;- data.frame(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\nstr(df1)\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\ndf2 &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n\n列名不规范时，是否自动转换为合法列名：data.frame()在参数check.names = FALSE时不会转换列名，tibble()函数始终不会转换列名，而是使用“`”包裹列名。\n\n\nnames(data.frame(`1` = 1))\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n#&gt; [1] \"1\"\n\n\n在构建数据框时，如果列之间的长度不同：data.frame()函数会将较短的列自动循环，tibble()函数只会循环长度为1的列，否则报错。\n\n\ndata.frame(x = 1:4, y = 1:2)\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\ndata.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\ntibble(x = 1:4, y = 1:2)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\n\n在构建数据框时，tibble()函数可以使用前面定义好的列的数据。\n\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\n\n\nRow names\ndataframe可以使用data.frame(row.names = ...)或rownames(df) &lt;- ...来赋予数据框行名，但是tibble不支持设置行名（实际是可以设置的，只是不建议这样做）。\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\nrownames(df3)\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\n对于tibble为什么不赞成为数据框设置行名，可以参考原文。dataframe转换为tibble时可以使用rownames_to_column()或as_tibble(rownames = \"rownames\")来保留行名信息。\n\n\nPrinting\n在终端以dataframe或tibble格式分别打印数据，会发现：dataframe将所有行列都打印了出来，而tibble只打印前几行及前几列，同时显示未打印列及行的信息，并且显示每列数据的类型，压缩内容过长的单元格，显示特殊数据比如NA。\n\ndplyr::starwars\n#&gt; # A tibble: 87 × 14\n#&gt;   name           height  mass hair_color  skin_color  eye_color birth_year\n#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Luke Skywalker    172    77 blond       fair        blue            19  \n#&gt; 2 C-3PO             167    75 &lt;NA&gt;        gold        yellow         112  \n#&gt; 3 R2-D2              96    32 &lt;NA&gt;        white, blue red             33  \n#&gt; 4 Darth Vader       202   136 none        white       yellow          41.9\n#&gt; 5 Leia Organa       150    49 brown       light       brown           19  \n#&gt; 6 Owen Lars         178   120 brown, grey light       blue            52  \n#&gt; # ℹ 81 more rows\n#&gt; # ℹ 7 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt;, …\n\n\n\nSubsetting\n在第4章会学到更多有关提取子集的内容，这里介绍两个dataframe在提取子集时的两个缺点：\n\ndf[, vars]提取的列为1时，会自动降维成向量，除非添加参数df[, vars, drop = FALSE]。\ndf$x根据列名提取某列时，如果没有该列，会尝试返回一个字符串开头是x字符的列。\n\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n#&gt;  chr \"a\"\nstr(df2$x)\n#&gt;  NULL\n\n\n\nTesting and coercing\nis.data.frame()可以用来检查是否是dataframe或tibble，is_tibble()只能检查是否是tibble（注意两个函数在形式上的区别.,_）。\n\nis.data.frame(df1)\n#&gt; [1] TRUE\nis.data.frame(df2)\n#&gt; [1] TRUE\n\nis_tibble(df1)\n#&gt; [1] FALSE\nis_tibble(df2)\n#&gt; [1] TRUE\n\n\n\nList columns\n前面我们说过，数据框本质是一个list，所以数据框中的列可以包含任意类型的元素，包括list。tibble本身支持list column，dataframe需要额外的I()函数辅助。\n\n# tibble\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\n# dataframe\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3,\n  y = I(list(1:2, 1:3, 1:4))\n)\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\n\nMatrix and data frame columns\n同上面的list一样，你可以在数据框中添加行数相等的矩阵和数据框。\n\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/3 Vectors.html#null",
    "href": "Books/Advanced R/3 Vectors.html#null",
    "title": "3 Vectors",
    "section": "NULL",
    "text": "NULL\nNULL 的长度为0，类型为NULL，且无法拥有任何属性。\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n#&gt; [1] 0\n\nx &lt;- NULL\nattr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R/12 Base types.html",
    "href": "Books/Advanced R/12 Base types.html",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此对象非彼对象，前者指得是来自于S语言的base object，同我们研究的面向对象(OO object)不是一回事。\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R/12 Base types.html#introduction",
    "href": "Books/Advanced R/12 Base types.html#introduction",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此对象非彼对象，前者指得是来自于S语言的base object，同我们研究的面向对象(OO object)不是一回事。\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R/12 Base types.html#base-vs-oo-objects",
    "href": "Books/Advanced R/12 Base types.html#base-vs-oo-objects",
    "title": "12 Base types",
    "section": "Base VS OO objects",
    "text": "Base VS OO objects\n区分二者的三种方法：\n\nis.object()：base object返回FALSE，OO object返回TRUE。\nsloop::otype()：base object返回base，OO object返回其他，如S3。\nattr()：base object返回NULL，OO object返回class属性。\n\n\nis.object(1:10)\n#&gt; [1] FALSE\nis.object(mtcars)\n#&gt; [1] TRUE\n\nsloop::otype(1:10)\n#&gt; [1] \"base\"\nsloop::otype(mtcars)\n#&gt; [1] \"S3\"\n\nattr(1:10, \"class\")\n#&gt; NULL\nattr(mtcars, \"class\")\n#&gt; [1] \"data.frame\"",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R/12 Base types.html#base-types",
    "href": "Books/Advanced R/12 Base types.html#base-types",
    "title": "12 Base types",
    "section": "Base types",
    "text": "Base types\n无论是OO object还是base object，都有一个base type，使用typeof()来查看；不要使用mode()或storage.mode()，它们只适配S语言。\n\ntypeof(1:10)\n#&gt; [1] \"integer\"\n\ntypeof(mtcars)\n#&gt; [1] \"list\"\n\ntypeof(mean)\n#&gt; [1] \"closure\"\n\nR 的底层使用了C语言中的switch语句来对不同base type执行不同处理。想要新增一个base type需要修改R-core，所以通常不会随意增加base type。截至目前一共有25种base type，下面按照本书中出现的顺序列举。\n\nVector\n\n\n\nbase Type\nC Type\n\n\n\n\nNULL\nNILSXP\n\n\nlogical\nLGLSXP\n\n\ninteger\nINTSXP\n\n\ndouble\nREALSXP\n\n\ncomplex\nCPLXSXP\n\n\ncharacter\nSTRSXP\n\n\nlist\nVECSXP\n\n\nraw\nRAWSXP\n\n\n\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\ntypeof(1L)\n#&gt; [1] \"integer\"\ntypeof(1i)\n#&gt; [1] \"complex\"\n\n\n\nFunctions\n\n\n\nbase Type\nC Type\nfunction type\n\n\n\n\nclosure\nCLOSXP\nregular R functions\n\n\nspecial\nSPECIALSXP\ninternal functions\n\n\nbuiltin\nBUILTINSXP\nprimitive functions\n\n\n\n\ntypeof(mean)\n#&gt; [1] \"closure\"\ntypeof(`[`)\n#&gt; [1] \"special\"\ntypeof(sum)\n#&gt; [1] \"builtin\"\n\n\n\nEnvironments\n\n\n\nbase Type\nC Type\n\n\n\n\nenvironment\nENVSXP\n\n\n\n\ntypeof(globalenv())\n#&gt; [1] \"environment\"\n\n\n\nS4\n\n\n\nbase Type\nC Type\n\n\n\n\nS4\nS4SXP\n\n\n\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\ntypeof(mle_obj)\n#&gt; [1] \"S4\"\n\n\n\nLanguage components\n\n\n\nbase Type\nC Type\n\n\n\n\nsymbol\nSYMSXP\n\n\nlanguage\nLANGSXP\n\n\npairlist\nLISTSXP\n\n\nexpression\nEXPRSXP\n\n\n\n\ntypeof(quote(a))\n#&gt; [1] \"symbol\"\ntypeof(quote(a + 1))\n#&gt; [1] \"language\"\ntypeof(formals(mean))\n#&gt; [1] \"pairlist\"\ntypeof(expression(1 + 0:9))\n#&gt; [1] \"expression\"\n\n\n\nOthers\n\n\n\nbase Type\nC Type\n\n\n\n\nexternalptr\nEXTPTRSXP\n\n\nweakref\nWEAKREFSXP\n\n\nbytecode\nBCODESXP\n\n\npromise\nPROMSXP\n\n\n...\nDOTSXP\n\n\nany\nANYSXP\n\n\n\n\n\nNumeric type\n“numeric”在R中存在三种解读：\n\n某些地方，numeric是double的别名。例如as.numeric()和as.double()等价，numeric()和double()等价。\n在S3和S4系统中，“numeric”用作”integer type”或”double type”的缩写：\n\nsloop::s3_class(1)\n#&gt; [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#&gt; [1] \"integer\" \"numeric\"\n\nis.numeric()用来检测那些行为类似number的对象。例如，因子的本质是”integer type”，但是没有number的行为（求取一个因子的均值毫无意义）。\n\ntypeof(factor(\"x\"))\n#&gt; [1] \"integer\"\nis.numeric(factor(\"x\"))\n#&gt; [1] FALSE\n\n\n本书中的numeric表示integer或double。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Blog/Object in R1.html#成为面对对象的五个条件",
    "href": "Blog/Object in R1.html#成为面对对象的五个条件",
    "title": "R 中的面向对象(1)",
    "section": "成为面对对象的五个条件",
    "text": "成为面对对象的五个条件\n\n类\n对象\n继承\n封装\n多态\n\n定义一个类，这个类有一些属性和方法，方法被封装为接口和实现；类可以实例化一个对象；类之间具有父子关系，子类可以继承父类的属性和方法；不同类的方法名是重复的，可以根据类选择对应的实现，这称之为多态。"
  },
  {
    "objectID": "Blog/Object in R1.html#为什么使用面向对象",
    "href": "Blog/Object in R1.html#为什么使用面向对象",
    "title": "R 中的面向对象(1)",
    "section": "为什么使用面向对象：",
    "text": "为什么使用面向对象：\n\n封装提供了标准的使用接口，能够降低系统的耦合度。\n继承允许子类继承父类的特性，提高了代码的重用性。\n多态允许相同函数对于不同的类有不同的行为，提高了代码的灵活性。\n\n想象一下，当你想更新一个函数的使用方法，但是又得保持和以前的兼容性，你只需要再创建一个子类，然后重新实现父类的方法，就可以了。"
  },
  {
    "objectID": "Blog/Object in R1.html#r-中的面向对象",
    "href": "Blog/Object in R1.html#r-中的面向对象",
    "title": "R 中的面向对象(1)",
    "section": "R 中的面向对象",
    "text": "R 中的面向对象\nR 语言中存在多种面向对象的编程，包括封装类的如RC，R6；泛函类的如S3，S4等。\n\n基于S3的面向对象编程基于泛型函数（generic function），不基于类层级结构,没有类的继承，没有严格的层级结构式继承。\n基于S4的面向对象编程，相对S3健全，实现了类的继承，具有严格的层级结构式类继承，但是是在函数封装过程中同S3一样，基于泛型函数。\n基于RC（也称S5）的面向对象编程则更加完善，符合上面的要求。\n基于R6包的面向对象编程，同样符合上面的要求。\n基于proto包的面向对象编程在ggplot2包中使用。\n基于R.oo包的面向对象编程类似S3。"
  },
  {
    "objectID": "Blog/Object in R1.html#sloop-包",
    "href": "Blog/Object in R1.html#sloop-包",
    "title": "R 中的面向对象(1)",
    "section": "sloop 包",
    "text": "sloop 包\n包中的函数sloop::otype()可以用来检查对象的面向对象编程类型。\n\nlibrary(sloop)\n\notype(1:10)\n#&gt; [1] \"base\"\n\notype(mtcars)\n#&gt; [1] \"S3\"\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\notype(mle_obj)\n#&gt; [1] \"S4\""
  },
  {
    "objectID": "Blog/Code chunks.html",
    "href": "Blog/Code chunks.html",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#label",
    "href": "Blog/Code chunks.html#label",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#execute",
    "href": "Blog/Code chunks.html#execute",
    "title": "quarto 中R代码块的设置",
    "section": "execute",
    "text": "execute\n可以使用execute选项来控制代码块；下面是对可用参数的总结。"
  },
  {
    "objectID": "Blog/Code chunks.html#knitr",
    "href": "Blog/Code chunks.html#knitr",
    "title": "quarto 中R代码块的设置",
    "section": "knitr",
    "text": "knitr\n因为quarto除对R代码块支持外，还支持python、Julia，所以除通用设置execute，quarto 还有R语言特有的设置——knitr。\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\n上面的设置可以自动将R代码的运行结果于代码拼接起来，并使用#&gt;作为注释，达到下面的效果。\n\n1 + 1\n#&gt; 2"
  },
  {
    "objectID": "Blog/Code chunks.html#行代码",
    "href": "Blog/Code chunks.html#行代码",
    "title": "quarto 中R代码块的设置",
    "section": "行代码",
    "text": "行代码\n处理上面使用```{r}的代码块，quarto还使用`r的行代码。"
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html",
    "href": "Books/Advanced R/1 Introduction.html",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#why-r",
    "href": "Books/Advanced R/1 Introduction.html#why-r",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#who-should-read-this-book",
    "href": "Books/Advanced R/1 Introduction.html#who-should-read-this-book",
    "title": "1 Introduction",
    "section": "Who should read this book",
    "text": "Who should read this book\n本书适合两类人：\n\n中级 R 程序员，他们希望更深入地研究 R 语言，理解语言的工作原理，并学习解决各种问题的新策略。\n来自其他语言的程序员，他们正在学习 R，并且想要理解为什么 R 是这样工作的。\n\n为了阅读这本书之前，你需要用 R 或其他编程语言编写大量的代码，熟悉数据分析的基础知识 (即数据导入、操作和可视化) ，熟悉 CRAN 包的安装和使用。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#what-you-will-get-out-of-this-book",
    "href": "Books/Advanced R/1 Introduction.html#what-you-will-get-out-of-this-book",
    "title": "1 Introduction",
    "section": "What you will get out of this book",
    "text": "What you will get out of this book\n阅读本书，你可以：\n\n熟悉 R 的基础知识。你将了解复杂数据类型以及对它们执行操作的最佳方法，对函数如何工作有深入的了解，知道什么是环境，以及如何使用条件系统。\n理解函数式编程的含义，以及为什么它是数据科学的有用工具。你将能够快速学习如何使用现有的工具，并且具备在需要时创建自己的功能性工具的知识。\n了解 R 的各种面向对象系统。你将最熟悉 S3，并且知道 S4 和 R6，以及在需要时在哪里查找更多信息。\n欣赏元编程的双刃剑。你将能够创建使用整洁计算、保存类型和创建优雅代码来表示重要操作的函数，也会明白什么是危险，什么时候应该避免。\n有一个良好的直觉，在 R 中的操作是缓慢的或使用大量的内存。你将知道如何使用分析来查明性能瓶颈，并且知道足够多的 C++ 来将慢速 R 函数转换为快速 C++ 等价物。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#what-you-will-not-learn",
    "href": "Books/Advanced R/1 Introduction.html#what-you-will-not-learn",
    "title": "1 Introduction",
    "section": "What you will not learn",
    "text": "What you will not learn\n本书不涉及：\n\n如何进行数据分析，数据分析推荐R for Data Science。\n如何生成R包，构建R包推荐R packages。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#meta-techniques",
    "href": "Books/Advanced R/1 Introduction.html#meta-techniques",
    "title": "1 Introduction",
    "section": "Meta-techniques",
    "text": "Meta-techniques\n提升编程能力的两个途径：\n\n阅读源代码。\n采用科学思维",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#recommended-reading",
    "href": "Books/Advanced R/1 Introduction.html#recommended-reading",
    "title": "1 Introduction",
    "section": "Recommended reading",
    "text": "Recommended reading\n\nThe Structure and Interpretation of Computer Programs：提升R面向对象的理解。\nConcepts, Techniques and Models of Computer Programming：理解R与其他语言的差异。\nThe Pragmatic Programmer",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#getting-help",
    "href": "Books/Advanced R/1 Introduction.html#getting-help",
    "title": "1 Introduction",
    "section": "Getting help",
    "text": "Getting help\n在遇到困难寻求帮助时，下面是一些问答网站：\n\nRstudio Community\nStackOverflow\nR-help mailing list\n\n在寻求帮助前，你要：\n\n确定你的R版本和R包版本，及环境。\n给出一个复现问题的最小示例（reprex）。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#acknowledgments",
    "href": "Books/Advanced R/1 Introduction.html#acknowledgments",
    "title": "1 Introduction",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n…",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#conventions",
    "href": "Books/Advanced R/1 Introduction.html#conventions",
    "title": "1 Introduction",
    "section": "Conventions",
    "text": "Conventions\n对本书中的一些符号进行说明：\n\nf() 表示函数\ng 表示变量和函数参数\nh/ 表示路径\n#&gt; 表示终端运行结果\nset.seed(1014) 每章固定随机数种子",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/1 Introduction.html#colophon",
    "href": "Books/Advanced R/1 Introduction.html#colophon",
    "title": "1 Introduction",
    "section": "Colophon",
    "text": "Colophon\n书中的R 和 R包版本会实时更新，请阅读原文了解详细信息。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html",
    "href": "Books/Advanced R/2 Names and values.html",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#introduction",
    "href": "Books/Advanced R/2 Names and values.html#introduction",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#binding-basics",
    "href": "Books/Advanced R/2 Names and values.html#binding-basics",
    "title": "2 Names and values",
    "section": "Binding basics",
    "text": "Binding basics\n考虑下面的代码：\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\n我们创建了一个名为x，值为1,2,3的对象，然后复制了一份讲其命名为y。那么，R在内存中是否也复制了一份，也即消耗了2倍的内存呢？事实上，此时消耗的内存并不是两倍，实际情况如下图所示。\n\n解释一下：\n\nc(1,2,3)创建了对象，并占用内存，地址为0x74b。\n&lt;- 为对象绑定一个名字，即x。\ny &lt;- x虽然将x复制了一份，但是x和y的值相同，都是对象c(1,2,3)，所以内存地址是不变。\n\n也即是说：内存和&lt;-后面的对象有关系，后面的不变，内存地址不变，内存消耗几乎不变；&lt;-前面的只是对象绑定的名字，因为实际的内存地址会随着终端变动而发生变动，需要绑定一个标签，你在代码的其他地方可以调用。\n查看对象的地址可以使用lobstr::obj_addr()，当你运行时，结果肯定与我的结果不同，因为终端发生了变动。\n\nobj_addr(x)\n#&gt; [1] \"0x5624fea45098\"\nobj_addr(y)\n#&gt; [1] \"0x5624fea45098\"\n\n请注意：上述说的“x和y的值相同”，与“创建值相同的两个对象”不同。\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 2, 3)\nobj_addr(a)\n#&gt; [1] \"0x562500433d18\"\nobj_addr(b)\n#&gt; [1] \"0x5625004333b8\"\n\n\nNon-syntactic names\nR 中对变量名的要求：必须由字母、数字、.、_构成，但_、数字、.+数字不能位于开头；不能使用关键字，查看关键字?Reserved；使用` 可以将任意字符包裹起来当作变量名；不建议使用'或\"将变量名包裹。\n\n_abc &lt;- 1\n\nif &lt;- 10\n\n`_abc` &lt;- 1\n`_abc`\n\n`if` &lt;- 10\n`if`\n#&gt; Error in parse(text = input): &lt;text&gt;:1:2: unexpected symbol\n#&gt; 1: _abc\n#&gt;      ^\n\n\n\nExercises\n\n下面所指的mean函数内存地址都相同。\n\n\nobj_addr(mean)\n#&gt; [1] \"0x5624f9164638\"\nobj_addr(base::mean)\n#&gt; [1] \"0x5624f9164638\"\nobj_addr(get(\"mean\"))\n#&gt; [1] \"0x5624f9164638\"\nobj_addr(evalq(mean))\n#&gt; [1] \"0x5624f9164638\"\nobj_addr(match.fun(\"mean\"))\n#&gt; [1] \"0x5624f9164638\"\n\n\nutils::read.csv()添加参数check.names = FALSE可以抑制列名的强制转换。\nmake.names()在将非法名转换为合法名时，会遵循下面的规则：\n\n必要时添加前缀X。\n非法字符转换为.。\n缺失值转换为NA。\nR中的关键字后添加.。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#copy-on-modify",
    "href": "Books/Advanced R/2 Names and values.html#copy-on-modify",
    "title": "2 Names and values",
    "section": "Copy-on-modify",
    "text": "Copy-on-modify\n诚如上述，当对象相同时，没有发生内存的消耗；但是如果对y进行了值得修改，那么内存会发生变动，如下所示。\n\ny[[3]] &lt;- 4\nx\n#&gt; [1] 1 2 3\ny\n#&gt; [1] 1 2 4\nobj_addr(x)\n#&gt; [1] \"0x5624fea45098\"\nobj_addr(y)\n#&gt; [1] \"0x5624fd62ba98\"\n\nx绑定得原对象值未改变，R 创建新的对象，重新与y进行绑定。\n\n如果你修改多次对象，R 会创建多个新的对象，然后重新绑定，但是旧的对象不会消失，仍然存在于内存中，如下所示。\n\ny[[3]] &lt;- 5\nobj_addr(y)\n#&gt; [1] \"0x5624fd8f0168\"\n\n\n\n\n\n\n\nNote\n\n\n\n请注意：在Rstudio中进行上述内存地址检查时，会有所不同。\n\n\n\ntracemem()\ntracemem()可以跟踪对象，在对象发生变动时显示变动情况，如下所示。\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x5624fea45098&gt;\n\ny &lt;- x\ny[[3]] &lt;- 4L\n#&gt; tracemem[0x5624fea45098 -&gt; 0x5624fd895a48]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\ny[[3]] &lt;- 5L\n\n使用untracemem()可以停止跟踪，如下所示。\n\nuntracemem(y)\ny[[3]] &lt;- 6L\n\n\n\nFunction calls\n函数生成对象时遵循相同的规则，如下所示。\n\nf &lt;- function(a) {\n  a\n}\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x5624fea45098&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\n\n解释一下：\n\n黄色部分表示函数，有参数a。\n灰色部分表示执行环境，返回函数运行后的结果a。\n因为返回结果和x一致，没有改变对象，所以仍然绑定相同的对象。\n当函数返回结果与x不一致时，会创建新的对象，重新绑定。\n\n\n\nLists\n与上面的向量不同，list格式的对象不仅本身有内存地址指定，它的元素也有内存地址指定。\n下面是一个简单的list对象，虽然看似简单，但是在内存分配上却不简单。\n\nl1 &lt;- list(1, 2, 3)\n\n\n当复制list对象时，同样内存不会发生改变：\n\nl2 &lt;- l1\n\n\n当复制的对象l2发生元素变动时，虽然R会创建一个新的内存地址，但同上面的情况略有不同：对list的复制是浅复制，不会复制所有的元素。与浅复制相对的是深复制，在R 3.1.0之前，都是深复制。\n\nl2[[3]] &lt;- 4\n\n\n使用lobstr::ref()可以查看list中每个元素的内存地址。注意对一个list单独使用，和对两个list同时使用的结果中前面的数字有不同（自己尝试一下）。\n\nref(l1, l2)\n#&gt; █ [1:0x5624fe494b38] &lt;list&gt; \n#&gt; ├─[2:0x5624fe52a930] &lt;dbl&gt; \n#&gt; ├─[3:0x5624fe52a770] &lt;dbl&gt; \n#&gt; └─[4:0x5624fe52a5b0] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [5:0x5624febc92a8] &lt;list&gt; \n#&gt; ├─[2:0x5624fe52a930] \n#&gt; ├─[3:0x5624fe52a770] \n#&gt; └─[6:0x5624fec75e48] &lt;dbl&gt;\n\n关于list中的内存指向，你可以试着嵌套一些复杂的list，然后观察内存分配情况。\n\n\nData frames\ndata.frame 其本质就是list，所以它的行为同list一样。\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nref(d1, d2, d3)\n#&gt; █ [1:0x5624ffa98f88] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x5624ff707c48] &lt;dbl&gt; \n#&gt; └─y = [3:0x5624ff707bf8] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [4:0x5624ffb59868] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x5624ff707c48] \n#&gt; └─y = [5:0x5624ff79dc58] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [6:0x5624ffcda128] &lt;df[,2]&gt; \n#&gt; ├─x = [7:0x5624ff821a48] &lt;dbl&gt; \n#&gt; └─y = [8:0x5624ff8219f8] &lt;dbl&gt;\n\n\n\nCharacter vectors\n对于字符串类型的向量，R 使用全局字符串池来储存字符串。\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\ny &lt;- c(\"a\", \"d\")\nz &lt;- list(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n#&gt; █ [1:0x56250034cf88] &lt;chr&gt; \n#&gt; ├─[2:0x5624f79fad90] &lt;string: \"a\"&gt; \n#&gt; ├─[2:0x5624f79fad90] \n#&gt; ├─[3:0x5624f86d8728] &lt;string: \"abc\"&gt; \n#&gt; └─[4:0x5624f7e68d30] &lt;string: \"d\"&gt;\nref(y, character = TRUE)\n#&gt; █ [1:0x562500c20fb8] &lt;chr&gt; \n#&gt; ├─[2:0x5624f79fad90] &lt;string: \"a\"&gt; \n#&gt; └─[3:0x5624f7e68d30] &lt;string: \"d\"&gt;\nref(z, character = TRUE)\n#&gt; █ [1:0x56250034bcc8] &lt;list&gt; \n#&gt; ├─█ [2:0x5624fe835818] &lt;chr&gt; \n#&gt; │ └─[3:0x5624f79fad90] &lt;string: \"a\"&gt; \n#&gt; ├─█ [4:0x5624fe835658] &lt;chr&gt; \n#&gt; │ └─[3:0x5624f79fad90] \n#&gt; ├─█ [5:0x5624fe835498] &lt;chr&gt; \n#&gt; │ └─[6:0x5624f86d8728] &lt;string: \"abc\"&gt; \n#&gt; └─█ [7:0x5624fe8352d8] &lt;chr&gt; \n#&gt;   └─[8:0x5624f7e68d30] &lt;string: \"d\"&gt;\n\n\n\n\nExercises\n\n1:10在内存中创建了对象，但是没有绑定，R无法对没有name的对象进行操作。\nx最先是integer类型，x[[3]] &lt;- 4 使用了double类型的数据替换，会导致R先复制一份double类型的向量，然后再替换数据。数据类型见下一章。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#object-size",
    "href": "Books/Advanced R/2 Names and values.html#object-size",
    "title": "2 Names and values",
    "section": "Object size",
    "text": "Object size\n使用lobstr::obj_size()可以查看对象的大小。\n\nobj_size(letters)\n#&gt; 1.71 kB\nobj_size(ggplot2::diamonds)\n#&gt; 3.46 MB\n\nlist对象，因为有上述的浅复制机制，实际大小会与想象的不同。\n\nx &lt;- runif(1e6)\nobj_size(x)\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n#&gt; 8.00 MB\n\n上述对象中，y比x要略大一些，大约80b，因为包含了三份空元素的list大小是80b。\n\nobj_size(list(NULL, NULL, NULL))\n#&gt; 80 B\n\n字符串向量也有相同的现象。\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n#&gt; 136 B\nobj_size(rep(banana, 100))\n#&gt; 928 B\n\n\nExercises\n…",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#modify-in-place",
    "href": "Books/Advanced R/2 Names and values.html#modify-in-place",
    "title": "2 Names and values",
    "section": "Modify-in-place",
    "text": "Modify-in-place\n诚如上述，当复制的对象发生值的改动，R会复制一份新，然后再修改值。但存在两个特例：\n\n当对象只绑定了一个name时，会直接修改对象的值。\n环境变量是一个特殊的对象，它总是直接修改对象的值。\n\n\nObjects with a single binding\n上面提到的“当对象只绑定了一个name时，会直接修改对象的值”，我在实际使用中，发现内存地址会发生变化。我简单的在不同系统中进行了实验，推测可能是系统原因。\n\nv &lt;- c(1, 2, 3)\nlobstr::obj_addr(v)\n#&gt; [1] \"0x5624f9ca9778\"\nv[[3]] &lt;- 4\nlobstr::obj_addr(v)\n#&gt; [1] \"0x5624f8529348\"\n\n在R中存在下面两种情况，使得无法准确预测是否会发生复制:\n\nR 对于对象所绑定的name统计只能统计为：0，1，many；一旦对象绑定了多个name，那么就会始终被认为是many，无法回退。\n绝大多数函数都会复制对象，除非是用C语言实现的函数。\n\n例如下面的示例（按道理，上面的示例应该是不会发生变化的）：\n\n# 复制一份对象，a,b的地址是一样的\na &lt;- c(1,2,3)\nb &lt;- a\nlobstr::obj_addr(a)\n#&gt; [1] \"0x5624fec179a8\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x5624fec179a8\"\n# 当把名字a绑定另外一个对象后，在修改b的值，b的内存地址会发生变化\na &lt;- c(2,3,4)\nb[[3]] &lt;- 4\nlobstr::obj_addr(a)\n#&gt; [1] \"0x5624fec512e8\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x5624fec87088\"\n\n上面所描述的对象复制过程，也是R base中for loop缓慢的原因，即for loop本身并不慢，而是因为每次循环都会发生复制修改对象的操作，导致运行缓慢。下面示例中每次循环都会发生两次复制，而转换为list结构时，总共只发生一次复制。\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\n\n# 每次循环都复制两次\ncat(tracemem(x), \"\\n\")\n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x564653d5bca8 -&gt; 0x564656d3b6e8]:\n#&gt; tracemem[0x564656d3b6e8 -&gt; 0x564656d3b838]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3b838 -&gt; 0x564656d3b9f8]:\n#&gt; tracemem[0x564656d3b9f8 -&gt; 0x564656d3bbb8]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bbb8 -&gt; 0x564656d3be58]:\n#&gt; tracemem[0x564656d3be58 -&gt; 0x564656d3bf38]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bf38 -&gt; 0x564656d3c248]:\n#&gt; tracemem[0x564656d3c248 -&gt; 0x564656d3c558]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3c558 -&gt; 0x564656d3cc58]:\n#&gt; tracemem[0x564656d3cc58 -&gt; 0x564656d37838]: [[&lt;-.data.frame [[&lt;-\nuntracemem(x)\n\n\n\n# 总共复制一次\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n#&gt; &lt;0x5625003a2058&gt;\n\nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x5625003a2058 -&gt; 0x56250053df78]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\n\n\nEnvironments\n环境变量储存着对象和name之间的绑定关系，它总是直接修改对象的值，不会进行复制。因为环境本质是一个查找表，存储变量名及其值，如果它们像向量或列表那样每次修改时都进行复制的话，会导致显著的性能开销。\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x5624fef45008\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x5624fef45008\"\n\n\n\ne1$c &lt;- 4\ne2$c\n#&gt; [1] 4\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x5624fef45008\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x5624fef45008\"",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/2 Names and values.html#unbinding-and-the-garbage-collector",
    "href": "Books/Advanced R/2 Names and values.html#unbinding-and-the-garbage-collector",
    "title": "2 Names and values",
    "section": "Unbinding and the garbage collector",
    "text": "Unbinding and the garbage collector\n关于garbage collector（gc），可以总结为以下几点：\n\nrm()只是解除name绑定，不会清除对象。\nR 环境中没有name绑定的对象，使用gc()会被清除掉。\nR 会在内存不足时自动运行gc()，使用gcinfo(TRUE)后，R每次gc()都会输出信息。\n你无需手动运行gc()，这是没有必要的操作。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R/Foundations Introduction.html",
    "href": "Books/Advanced R/Foundations Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "第二章：object和它的name之间的区别。认识到它们的区别，你会在复制对象时更加的小心，因为这涉及内存的消耗，你会明白哪些操作是廉价的，哪些是昂贵的。\n第三章：vector的类型和属性(attributes)。\n第四章：子集操作。\n第五章：控制流，if,for,switch(),while等语句。\n第六章：函数function构建细节，运行机制，退出机制；lazy 语式。\n第七章：R环境的数据结构。\n第八章：控制如何输出错误，警告，信息等。\n\n\n\n\n Back to top",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html",
    "href": "Books/R4DS2/26 Iteration.html",
    "title": "26 Iteration",
    "section": "",
    "text": "在tidyverse中有一些常见的循环操作，如：\n\n绘制分面——facet_wrap(),facet_grid()\n分组总结–group_by(),summarise()\nlist-column解压——unnest_wider(),unnest_longer()\n\n下面我们学习另外一些循环技巧。\n\nlibrary(tidyverse)",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#选择列",
    "href": "Books/R4DS2/26 Iteration.html#选择列",
    "title": "26 Iteration",
    "section": "选择列",
    "text": "选择列\n.cols控制选择哪几列，是一个tidy-select类，类似于dplyr中的select()，可以使用适配select()的函数，如starts_with()、contains()等。\n更多有过关于tidy-select的内容，可以参考?dplyr_tidy_select。\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 × 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数",
    "href": "Books/R4DS2/26 Iteration.html#函数",
    "title": "26 Iteration",
    "section": "函数",
    "text": "函数\n.fns参数提供across()进行call的函数，可以是 - 函数名，例如mean，注意此处函数后不能有() - purrr-style lambda，例如~mean(.x, na.rm = TRUE) - 上述两种函数组成的named list，例如list(mean = mean,n_miss = ~ sum(is.na(.x))\n\n\n\n函数名\n\n# 函数名后有`()`会报错。\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ℹ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\n\n\n\n\npurrr-style lambda\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, ~ median(., na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\n\n\n\n\n函数list\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#列名",
    "href": "Books/R4DS2/26 Iteration.html#列名",
    "title": "26 Iteration",
    "section": "列名",
    "text": "列名\n如果你仔细观察，上面例子中的列名类似于{.col}_{.fn}（这也是为什么函数list是要有name属性的原因）。\n.names参数控制列名定义规则，使用{.col}表示原始列名，{.fn}表示函数名；单个函数默认{.col}，多个函数默认{.col}_{.fn}。\nacross()在与mutate()联用时会将原来的列覆盖，因为.names()默认是{.col}，所以看不出来，当参数值改变后就会直观的体现出来：\n\n\n\n与mutate联用\n\ndf_miss |&gt;\n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n#&gt; # A tibble: 5 × 8\n#&gt;        a      b      c     d a_na_zero b_na_zero c_na_zero d_na_zero\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60      0.434    -1.25      0         1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     0        -1.43     -0.297     0.776\n#&gt; 3 -0.156 -0.980 NA     1.15     -0.156    -0.980     0         1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13     -2.61     -0.683    -0.785     2.13 \n#&gt; 5  1.11  NA     -0.387 0.704     1.11      0        -0.387     0.704",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "href": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "title": "26 Iteration",
    "section": "filter()中的循环",
    "text": "filter()中的循环\ndplyr 提供了两个across()的变体:\n\nif_any()：至少有一个条件返回TRUE\nif_all()：所有条件返回TRUE\n\n\n# same as df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# same as df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "href": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "title": "26 Iteration",
    "section": "与piovt_longer()对比",
    "text": "与piovt_longer()对比\n使用piovt_longer()可以实现across()，反之则不成立。例如下面的两个例子\n\n\n\nacross\n\ndf |&gt;\n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\npivot_longer 复现\n\nlong &lt;- df |&gt;\n  pivot_longer(a:d) |&gt;\n  group_by(name) |&gt;\n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong |&gt;\n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\n只能使用pivot_longer\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\ndf_long &lt;- df_paired |&gt;\n  pivot_longer(\n    everything(),\n    names_to = c(\"group\", \".value\"),\n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 × 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ℹ 34 more rows\n\ndf_long |&gt;\n  group_by(group) |&gt;\n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 × 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "href": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "title": "26 Iteration",
    "section": "返回结果不同",
    "text": "返回结果不同\nmap()函数会返回一个list，其变体则不同。\n\n返回输入值\nwalk()函数只能隐性返回输入，对.f生成的结果没有处理，这在循环绘图中十分便利。\nres &lt;- 1:4 |&gt;\n  walk(\\(x) {\n    hist(rnorm(100, x))\n  })\n\nres\n#&gt; [1] 1 2 3 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n返回结果结构与输入相同\nmodify()函数会输出一个与输入结构完全相同的结果，常用来修改元素类型。\n\n# Convert to characters\niris |&gt; str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\niris |&gt;\n  modify(as.character) |&gt;\n  str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: chr  \"5.1\" \"4.9\" \"4.7\" \"4.6\" ...\n#&gt;  $ Sepal.Width : chr  \"3.5\" \"3\" \"3.2\" \"3.1\" ...\n#&gt;  $ Petal.Length: chr  \"1.4\" \"1.4\" \"1.3\" \"1.5\" ...\n#&gt;  $ Petal.Width : chr  \"0.2\" \"0.2\" \"0.2\" \"0.2\" ...\n#&gt;  $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n其还有变体modify_if()，modify_at()，modify2()，imodify()，使用方法相似，具体差异同下面讲到的一样。\n\n\n返回原子向量\n这一类有map_lgl(),map_int(),map_dbl(),map_chr(),map_vec()；要求返回的原子向量类型为函数名后缀规定的类型，否则报错。例如：map_lgl()函数要求返回结果为由TRUE和FALSE构成的向量，否则报错。map_vec()函数提供了参数.ptype，可以指定返回结果的类型。\n\nnumbers &lt;- list(1, 2, 3, 4)\n\nmap_lgl(numbers, ~ .x %% 2 == 0)\n#&gt; [1] FALSE  TRUE FALSE  TRUE\n\nmap_lgl(numbers, ~ .x * 2)\n#&gt; Error in `map_lgl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a number to a logical.\n\n\n\n返回数据框\n这一类有map_dfc(),map_dfr()，这两类函数在官方文档中已经不再推荐使用，而是使用map() + list_rbind()/list_cbind()的组合方式。\n\n# map ---------------------------------------------\n# Was:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map_dfr(\\(mod) as.data.frame(t(as.matrix(coef(mod)))))\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438\n# Now:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map(\\(mod) as.data.frame(t(as.matrix(coef(mod))))) |&gt;\n  list_rbind()\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "href": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "title": "26 Iteration",
    "section": "输入元素不同",
    "text": "输入元素不同\n这一类有：\n\n对不同位置元素操作：map_at(),map_if(),map_depth()。\n要求元素类型为长度是1的list：lmap()和其变体lmap_at(),lmap_if()。\n\n\nmap_at()\n通过参数.at，提供元素在输入中的位置或name属性，针对特定元素进行操作。\n\nl3 &lt;- list(\n  a = 1:3,\n  b = LETTERS[1:3],\n  c = 7:9\n)\n\nl3 |&gt;\n  map_at(.at = c(\"a\", \"c\"), ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_if()\n通过参数.p，提供元素要满足的条件，针对特定元素进行操作，可以是判断函数，也可以是逻辑向量。\n\nl3 |&gt;\n  map_if(.p = is.numeric, ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_depth()\n通过参数.depth，提供元素的深度，针对该深度处的元素进行操作。\n\nx &lt;- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))\nx |&gt; str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: int [1:2] 1 2\n#&gt;   ..$ bar: int [1:2] 3 4\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: int [1:2] 5 6\n\nx |&gt;\n  map_depth(2, \\(y) paste(y, collapse = \"/\")) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n# Equivalent to:\nx |&gt;\n  map(\\(y) map(y, \\(z) paste(z, collapse = \"/\"))) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n\n\nlmap() 类\nlmap()与map()的不同之处在于，后者提取使用[[i]]来提取list中的元素，返回一个向量，前者使用[i]提取list中的元素，返回一个list。\n由于lmap()操作对象是list，所以它可以使用list中的name属性；在返回结果时，它会使用c()将list合并。下面是一个示例：\n\nadd_minus &lt;- function(x) {\n  res1 &lt;- lapply(x, function(y) y - 1)\n  names(res1) &lt;- paste0(names(x), \"_minus\")\n  res2 &lt;- lapply(x, function(y) y + 1)\n  names(res2) &lt;- paste0(names(x), \"_plus\")\n  c(res1, res2)\n}\n\n# The output size varies each time we map f()\ntest &lt;- list(a = 1:4, c = 8:9)\ntest |&gt;\n  lmap(add_minus) |&gt;\n  str()\n#&gt; List of 4\n#&gt;  $ a_minus: num [1:4] 0 1 2 3\n#&gt;  $ a_plus : num [1:4] 2 3 4 5\n#&gt;  $ c_minus: num [1:2] 7 8\n#&gt;  $ c_plus : num [1:2] 9 10\n\n所以，lmap()对参数.x，.f有不同的要求：\n\n.x：list 或 data.frame\n.f：该函数输入为长度是1的list，输出是任意长度的list。",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "href": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "title": "26 Iteration",
    "section": "函数参数数目",
    "text": "函数参数数目\n这一类函数有map2()、pmap()和map2()的变体imap()。这些函数与map()的使用方法类似，只是多提供了一组或多组.f函数的参数。同时这些函数都有*_lgl(),*_int(), *_dbl(), *_chr(), *_vec(), *_dfc(), *_dfr(),*walk()等变体，使用方法同上。\n\nimap()\nimap()是map2(x, names(x), ...)或map2(x, seq_along(x), ...)的简写，其余使用方法相同。\n\nset.seed(123)\nimap_chr(sample(10), paste)\n#&gt;  [1] \"3 1\"  \"10 2\" \"2 3\"  \"8 4\"  \"6 5\"  \"9 6\"  \"1 7\"  \"7 8\"  \"5 9\"  \"4 10\"",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/index.html",
    "href": "Books/R4DS2/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍R for Data Science的学习笔记。\n原文见：R for Data Science (2e)\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/index.html",
    "href": "Books/Tidy Modeling with R/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Tidy Modeling with R的学习笔记。\n原文见：Tidy Modeling with R\ntidymodels R包官方网站：https://www.tidymodels.org\n本书主要包含两方面：\n\n如何使用tidymodels包进行机器学习建模\n统计建模中的实践经验\n\n下面是全文概览：\n\n第1章：概述模型的分类，强调什么是好的建模软件。\n第2章：回顾 tidyverse 语法。\n第3章：base R中的统计建模总览及其不足。\n第4~9章：tidymodel系列包的介绍：recipes，parsnip，workflows，yardstick等。\n第10~15章：模型性能评估与调参。\n第16~21章：如何理解和解构模型。\n\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html",
    "href": "Books/quarto/Project Basics.html",
    "title": "Project Basics",
    "section": "",
    "text": "原文：https://quarto.org/docs/projects/quarto-projects.html\nquarto的官方网站提供了许多创建项目的教程，如下图，如何创建项目，这里不再赘述。\n\n\n\n官网教程\n\n\n\n\n当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true\n\n\n\n\n使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#shared-metadata",
    "href": "Books/quarto/Project Basics.html#shared-metadata",
    "title": "Project Basics",
    "section": "",
    "text": "当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#rendering-projects",
    "href": "Books/quarto/Project Basics.html#rendering-projects",
    "title": "Project Basics",
    "section": "",
    "text": "使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nquarto 中R代码块的设置\n\n\n\n\n\n\nquarto\n\n\n\n\n\n\n\n\n\n2025-03-15\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nR 中的面向对象(1)\n\n\n\n\n\n\n面向对象\n\n\n\n\n\n\n\n\n\n2025-03-16\n\n\n大番薯本薯\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  }
]