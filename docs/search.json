[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "欢迎来到 RSSPtho，这里有\n\n读书笔记\n工作经验\n流程搭建\nshiny软件\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "一名拥有2年工作经验的生物信息工程师。我对R语言充满热情，致力于使用R语言解决生命科学中的数据。\n\n\n\n中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)\n\n\n\n硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)\n\n\n\n\n\n\nR\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "about.html#工作经历",
    "href": "about.html#工作经历",
    "title": "About me",
    "section": "",
    "text": "中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)"
  },
  {
    "objectID": "about.html#教育经历",
    "href": "about.html#教育经历",
    "title": "About me",
    "section": "",
    "text": "硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)"
  },
  {
    "objectID": "about.html#技能",
    "href": "about.html#技能",
    "title": "About me",
    "section": "",
    "text": "R\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "Books/ggplot2/index.html",
    "href": "Books/ggplot2/index.html",
    "title": "index",
    "section": "",
    "text": "test\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "title": "1 Software for modeling",
    "section": "",
    "text": "模型是能一种能描述系统之间的关系的数学工具，它能够还原或简化关系。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "title": "1 Software for modeling",
    "section": "建模软件的基础",
    "text": "建模软件的基础\n\n用户友好，轻松产生实践。\n科学的方法论，发现隐藏的错误。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "title": "1 Software for modeling",
    "section": "模型类型",
    "text": "模型类型\n\n描述模型\n\n\n推理模型\n假设检验法\n\n\n预测模型\n动力学模型\n经验驱动模型"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "title": "1 Software for modeling",
    "section": "模型类型间的联系",
    "text": "模型类型间的联系"
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html",
    "href": "Books/R4DS2/27 A field guide to base R.html",
    "title": "27 A field guide to base R",
    "section": "",
    "text": "本章介绍一些base R中的重要函数：\n\n提取多个元素——[\n提取单个元素——[&$\napply家族\nfor循环\nPlot\n\n\nlibrary(tidyverse)",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "title": "27 A field guide to base R",
    "section": "提取向量",
    "text": "提取向量\n五种常见情景：\n\n正整数表示元素位置提取，重复提取生成重复元素的向量。\n\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n\n负整数表示删除对应位置的元素。\n\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n\n逻辑向量提取值为TRUE的元素；关于NA的处理与dplyr::filter()不同，前者保留，后者不保留。\n\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# All non-missing values of x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# All even (or missing!) values of x\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\n\n字符串向量提取有name属性的向量元素。\n\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\n\nnothing–x[]返回完整的对象，在后面对data.frame提取时有用。",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "title": "27 A field guide to base R",
    "section": "提取数据框",
    "text": "提取数据框\n使用df[rows, cols]提取数据框中对应的行或列；其中rows和cols与上面的使用方法一致。\n\ndf &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"e\", \"f\"),\n  z = runif(3)\n)\n\n# Select first row and second column\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Select all rows and columns x and y\ndf[, c(\"x\", \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Select rows where `x` is greater than 1 and all columns\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\ndata.frame格式与tibble格式的数据框在使用[上的唯一区别是：当df[,cols]中的cols只有一个元素时，data.frame格式返回向量，而tibble格式仍返回tibble。\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\ndata.frame格式使用drop参数，可以避免降维。\n\ndf1[, \"x\", drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr 中的等价操作",
    "text": "dplyr 中的等价操作\n在dplyr包中有几个verb等价于[的特例：\n\nfilter()：等价于按行使用逻辑向量提取，但对于NA的处理不同，filter()不保留NA，而[保留。\n\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA),\n  y = letters[1:5],\n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n# same as\ndf[!is.na(df$x) & df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\ndf[which(df$x &gt; 1), ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n\narrange()：等价于按行使用正整数向量提取，向量通常由order()生成。\n\n\ndf |&gt; arrange(x, y)\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n# same as\ndf[order(df$x, df$y), ]\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n\nselect() & relocate()：等价于按列使用字符向量提取。\n\n\ndf |&gt; select(x, z)\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290\n\n# same as\ndf[, c(\"x\", \"z\")]\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "href": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "title": "27 A field guide to base R",
    "section": "Data Frames",
    "text": "Data Frames\n[[和$用来提取数据框中的某列；[[可以通过位置或name属性提取，而$只能通过name属性提取。\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# by position\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# by name\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\ndplyr包提取了pull()函数，它等价于[[和$。\n\ntb |&gt; pull(x)\n#&gt; [1] 1 2 3 4",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "href": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "title": "27 A field guide to base R",
    "section": "Tibbles",
    "text": "Tibbles\ndata.frame与tibble在使用$时有着显著的不同；前者遵循部分匹配原则，后者使用精确匹配原则。\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x1\n#&gt; [1] 1\ntb$z\n#&gt; NULL",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr::mutate的等价操作",
    "text": "dplyr::mutate的等价操作\n下面是使用with(),within()和transform()进行等价操作的例子。\n\n\ndata(diamonds, package = \"ggplot2\")\n\n# Most straightforward\ndiamonds$ppc &lt;- diamonds$price / diamonds$carat\n\n# Avoid repeating diamonds\ndiamonds$ppc &lt;- with(diamonds, price / carat)\n\n# The inspiration for dplyr's mutate\ndiamonds &lt;- transform(diamonds, ppc = price / carat)\ndiamonds &lt;- diamonds |&gt; transform(ppc = price / carat)\n\n# Similar to transform(), but uses assignment rather argument matching\n# (can also use = here, since = is equivalent to &lt;- outside of a function call)\ndiamonds &lt;- within(diamonds, {\n  ppc &lt;- price / carat\n})\ndiamonds &lt;- diamonds |&gt; within({\n  ppc &lt;- price / carat\n})\n\n# Protect against partial matching\ndiamonds$ppc &lt;- diamonds[[\"price\"]] / diamonds[[\"carat\"]]\ndiamonds$ppc &lt;- diamonds[, \"price\"] / diamonds[, \"carat\"]\n\n# FORBIDDEN\nattach(diamonds)\ndiamonds$ppc &lt;- price / carat",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#lists",
    "href": "Books/R4DS2/27 A field guide to base R.html#lists",
    "title": "27 A field guide to base R",
    "section": "lists",
    "text": "lists\n[，[[和$都可以提取list中的元素，但[保留原list层级，而[[和$不保留。\n\nl &lt;- list(\n  a = 1:3,\n  b = \"a string\",\n  c = pi,\n  d = list(-1, -5)\n)\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\n两者的差异如下图所示：",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/index.html",
    "href": "Books/Advanced R(2e)/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Advanced R的学习笔记。\n原文见：Advanced R\n本书主要包含两方面：\n\nR 语言底层逻辑\n高级编程技巧\n\n下面是全文概览：\n\n第1章：简介。\n第2-8章：R语言基础概念。\n第9-11章：函数编程。\n第12~16章：面向对象编程。\n第17~21章：元编程。\n第22-25章：高级编程技巧。\n\n本书适合在不同阶段，根本不同需求阅读不同章节。\n本书中的练习题解决方案：Advanced R Solutions\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html",
    "href": "Books/Advanced R(2e)/3 Vectors.html",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#introduction",
    "href": "Books/Advanced R(2e)/3 Vectors.html#introduction",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#atomic-vectors",
    "href": "Books/Advanced R(2e)/3 Vectors.html#atomic-vectors",
    "title": "3 Vectors",
    "section": "Atomic vectors",
    "text": "Atomic vectors\nR 中有四类常见的atomic向量：integer、double、character、logical。下面是这四类向量之间的关系图。还有两类不常见的：complex和raw，前者表示复数，后者表示二级制数据。\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \" \"\n        D\n        E\n        F\n        G\n    end\n\n\n\n\n\n\n\nScalars\n上述四种atomic向量都有各自的语法：\n\nlogical：只能使用TRUE/T和FALSE/F。\ndouble：有三种形式：十进制、科学技术法和十六进制；还有三个特殊的符号：NaN、Inf和-Inf。\ninteger：形式同double，但是必须添加L后缀。\ncharacter：使用双引号或单引号包裹，\\进行转义。\n\n\n\nMaking longer vectors with c()\n使用c()函数可以创建长向量，使用typeof()查看对象的类型。\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\ntypeof(lgl_var)\n#&gt; [1] \"logical\"\ntypeof(int_var)\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n#&gt; [1] \"double\"\ntypeof(chr_var)\n#&gt; [1] \"character\"\n\n\n\nMissing values\nNA是not applicable的缩写，表示缺失值。缺失值有一定的‘传染性’：许多包含NA的计算会返回NA。\n\nNA &gt; 5\n#&gt; [1] NA\n10 * NA\n#&gt; [1] NA\n!NA\n#&gt; [1] NA\n\n但有一些特例：\n\nNA^0\n#&gt; [1] 1\nNA | TRUE\n#&gt; [1] TRUE\nNA & FALSE\n#&gt; [1] FALSE\n\n使用is.na()判断是否是NA，而不是==。\n\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n#&gt; [1] NA NA NA NA\nis.na(x)\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n理论上讲：存在四种NA类型，分别对应上述的四种atomic向量：NA(logical)、NA_integer_(integer)、NA_real_(double)、NA_character(character)。但平常使用无需强调，R会自动强制转换。NA默认表示logical是因为下面的强制转换顺序。\n\n\nCoercion\n如上所述，当atomic向量中的元素类型不一致时，R会自动强制转换类型。转换的顺序次序为：character → double → integer → logical。例如，c(\"a\", 1)的结果是c(\"a\", \"1\")。\n\nc(\"a\", 1)\n#&gt; [1] \"a\" \"1\"\n\n强制转换的背后是as.*()函数，例如as.logical()、as.integer()、as.double()、as.character()。转换失败会生成警告信息和缺失值。\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\nTesting\nR 中由类似判断是否是缺失值is.na()的其他函数，但是要小心使用。is.logical()、is.integer()、is.double()、is.character()这四个函数的用法与is.na()相同；is.vector()、is.atomic()、is.numeric()的用法则大不相同。\n\nis.vector()：根据mode参数，判断是否属于atomic向量、list、或expression，同时不能有除name外的其他属性。\nis.atomic()：判断是否属于atomic向量，NULL返回FALSE。\nis.numeric()：属于double、integer或任何可视为数值的向量。\n\n具体细节可以查看R文档。\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#attributes",
    "href": "Books/Advanced R(2e)/3 Vectors.html#attributes",
    "title": "3 Vectors",
    "section": "Attributes",
    "text": "Attributes\n\nGetting and setting\n属性可以看作是由键值对构成，附属于对象的元信息。可以使用attr(),attributes(),structure()来提取或设置对象的属性。\n\n# 单独设置\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n# 批量设置\na &lt;- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n属性极易丢失，但有两个例外，通常会保留：name,dim；保留属性需要使用S3面向对象系统。\n\nattributes(a[1])\n#&gt; NULL\nattributes(sum(a))\n#&gt; NULL\n\n\n\nNames\n有三种为向量设定name属性的方法。去除name属性有两种方法.\n\n# When creating it:\nx &lt;- c(a = 1, b = 2, c = 3)\nx\n#&gt; a b c \n#&gt; 1 2 3\nx &lt;- unname(x)\nx\n#&gt; [1] 1 2 3\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\nx\n#&gt; a b c \n#&gt; 1 2 3\nnames(x) &lt;- NULL\nx\n#&gt; [1] 1 2 3\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\nx\n#&gt; a b c \n#&gt; 1 2 3\n\n在创建name属性时，应当保持name唯一且不为缺失值。需要注意这不是R的强制要求。\n\n\nDimensions\natomic向量添加dim属性，就可以生成二维matrix或多维array。在R中可以使用matrix(),array()或dim()来生成。\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\natomic向量的许多函数都对matrix和array进行了推广。\n\n\n\nVector\nMatrix\nArray\n\n\n\n\nnames()\nrownames(),colnames()\ndimnames()\n\n\nlength()\nnrow(),ncol()\ndim()\n\n\nc()\nrbind(),cbind()\nabind::abind()\n\n\n-\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n不能简单地将没有维度的atomic向量视作只有1行或1列的矩阵、1维的数组，因为函数对它们的处理结果是不一样的。\n\nstr(1:3) # 1d vector\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3)) # \"array\" vector\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\nExercises\n\ncomment属性比较特殊，不会被print打印出来，只能使用attr()或attributes()来提取。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#s3-atomic-vectors",
    "href": "Books/Advanced R(2e)/3 Vectors.html#s3-atomic-vectors",
    "title": "3 Vectors",
    "section": "S3 atomic vectors",
    "text": "S3 atomic vectors\nclass是另外一个重要的属性，它赋予了对象S3面向对象的能力。每个S3对象由base type构建（base type内容见12章）。本节主要讨论下面四种S3 atomic vectors：\n\nfactor：分类数据。\nDate：日期数据。\nPOSIXct：日期时间数据。\ndifftime：持续时间数据。\n\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \"base atomic\"\n        D\n        E\n        F\n        G\n    end\n    H[factor] --&gt; E\n    I[POSIXct] --&gt; F\n    J[Date] --&gt; F\n    subgraph \"S3 atomic\"\n        H\n        I\n        J\n    end\n\n\n\n\n\n\n\nFactors\nfactor 是在integer类型向量基础上，添加class = fcator和levels两个属性构成。\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\nfactor 有一个变体——ordered factor，它的属性levels具有了顺次意义，例如：low,medium,high等。\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nbase R 中的函数如read.csv(),data.frame()会自动将字符串转换为factor，这种行为很没有道理，因为有时数据中不可能包含全部的level。可以通过stringsAsFactors = FALSE来禁用这种行为。\n\n\nDates\nDate 是在double类型向量基础上，添加class = Date属性构成。去除属性后，可以看到原来的double向量。\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n#&gt; [1] \"double\"\nattributes(today)\n#&gt; $class\n#&gt; [1] \"Date\"\n\n# 底层double向量，思考一下这个数字的含义？\nunclass(today)\n#&gt; [1] 20183\n\n\n\nDate-times\nbase R 提供了两种储存 date-time 的数据格式：POSIXct和POSIXlt。这里我们只关注POSIXct，因为它构建于double类型向上，且在数据框中广泛应用。POSIXct有两个属性：class = POSIXct和tzone。\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#&gt; [1] \"double\"\nattributes(now_ct)\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntzone属性值控制date-time的显示形式，不改变其本质的double数值。\n\nnew_ct &lt;- structure(now_ct, tzone = \"Asia/Tokyo\")\nnew_ct\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nunclass(now_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\nunclass(new_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"Asia/Tokyo\"\n\n\n\nDurations\ndurations 表示date或date-time之间的持续时间，它是在double类型向量基础上，添加class = difftime属性构成，同时有属性units，表示持续时间的单位。\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n#&gt; [1] \"double\"\n#&gt; [1] \"double\"\nattributes(one_week_1)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n#&gt; [1] \"double\"\nattributes(one_week_2)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nExercises\n\n仔细观察下面三个因子的不同。\n\n\n# 数据和level同时反转\nf1 &lt;- factor(letters)\nf1\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\nlevels(f1) &lt;- rev(levels(f1))\nf1\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\n\n# 仅数据反转\nf2 &lt;- rev(factor(letters))\nf2\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f2)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1\n\n# 仅level反转\nf3 &lt;- factor(letters, levels = rev(letters))\nf3\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f3)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#lists",
    "href": "Books/Advanced R(2e)/3 Vectors.html#lists",
    "title": "3 Vectors",
    "section": "Lists",
    "text": "Lists\n虽然看起来list中的元素是不同，诚如前章所述，list中的元素有其自己的内存地址，也就是说，list中的元素本质是相同的，只是其索引的内容类型不同。\n\nCreating\n使用函数list()创建list。\n\nl1 &lt;- list(\n  1:3,\n  \"a\",\n  c(TRUE, FALSE, TRUE),\n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#&gt; [1] \"list\"\n\nstr(l1)\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\n如上所述，list的元素只是索引，所以list的实际内存大小可能与你的期望相差甚远。\n\nlobstr::obj_size(mtcars)\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#&gt; 7.29 kB\n\nlist 中的元素可以是其他的list。\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\n\n前面讲到函数c()要求元素类型一致，否则执行强制转换；当list和其他atomic向量使用c()合并时，atomic向量会被强制添加到list中。\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n\n\n\nTesting and coercion\n\n使用typeof()查看是否为list。\n使用as.list()强制转换为list。\n使用unlist()强制转换为atomic向量。\n\n\n# 注意as.list的不同\nl6 &lt;- list(1:3)\nl6\n#&gt; [[1]]\n#&gt; [1] 1 2 3\n\ntypeof(l6)\n#&gt; [1] \"list\"\n\nas.list(1:3)\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\n\nMatrices and arrays\natomic向量添加dim属性后创建出matrix，list添加dim属性后可以创建此出list-matrix、list-array。这些数据结构可以使得处理特殊数据时更加灵活。\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n#&gt; [1] 1 2 3\n\n\n\nExercises\n\n使用[函数提取元素时，当超出范围，atomic向量返回NA，list返回NULL。\n\n\n# Subsetting atomic vectors\n(1:2)[3]\n#&gt; [1] NA\n(1:2)[NA]\n#&gt; [1] NA NA\n\n# Subsetting lists\nas.list(1:2)[3]\n#&gt; [[1]]\n#&gt; NULL\nas.list(1:2)[NA]\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#data-frames-and-tibbles",
    "href": "Books/Advanced R(2e)/3 Vectors.html#data-frames-and-tibbles",
    "title": "3 Vectors",
    "section": "Data frames and tibbles",
    "text": "Data frames and tibbles\n最重要的两个以list为基础构建的S3 对象是：data.frame和tibble。\n\n\n\n\n\ngraph BT\n    B[List] --&gt; A(Vector)\n    D[data.frame] --&gt; B(List)\n    C[tibble] --&gt; B(List)\n\n\n\n\n\n\ndataframe有三个属性names、class = data.frame、row.names。names是list本身的属性，表示为有name的list，在dataframe中表示列名；row.names表示行名。同时dataframe要求list中的每个元素长度都相等。作用于list的函数如names()，作用于dataframe时返回的是列名，等价于colnames()、length()返回的是列数，等价于ncol()。\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#&gt; [1] \"list\"\n\nattributes(df1)\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nnames(df1)\n#&gt; [1] \"x\" \"y\"\nlength(df1)\n#&gt; [1] 2\n\ntibble由R包tibble提供，是对dataframe的一种补充，二者由唯一的不同是属性class，tibble有其自己独特的类tbl_df,tbl。类的不同赋予了tibble格式在某些行为上与dataframe有着巨大的差别。下面会详细介绍二者的不同。\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#&gt; [1] \"list\"\n\nattributes(df2)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\n\nCreating\n在使用data.frame()和tibble()函数创建dataframe或tibble时，主要有下面四点不同：\n\n列为字符串时，是否自动转换为因子：在R 4.0.0之前的版本，data.frame()函数默认stringsAsFactors = TRUE，而tibble()函数始终不会将字符串转换为因子。\n\n\ndf1 &lt;- data.frame(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\nstr(df1)\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\ndf2 &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n\n列名不规范时，是否自动转换为合法列名：data.frame()在参数check.names = FALSE时不会转换列名，tibble()函数始终不会转换列名，而是使用“`”包裹列名。\n\n\nnames(data.frame(`1` = 1))\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n#&gt; [1] \"1\"\n\n\n在构建数据框时，如果列之间的长度不同：data.frame()函数会将较短的列自动循环，tibble()函数只会循环长度为1的列，否则报错。\n\n\ndata.frame(x = 1:4, y = 1:2)\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\ndata.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\ntibble(x = 1:4, y = 1:2)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\n\n在构建数据框时，tibble()函数可以使用前面定义好的列的数据。\n\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\n\n\nRow names\ndataframe可以使用data.frame(row.names = ...)或rownames(df) &lt;- ...来赋予数据框行名，但是tibble不支持设置行名（实际是可以设置的，只是不建议这样做）。\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\nrownames(df3)\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\n对于tibble为什么不赞成为数据框设置行名，可以参考原文。dataframe转换为tibble时可以使用rownames_to_column()或as_tibble(rownames = \"rownames\")来保留行名信息。\n\n\nPrinting\n在终端以dataframe或tibble格式分别打印数据，会发现：dataframe将所有行列都打印了出来，而tibble只打印前几行及前几列，同时显示未打印列及行的信息，并且显示每列数据的类型，压缩内容过长的单元格，显示特殊数据比如NA。\n\ndplyr::starwars\n#&gt; # A tibble: 87 × 14\n#&gt;   name           height  mass hair_color  skin_color  eye_color birth_year\n#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Luke Skywalker    172    77 blond       fair        blue            19  \n#&gt; 2 C-3PO             167    75 &lt;NA&gt;        gold        yellow         112  \n#&gt; 3 R2-D2              96    32 &lt;NA&gt;        white, blue red             33  \n#&gt; 4 Darth Vader       202   136 none        white       yellow          41.9\n#&gt; 5 Leia Organa       150    49 brown       light       brown           19  \n#&gt; 6 Owen Lars         178   120 brown, grey light       blue            52  \n#&gt; # ℹ 81 more rows\n#&gt; # ℹ 7 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt;, …\n\n\n\nSubsetting\n在第4章会学到更多有关提取子集的内容，这里介绍两个dataframe在提取子集时的两个缺点：\n\ndf[, vars]提取的列为1时，会自动降维成向量，除非添加参数df[, vars, drop = FALSE]。\ndf$x根据列名提取某列时，如果没有该列，会尝试返回一个字符串开头是x字符的列。\n\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n#&gt;  chr \"a\"\nstr(df2$x)\n#&gt;  NULL\n\n\n\nTesting and coercing\nis.data.frame()可以用来检查是否是dataframe或tibble，is_tibble()只能检查是否是tibble（注意两个函数在形式上的区别.,_）。\n\nis.data.frame(df1)\n#&gt; [1] TRUE\nis.data.frame(df2)\n#&gt; [1] TRUE\n\nis_tibble(df1)\n#&gt; [1] FALSE\nis_tibble(df2)\n#&gt; [1] TRUE\n\n\n\nList columns\n前面我们说过，数据框本质是一个list，所以数据框中的列可以包含任意类型的元素，包括list。tibble本身支持list column，dataframe需要额外的I()函数辅助。\n\n# tibble\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\n# dataframe\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3,\n  y = I(list(1:2, 1:3, 1:4))\n)\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\n\nMatrix and data frame columns\n同上面的list一样，你可以在数据框中添加行数相等的矩阵和数据框。\n\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#null",
    "href": "Books/Advanced R(2e)/3 Vectors.html#null",
    "title": "3 Vectors",
    "section": "NULL",
    "text": "NULL\nNULL 的长度为0，类型为NULL，且无法拥有任何属性。\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n#&gt; [1] 0\n\nx &lt;- NULL\nattr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html",
    "href": "Books/Advanced R(2e)/13 S3.html",
    "title": "13 S3",
    "section": "",
    "text": "R 的第一个OOP是S3面向对象，它的唯一优点是极其简单——无法再扔掉它的任何一部分来实现OOP。S3面向对象是R base和stats包中唯一使用的OOP。\nS3面向对象不像其他语言中那么严格，赋予了R编程人员很大的自由，这是危险的；为了能更好的使用S3面向对象，本章会介绍使用S3面向对象时约定的惯例。\n本章的目的也仅是对S3面向对象如何工作进行介绍，不涉及如何有效地创建新的S3类。\n\n\n\n13.2节：总览S3类——类，泛型函数，方法\n13.3节：创建新的S3类时的细节，三个函数：constructor，helper，validator\n13.4节：介绍类与方法如何工作（方法派发），method dispatch\n13.5节：S3类的四种主要风格：vector，record，data frame，scalar\n13.6节：介绍S3的继承及如何添加类的关系\n13.7节：详细介绍类方法分派\n\n\n\n\nS3类与class属性密不可分，我们需要使用sloop包来查看S3类的内部结构。\n\nlibrary(sloop)",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#introduction",
    "href": "Books/Advanced R(2e)/13 S3.html#introduction",
    "title": "13 S3",
    "section": "",
    "text": "R 的第一个OOP是S3面向对象，它的唯一优点是极其简单——无法再扔掉它的任何一部分来实现OOP。S3面向对象是R base和stats包中唯一使用的OOP。\nS3面向对象不像其他语言中那么严格，赋予了R编程人员很大的自由，这是危险的；为了能更好的使用S3面向对象，本章会介绍使用S3面向对象时约定的惯例。\n本章的目的也仅是对S3面向对象如何工作进行介绍，不涉及如何有效地创建新的S3类。\n\n\n\n13.2节：总览S3类——类，泛型函数，方法\n13.3节：创建新的S3类时的细节，三个函数：constructor，helper，validator\n13.4节：介绍类与方法如何工作（方法派发），method dispatch\n13.5节：S3类的四种主要风格：vector，record，data frame，scalar\n13.6节：介绍S3的继承及如何添加类的关系\n13.7节：详细介绍类方法分派\n\n\n\n\nS3类与class属性密不可分，我们需要使用sloop包来查看S3类的内部结构。\n\nlibrary(sloop)",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#basics",
    "href": "Books/Advanced R(2e)/13 S3.html#basics",
    "title": "13 S3",
    "section": "Basics",
    "text": "Basics\n\n类，属性\nS3对象是一个至少有1个class属性的base type。例如factor，它的base type是integer，除此之外还有class属性和levels属性。\n\nf &lt;- factor(c(\"a\", \"b\", \"c\"))\n\ntypeof(f)\n#&gt; [1] \"integer\"\nattributes(f)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n使用unclass()可以去除S3对象的class属性，暴露出其底层的base type，同时失去对象的特有行为。\n\nunclass(f)\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\n\n\n方法\nS3类方法的实现是基于“泛型函数”的。识别泛型函数的一种简单方法是使用sloop::ftype()，如果结果中有”generic”字样，就是泛型函数。\n\nftype(print)\n#&gt; [1] \"S3\"      \"generic\"\nftype(str)\n#&gt; [1] \"S3\"      \"generic\"\nftype(unclass)\n#&gt; [1] \"primitive\"\n\n不同S3对象输入到同一个泛型函数时会产生不同的结果（多态）。底层逻辑是，根据对象class属性，选择对应的方法。许多R函数属于泛型函数，例如print()。\n\nprint(f)\n#&gt; [1] a b c\n#&gt; Levels: a b c\n\n# stripping class reverts to integer behaviour\nprint(unclass(f))\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\n我们知道面向对象系统有一个重要特征——“封装”。S3系统的泛型函数同样具有封装的特性，会隐藏对象中的细节。例如常用的泛型函数str()，虽然是用来查看对象的结构，但你所看到的是对象想让你看到的，没有展示对象内部详细的细节。POSIXlt类用来表示时间，使用str()只能看到年月日，但其底层是一个list。\n\ntime &lt;- strptime(c(\"2017-01-01\", \"2020-05-04 03:21\"), \"%Y-%m-%d\")\nstr(time)\n#&gt;  POSIXlt[1:2], format: \"2017-01-01\" \"2020-05-04\"\n\nstr(unclass(time))\n#&gt; List of 11\n#&gt;  $ sec   : num [1:2] 0 0\n#&gt;  $ min   : int [1:2] 0 0\n#&gt;  $ hour  : int [1:2] 0 0\n#&gt;  $ mday  : int [1:2] 1 4\n#&gt;  $ mon   : int [1:2] 0 4\n#&gt;  $ year  : int [1:2] 117 120\n#&gt;  $ wday  : int [1:2] 0 1\n#&gt;  $ yday  : int [1:2] 0 124\n#&gt;  $ isdst : int [1:2] 0 0\n#&gt;  $ zone  : chr [1:2] \"CST\" \"CST\"\n#&gt;  $ gmtoff: int [1:2] NA NA\n#&gt;  - attr(*, \"tzone\")= chr [1:3] \"\" \"CST\" \"CDT\"\n#&gt;  - attr(*, \"balanced\")= logi TRUE\n\n\n\n方法派发\n泛型函数会为不同类找到正确的实现，类的特定实现称为方法（method），泛型函数通过执行方法分派（method dispatch）来找到对应的方法。\n可以使用sloop::s3_dispatch()函数查看方法派发的过程。如下面所示，找到了当前print的多个方法print.factor和print.default，最终选择了print.factor。\n\ns3_dispatch(print(f))\n#&gt; =&gt; print.factor\n#&gt;  * print.default\n\n从结果中可以看到，方法的命名规则是generic.class()。通常你无需使用generic.class()形式的函数，只需使用generic()，它会根据输入对象的class属性自动识别。因为某些函数的定义早于S3系统，所以类型&lt;&gt;.&lt;&gt;的函数不都是泛函，可以使用sloop::ftype()进行识别。\n\nftype(t.test)\n#&gt; [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#&gt; [1] \"S3\"     \"method\"\n\nS3 系统的泛函通常无法看到源码，但是可以使用sloop::s3_get_method()查看。\n\nweighted.mean.Date\n#&gt; Error: object 'weighted.mean.Date' not found\n\ns3_get_method(weighted.mean.Date)\n#&gt; function (x, w, ...) \n#&gt; .Date(weighted.mean(unclass(x), w, ...))\n#&gt; &lt;bytecode: 0x000001e1d2610048&gt;\n#&gt; &lt;environment: namespace:stats&gt;",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#classes",
    "href": "Books/Advanced R(2e)/13 S3.html#classes",
    "title": "13 S3",
    "section": "Classes",
    "text": "Classes\nS3面向对象实例化一个对象只能使用structure()或calss&lt;-()函数——通过设置class属性的方法实现。\n\n# Create and assign class in one step\nx &lt;- structure(list(), class = \"my_class\")\n\n# Create, then set class\nx &lt;- list()\nclass(x) &lt;- \"my_class\"\n\n使用class()查看一个对象的类型，使用inherits(x, \"classname\")来判断一个对象是否属于某类。\n\nclass(x)\n#&gt; [1] \"my_class\"\ninherits(x, \"my_class\")\n#&gt; [1] TRUE\ninherits(x, \"your_class\")\n#&gt; [1] FALSE\n\nclassname 可以是任意字符串，但是推荐使用字母和_，杜绝使用.。在package中使用class时，推荐加上包名。\nS3面向对象没有类正确性检查，意味着可以随意更改一个对象的类：\n\n# Create a linear model\nmod &lt;- lm(log(mpg) ~ log(disp), data = mtcars)\nclass(mod)\n#&gt; [1] \"lm\"\nprint(mod)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = log(mpg) ~ log(disp), data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    log(disp)  \n#&gt;      5.3810      -0.4586\n\n# Turn it into a date (?!)\nclass(mod) &lt;- \"Date\"\n\n# Unsurprisingly this doesn't work very well\nprint(mod)\n#&gt; Error in as.POSIXlt(.Internal(Date2POSIXlt(x, tz)), tz = tz): 'list' object cannot be coerced to type 'double'\n\n为了避免上述问题发生，推荐创建三个函数：\n\n低级构造函数(Constructor)，new_myclass()：高效地创建结构正确的类。\n验证函数(validator)，validate_myclass()：验证类的合法性。\n辅助函数(helper)，myclass()：用户友好的创建类。\n\n\nConstructors\nS3 面向对象没有提供正式的类定义函数，无法保证类的结构统一，我们需要自行创建一个构造函数，保证类的构造正确。构造函数应当遵循下面三条原则：\n\n函数命名为new_myclass()样式。\n一个参数服务于构成类的base type；每个属性一个参数。\n检查base type和每个参数的类型是否符合要求。\n\n下面是一个具有units属性，class属性为difftime的类构造函数：\n\nnew_difftime &lt;- function(x = double(), units = \"secs\") {\n  stopifnot(is.double(x))\n  units &lt;- match.arg(units, c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))\n\n  structure(x,\n    class = \"difftime\",\n    units = units\n  )\n}\n\nnew_difftime(c(1, 10, 3600), \"secs\")\n#&gt; Time differences in secs\n#&gt; [1]    1   10 3600\n\nnew_difftime(52, \"weeks\")\n#&gt; Time difference of 52 weeks\n\n构造函数面向的是开发者，这意味着，有些时候，我们可以牺牲一些安全性来换取高效性，例如避免耗时项的检查。\n\n\nValidators\n越复杂的类越需要细致地检查。如下例factor类，虽然有对输入类型检查，但仍然创建了错误的类。\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nnew_factor(1:5, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\nnew_factor(0:1, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\n\n想比于构造函数中对base type和参数类型的检查，对类输入的其他检查应该分离为单独的函数。这样当你知道输入是正确时，可以以更低的成本创建类，并且检查方法可以用在其他地方。\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values &gt; 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nvalidate_factor(new_factor(1:5, \"a\"))\n#&gt; Error: There must be at least as many `levels` as possible values in `x`\nvalidate_factor(new_factor(0:1, \"a\"))\n#&gt; Error: All `x` values must be non-missing and greater than zero\n\n\n\nHelpers\n为了方便使用者创建类对象，我们需要提供一个辅助函数。其遵循以下原则：\n\n函数名和类名相同，myclass()。\n如果存在constructor和validator，函数要使用它们。\n为终端用户创建精心设计的错误消息。。\n有一个精心设计的用户界面，精心选择的默认值和有用的转换\n\n下面是三个常见的示例：\n\n输入参数类型强制转换\n例如上面的new_difftime()对输入十分严格，当输入是integer时报错。\n\nnew_difftime(1:10)\n#&gt; Error in new_difftime(1:10): is.double(x) is not TRUE\n\n可以在helper函数中添加类型强制转换：\n\ndifftime &lt;- function(x = double(), units = \"secs\") {\n  x &lt;- as.double(x)\n  new_difftime(x, units = units)\n}\n\ndifftime(1:10)\n#&gt; Time differences in secs\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n提供有用的默认值\n在生成factor时，提供默认的levels。\n\nfactor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"))\n#&gt; [1] a a b\n#&gt; Levels: a b\n\n\n\n使用简单成分组成用户界面\n下面是一个构建POSIXct类的函数，函数的输入都是简单的整数。\n\nPOSIXct &lt;- function(year = integer(),\n                    month = integer(),\n                    day = integer(),\n                    hour = 0L,\n                    minute = 0L,\n                    sec = 0,\n                    tzone = \"\") {\n  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)\n}\n\nPOSIXct(2020, 1, 1, tzone = \"America/New_York\")\n#&gt; [1] \"2020-01-01 EST\"",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#generics-and-methods",
    "href": "Books/Advanced R(2e)/13 S3.html#generics-and-methods",
    "title": "13 S3",
    "section": "Generics and methods",
    "text": "Generics and methods\n如上所述，S3系统的泛型函数会执行方法分派——找到类能使用的方法，该过程由UseMethod()函数实现。UseMethod()函数有两个参数：\n\ngeneric：字符串类型的泛型函数名称。\nobject：要分派的对象。\n\n通常只需要第一个参数，例如mean():\n\nmean\n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x000001e1d1097580&gt;\n#&gt; &lt;environment: namespace:base&gt;\n\n创建自己的泛型函数，在创建时，泛型函数的参数不需要传递到UseMethod()中。\nmy_new_generic &lt;- function(x) {\n  UseMethod(\"my_new_generic\")\n}\n泛型函数内不要添加额外的处理逻辑，这会导致不可预的意外，例如下面的泛型函数g()，你无法修改变量y的值。\n\ng &lt;- function(x) {\n  x &lt;- 10\n  y &lt;- 10\n  UseMethod(\"g\")\n}\ng.default &lt;- function(x) c(x = x, y = y)\n\nx &lt;- 1\ny &lt;- 1\ng(x)\n#&gt; x y \n#&gt; 1 1\n\n\nMethod dispath\nUseMethod()执行方法派发的原理：创建泛型函数拥有的方法向量（generic.class），寻找潜在可用的方法。使用sloop::s3_dispath()可以查看这一过程。\n\nx &lt;- Sys.Date()\ns3_dispatch(print(x))\n#&gt; =&gt; print.Date\n#&gt;  * print.default\n\n\n=&gt;表示该方法被调用\n*表示该方法被定义但未被调用\n\n“default” class是特殊的伪类，它不是真实存在的类；包含它是为了使定义一个标准回退成为可能，这个回退在特定类的方法不可用时可以找到。例如下面的test类，在执行t()时，会自动为其分配t.default()方法，而不是R 4.0.0版本前的将t.test()当作方法进行派发。\n\nx &lt;- structure(1:10, class = \"test\")\ns3_dispatch(t(x))\n#&gt;    t.test\n#&gt; =&gt; t.default\n\n# Output in R version 3.6.2\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n#&gt;\n#&gt;  One Sample t-test\n#&gt;\n#&gt; data:  x\n#&gt; t = 5.7446, df = 9, p-value = 0.0002782\n#&gt; alternative hypothesis: true mean is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  3.334149 7.665851\n#&gt; sample estimates:\n#&gt; mean of x\n#&gt;       5.5\n方法派发的本质相当简单，但随着本章的深入，你会发现它在包含继承、基类型、内部泛型和组泛型方面变得越来越复杂。下面的代码展示了几个更复杂的情况，我们将在后续13.7节和14章中详细介绍。\n\nx &lt;- matrix(1:10, nrow = 2)\ns3_dispatch(mean(x))\n#&gt;    mean.matrix\n#&gt;    mean.integer\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\ns3_dispatch(sum(Sys.time()))\n#&gt;    sum.POSIXct\n#&gt;    sum.POSIXt\n#&gt;    sum.default\n#&gt; =&gt; Summary.POSIXct\n#&gt;    Summary.POSIXt\n#&gt;    Summary.default\n#&gt; -&gt; sum (internal)\n\n\n\nFinding methods\nsloop::s3_methods_generic()函数可以查看一个generic函数的所有方法。sloop::s3_methods_class()函数可以查看一个class的所有方法。\n\ns3_methods_generic(\"mean\")\n#&gt; # A tibble: 7 × 4\n#&gt;   generic class    visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;    &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 mean    Date     TRUE    base               \n#&gt; 2 mean    default  TRUE    base               \n#&gt; 3 mean    difftime TRUE    base               \n#&gt; 4 mean    POSIXct  TRUE    base               \n#&gt; 5 mean    POSIXlt  TRUE    base               \n#&gt; 6 mean    quosure  FALSE   registered S3method\n#&gt; # ℹ 1 more row\n\ns3_methods_class(\"ordered\")\n#&gt; # A tibble: 4 × 4\n#&gt;   generic       class   visible source             \n#&gt;   &lt;chr&gt;         &lt;chr&gt;   &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 as.data.frame ordered TRUE    base               \n#&gt; 2 Ops           ordered TRUE    base               \n#&gt; 3 relevel       ordered FALSE   registered S3method\n#&gt; 4 Summary       ordered TRUE    base\n\n\n\nCreating methods\n创建自己类的方法格式为：\ngeneric_name.class_name &lt;- function(generic_params) {\n  # do something\n}\n在创建新方法时要注意：\n\n首先，只有当你拥有泛型函数或类时，才应该编写方法。虽然即使你不拥有某个类或泛型函数,R 也会允许你定义方法，但这是极其不礼貌的行为。相反，请与泛型函数或类的作者合作，在他们的代码中添加方法。\n一个方法必须具有与其泛型相同的参数。这是通过 R CMD 检查在包中强制执行的，但即使不创建包，这也是一个很好的实践。",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#函数总结",
    "href": "Books/Advanced R(2e)/13 S3.html#函数总结",
    "title": "13 S3",
    "section": "函数总结",
    "text": "函数总结\n\nx &lt;- table(rpois(100, 5))\nx\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 11 12 \n#&gt;  6  6 14 20 22 14  9  2  2  3  1  1\n\n\ntypeof(x) # 查看base type\n#&gt; [1] \"integer\"\nattributes(x) # 查看属性\n#&gt; $dim\n#&gt; [1] 12\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames[[1]]\n#&gt;  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\ns3_class(x) # 查看S3 class\n#&gt; [1] \"table\"\nclass() # 查看class\n#&gt; Error in class(): 0 arguments passed to 'class' which requires 1\ninherits(x, \"classname\") # 判断是否属于classname\n#&gt; [1] FALSE\nsloop::s3_methods_class(\"table\") # 查看类可以用的泛函\n#&gt; # A tibble: 10 × 4\n#&gt;   generic       class visible source             \n#&gt;   &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 [             table TRUE    base               \n#&gt; 2 aperm         table TRUE    base               \n#&gt; 3 as.data.frame table TRUE    base               \n#&gt; 4 Axis          table FALSE   registered S3method\n#&gt; 5 lines         table FALSE   registered S3method\n#&gt; 6 plot          table FALSE   registered S3method\n#&gt; # ℹ 4 more rows\nsloop::s3_methods_generic(\"print\") # 查看与泛函相关的类\n#&gt; # A tibble: 294 × 4\n#&gt;   generic class             visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;             &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 print   acf               FALSE   registered S3method\n#&gt; 2 print   activeConcordance FALSE   registered S3method\n#&gt; 3 print   AES               FALSE   registered S3method\n#&gt; 4 print   all_vars          FALSE   registered S3method\n#&gt; 5 print   anova             FALSE   registered S3method\n#&gt; 6 print   any_vars          FALSE   registered S3method\n#&gt; # ℹ 288 more rows\n\nUseMethod()\n#&gt; Error in UseMethod(): there must be a 'generic' argument\n.class2(x)\n#&gt; [1] \"table\"\nmethods(\"print\")\n#&gt;   [1] print.acf*                                          \n#&gt;   [2] print.activeConcordance*                            \n#&gt;   [3] print.AES*                                          \n#&gt;   [4] print.all_vars*                                     \n#&gt;   [5] print.anova*                                        \n#&gt;   [6] print.any_vars*                                     \n#&gt;   [7] print.aov*                                          \n#&gt;   [8] print.aovlist*                                      \n#&gt;   [9] print.ar*                                           \n#&gt;  [10] print.Arima*                                        \n#&gt;  [11] print.arima0*                                       \n#&gt;  [12] print.AsIs                                          \n#&gt;  [13] print.aspell*                                       \n#&gt;  [14] print.aspell_inspect_context*                       \n#&gt;  [15] print.bibentry*                                     \n#&gt;  [16] print.Bibtex*                                       \n#&gt;  [17] print.browseVignettes*                              \n#&gt;  [18] print.by                                            \n#&gt;  [19] print.changedFiles*                                 \n#&gt;  [20] print.check_bogus_return*                           \n#&gt;  [21] print.check_code_usage_in_package*                  \n#&gt;  [22] print.check_compiled_code*                          \n#&gt;  [23] print.check_demo_index*                             \n#&gt;  [24] print.check_depdef*                                 \n#&gt;  [25] print.check_details*                                \n#&gt;  [26] print.check_details_changes*                        \n#&gt;  [27] print.check_doi_db*                                 \n#&gt;  [28] print.check_dotInternal*                            \n#&gt;  [29] print.check_make_vars*                              \n#&gt;  [30] print.check_nonAPI_calls*                           \n#&gt;  [31] print.check_package_code_assign_to_globalenv*       \n#&gt;  [32] print.check_package_code_attach*                    \n#&gt;  [33] print.check_package_code_data_into_globalenv*       \n#&gt;  [34] print.check_package_code_startup_functions*         \n#&gt;  [35] print.check_package_code_syntax*                    \n#&gt;  [36] print.check_package_code_unload_functions*          \n#&gt;  [37] print.check_package_compact_datasets*               \n#&gt;  [38] print.check_package_CRAN_incoming*                  \n#&gt;  [39] print.check_package_datalist*                       \n#&gt;  [40] print.check_package_datasets*                       \n#&gt;  [41] print.check_package_depends*                        \n#&gt;  [42] print.check_package_description*                    \n#&gt;  [43] print.check_package_description_encoding*           \n#&gt;  [44] print.check_package_license*                        \n#&gt;  [45] print.check_packages_in_dir*                        \n#&gt;  [46] print.check_packages_used*                          \n#&gt;  [47] print.check_po_files*                               \n#&gt;  [48] print.check_pragmas*                                \n#&gt;  [49] print.check_Rd_line_widths*                         \n#&gt;  [50] print.check_Rd_metadata*                            \n#&gt;  [51] print.check_Rd_xrefs*                               \n#&gt;  [52] print.check_RegSym_calls*                           \n#&gt;  [53] print.check_S3_methods_needing_delayed_registration*\n#&gt;  [54] print.check_so_symbols*                             \n#&gt;  [55] print.check_T_and_F*                                \n#&gt;  [56] print.check_url_db*                                 \n#&gt;  [57] print.check_vignette_index*                         \n#&gt;  [58] print.checkDocFiles*                                \n#&gt;  [59] print.checkDocStyle*                                \n#&gt;  [60] print.checkFF*                                      \n#&gt;  [61] print.checkRd*                                      \n#&gt;  [62] print.checkRdContents*                              \n#&gt;  [63] print.checkReplaceFuns*                             \n#&gt;  [64] print.checkS3methods*                               \n#&gt;  [65] print.checkTnF*                                     \n#&gt;  [66] print.checkVignettes*                               \n#&gt;  [67] print.citation*                                     \n#&gt;  [68] print.cli_ansi_html_style*                          \n#&gt;  [69] print.cli_ansi_string*                              \n#&gt;  [70] print.cli_ansi_style*                               \n#&gt;  [71] print.cli_boxx*                                     \n#&gt;  [72] print.cli_diff_chr*                                 \n#&gt;  [73] print.cli_doc*                                      \n#&gt;  [74] print.cli_progress_demo*                            \n#&gt;  [75] print.cli_rule*                                     \n#&gt;  [76] print.cli_sitrep*                                   \n#&gt;  [77] print.cli_spark*                                    \n#&gt;  [78] print.cli_spinner*                                  \n#&gt;  [79] print.cli_tree*                                     \n#&gt;  [80] print.codoc*                                        \n#&gt;  [81] print.codocClasses*                                 \n#&gt;  [82] print.codocData*                                    \n#&gt;  [83] print.colorConverter*                               \n#&gt;  [84] print.compactPDF*                                   \n#&gt;  [85] print.condition                                     \n#&gt;  [86] print.connection                                    \n#&gt;  [87] print.CRAN_package_reverse_dependencies_and_views*  \n#&gt;  [88] print.data.frame                                    \n#&gt;  [89] print.Date                                          \n#&gt;  [90] print.default                                       \n#&gt;  [91] print.dendrogram*                                   \n#&gt;  [92] print.density*                                      \n#&gt;  [93] print.difftime                                      \n#&gt;  [94] print.dist*                                         \n#&gt;  [95] print.Dlist                                         \n#&gt;  [96] print.DLLInfo                                       \n#&gt;  [97] print.DLLInfoList                                   \n#&gt;  [98] print.DLLRegisteredRoutines                         \n#&gt;  [99] print.dplyr_join_by*                                \n#&gt; [100] print.dplyr_sel_vars*                               \n#&gt; [101] print.dummy_coef*                                   \n#&gt; [102] print.dummy_coef_list*                              \n#&gt; [103] print.ecdf*                                         \n#&gt; [104] print.eigen                                         \n#&gt; [105] print.element*                                      \n#&gt; [106] print.evaluate_evaluation*                          \n#&gt; [107] print.factanal*                                     \n#&gt; [108] print.factor                                        \n#&gt; [109] print.family*                                       \n#&gt; [110] print.fileSnapshot*                                 \n#&gt; [111] print.findLineNumResult*                            \n#&gt; [112] print.flatGridListing*                              \n#&gt; [113] print.formula*                                      \n#&gt; [114] print.fseq*                                         \n#&gt; [115] print.ftable*                                       \n#&gt; [116] print.fun_list*                                     \n#&gt; [117] print.function                                      \n#&gt; [118] print.getAnywhere*                                  \n#&gt; [119] print.ggplot*                                       \n#&gt; [120] print.ggplot2_bins*                                 \n#&gt; [121] print.ggproto*                                      \n#&gt; [122] print.ggproto_method*                               \n#&gt; [123] print.gList*                                        \n#&gt; [124] print.glm*                                          \n#&gt; [125] print.glue*                                         \n#&gt; [126] print.gpar*                                         \n#&gt; [127] print.GridCoords*                                   \n#&gt; [128] print.GridGrobCoords*                               \n#&gt; [129] print.GridGTreeCoords*                              \n#&gt; [130] print.grob*                                         \n#&gt; [131] print.gtable*                                       \n#&gt; [132] print.hashtab*                                      \n#&gt; [133] print.hcl_palettes*                                 \n#&gt; [134] print.hclust*                                       \n#&gt; [135] print.help_files_with_topic*                        \n#&gt; [136] print.hexmode                                       \n#&gt; [137] print.HoltWinters*                                  \n#&gt; [138] print.hsearch*                                      \n#&gt; [139] print.hsearch_db*                                   \n#&gt; [140] print.htest*                                        \n#&gt; [141] print.html*                                         \n#&gt; [142] print.html_dependency*                              \n#&gt; [143] print.htmltools.selector*                           \n#&gt; [144] print.htmltools.selector.list*                      \n#&gt; [145] print.infl*                                         \n#&gt; [146] print.integrate*                                    \n#&gt; [147] print.isoreg*                                       \n#&gt; [148] print.json*                                         \n#&gt; [149] print.key_missing*                                  \n#&gt; [150] print.kmeans*                                       \n#&gt; [151] print.knitr_kable*                                  \n#&gt; [152] print.last_dplyr_warnings*                          \n#&gt; [153] print.Latex*                                        \n#&gt; [154] print.LaTeX*                                        \n#&gt; [155] print.libraryIQR                                    \n#&gt; [156] print.lifecycle_warnings*                           \n#&gt; [157] print.listof                                        \n#&gt; [158] print.lm*                                           \n#&gt; [159] print.loadings*                                     \n#&gt; [160] print.loess*                                        \n#&gt; [161] print.logLik*                                       \n#&gt; [162] print.ls_str*                                       \n#&gt; [163] print.medpolish*                                    \n#&gt; [164] print.method_table*                                 \n#&gt; [165] print.MethodsFunction*                              \n#&gt; [166] print.mtable*                                       \n#&gt; [167] print.NativeRoutineList                             \n#&gt; [168] print.news_db*                                      \n#&gt; [169] print.nls*                                          \n#&gt; [170] print.noquote                                       \n#&gt; [171] print.numeric_version                               \n#&gt; [172] print.object_size*                                  \n#&gt; [173] print.octmode                                       \n#&gt; [174] print.packageDescription*                           \n#&gt; [175] print.packageInfo                                   \n#&gt; [176] print.packageIQR*                                   \n#&gt; [177] print.packageStatus*                                \n#&gt; [178] print.paged_df*                                     \n#&gt; [179] print.pairwise.htest*                               \n#&gt; [180] print.path*                                         \n#&gt; [181] print.person*                                       \n#&gt; [182] print.pillar*                                       \n#&gt; [183] print.pillar_1e*                                    \n#&gt; [184] print.pillar_colonnade*                             \n#&gt; [185] print.pillar_ornament*                              \n#&gt; [186] print.pillar_shaft*                                 \n#&gt; [187] print.pillar_squeezed_colonnade*                    \n#&gt; [188] print.pillar_tbl_format_setup*                      \n#&gt; [189] print.pillar_vctr*                                  \n#&gt; [190] print.pillar_vctr_attr*                             \n#&gt; [191] print.POSIXct                                       \n#&gt; [192] print.POSIXlt                                       \n#&gt; [193] print.power.htest*                                  \n#&gt; [194] print.ppr*                                          \n#&gt; [195] print.prcomp*                                       \n#&gt; [196] print.princomp*                                     \n#&gt; [197] print.proc_time                                     \n#&gt; [198] print.purrr_function_compose*                       \n#&gt; [199] print.purrr_function_partial*                       \n#&gt; [200] print.purrr_rate_backoff*                           \n#&gt; [201] print.purrr_rate_delay*                             \n#&gt; [202] print.quosure*                                      \n#&gt; [203] print.quosures*                                     \n#&gt; [204] print.R6*                                           \n#&gt; [205] print.R6ClassGenerator*                             \n#&gt; [206] print.raster*                                       \n#&gt; [207] print.Rconcordance*                                 \n#&gt; [208] print.Rd*                                           \n#&gt; [209] print.recordedplot*                                 \n#&gt; [210] print.rel*                                          \n#&gt; [211] print.restart                                       \n#&gt; [212] print.RGBcolorConverter*                            \n#&gt; [213] print.RGlyphFont*                                   \n#&gt; [214] print.rlang_box_done*                               \n#&gt; [215] print.rlang_box_splice*                             \n#&gt; [216] print.rlang_data_pronoun*                           \n#&gt; [217] print.rlang_dict*                                   \n#&gt; [218] print.rlang_dyn_array*                              \n#&gt; [219] print.rlang_envs*                                   \n#&gt; [220] print.rlang_error*                                  \n#&gt; [221] print.rlang_fake_data_pronoun*                      \n#&gt; [222] print.rlang_lambda_function*                        \n#&gt; [223] print.rlang_message*                                \n#&gt; [224] print.rlang_trace*                                  \n#&gt; [225] print.rlang_warning*                                \n#&gt; [226] print.rlang_zap*                                    \n#&gt; [227] print.rlang:::list_of_conditions*                   \n#&gt; [228] print.rle                                           \n#&gt; [229] print.rlib_bytes*                                   \n#&gt; [230] print.rlib_error_3_0*                               \n#&gt; [231] print.rlib_trace_3_0*                               \n#&gt; [232] print.roman*                                        \n#&gt; [233] print.scalar*                                       \n#&gt; [234] print.sessionInfo*                                  \n#&gt; [235] print.shiny.tag*                                    \n#&gt; [236] print.shiny.tag.env*                                \n#&gt; [237] print.shiny.tag.list*                               \n#&gt; [238] print.shiny.tag.query*                              \n#&gt; [239] print.simple.list                                   \n#&gt; [240] print.smooth.spline*                                \n#&gt; [241] print.socket*                                       \n#&gt; [242] print.src*                                          \n#&gt; [243] print.srcfile                                       \n#&gt; [244] print.srcref                                        \n#&gt; [245] print.stepfun*                                      \n#&gt; [246] print.stl*                                          \n#&gt; [247] print.StructTS*                                     \n#&gt; [248] print.subdir_tests*                                 \n#&gt; [249] print.summarize_CRAN_check_status*                  \n#&gt; [250] print.summary.aov*                                  \n#&gt; [251] print.summary.aovlist*                              \n#&gt; [252] print.summary.ecdf*                                 \n#&gt; [253] print.summary.glm*                                  \n#&gt; [254] print.summary.lm*                                   \n#&gt; [255] print.summary.loess*                                \n#&gt; [256] print.summary.manova*                               \n#&gt; [257] print.summary.nls*                                  \n#&gt; [258] print.summary.packageStatus*                        \n#&gt; [259] print.summary.ppr*                                  \n#&gt; [260] print.summary.prcomp*                               \n#&gt; [261] print.summary.princomp*                             \n#&gt; [262] print.summary.table                                 \n#&gt; [263] print.summary.warnings                              \n#&gt; [264] print.summaryDefault                                \n#&gt; [265] print.table                                         \n#&gt; [266] print.tables_aov*                                   \n#&gt; [267] print.tbl*                                          \n#&gt; [268] print.terms*                                        \n#&gt; [269] print.theme*                                        \n#&gt; [270] print.transform*                                    \n#&gt; [271] print.trunc_mat*                                    \n#&gt; [272] print.ts*                                           \n#&gt; [273] print.tskernel*                                     \n#&gt; [274] print.TukeyHSD*                                     \n#&gt; [275] print.tukeyline*                                    \n#&gt; [276] print.tukeysmooth*                                  \n#&gt; [277] print.undoc*                                        \n#&gt; [278] print.uneval*                                       \n#&gt; [279] print.unit*                                         \n#&gt; [280] print.vctrs_bytes*                                  \n#&gt; [281] print.vctrs_sclr*                                   \n#&gt; [282] print.vctrs_unspecified*                            \n#&gt; [283] print.vctrs_vctr*                                   \n#&gt; [284] print.viewport*                                     \n#&gt; [285] print.vignette*                                     \n#&gt; [286] print.warnings                                      \n#&gt; [287] print.xfun_md_viewable*                             \n#&gt; [288] print.xfun_raw_string*                              \n#&gt; [289] print.xfun_record_results*                          \n#&gt; [290] print.xfun_rename_seq*                              \n#&gt; [291] print.xfun_strict_list*                             \n#&gt; [292] print.xgettext*                                     \n#&gt; [293] print.xngettext*                                    \n#&gt; [294] print.xtabs*                                        \n#&gt; see '?methods' for accessing help and source code"
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html",
    "href": "Books/Advanced R(2e)/1 Introduction.html",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#why-r",
    "href": "Books/Advanced R(2e)/1 Introduction.html#why-r",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#who-should-read-this-book",
    "href": "Books/Advanced R(2e)/1 Introduction.html#who-should-read-this-book",
    "title": "1 Introduction",
    "section": "Who should read this book",
    "text": "Who should read this book\n本书适合两类人：\n\n中级 R 程序员，他们希望更深入地研究 R 语言，理解语言的工作原理，并学习解决各种问题的新策略。\n来自其他语言的程序员，他们正在学习 R，并且想要理解为什么 R 是这样工作的。\n\n为了阅读这本书之前，你需要用 R 或其他编程语言编写大量的代码，熟悉数据分析的基础知识 (即数据导入、操作和可视化) ，熟悉 CRAN 包的安装和使用。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-get-out-of-this-book",
    "href": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-get-out-of-this-book",
    "title": "1 Introduction",
    "section": "What you will get out of this book",
    "text": "What you will get out of this book\n阅读本书，你可以：\n\n熟悉 R 的基础知识。你将了解复杂数据类型以及对它们执行操作的最佳方法，对函数如何工作有深入的了解，知道什么是环境，以及如何使用条件系统。\n理解函数式编程的含义，以及为什么它是数据科学的有用工具。你将能够快速学习如何使用现有的工具，并且具备在需要时创建自己的功能性工具的知识。\n了解 R 的各种面向对象系统。你将最熟悉 S3，并且知道 S4 和 R6，以及在需要时在哪里查找更多信息。\n欣赏元编程的双刃剑。你将能够创建使用整洁计算、保存类型和创建优雅代码来表示重要操作的函数，也会明白什么是危险，什么时候应该避免。\n有一个良好的直觉，在 R 中的操作是缓慢的或使用大量的内存。你将知道如何使用分析来查明性能瓶颈，并且知道足够多的 C++ 来将慢速 R 函数转换为快速 C++ 等价物。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-not-learn",
    "href": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-not-learn",
    "title": "1 Introduction",
    "section": "What you will not learn",
    "text": "What you will not learn\n本书不涉及：\n\n如何进行数据分析，数据分析推荐R for Data Science。\n如何生成R包，构建R包推荐R packages。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#meta-techniques",
    "href": "Books/Advanced R(2e)/1 Introduction.html#meta-techniques",
    "title": "1 Introduction",
    "section": "Meta-techniques",
    "text": "Meta-techniques\n提升编程能力的两个途径：\n\n阅读源代码。\n采用科学思维",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#recommended-reading",
    "href": "Books/Advanced R(2e)/1 Introduction.html#recommended-reading",
    "title": "1 Introduction",
    "section": "Recommended reading",
    "text": "Recommended reading\n\nThe Structure and Interpretation of Computer Programs：提升R面向对象的理解。\nConcepts, Techniques and Models of Computer Programming：理解R与其他语言的差异。\nThe Pragmatic Programmer",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#getting-help",
    "href": "Books/Advanced R(2e)/1 Introduction.html#getting-help",
    "title": "1 Introduction",
    "section": "Getting help",
    "text": "Getting help\n在遇到困难寻求帮助时，下面是一些问答网站：\n\nRstudio Community\nStackOverflow\nR-help mailing list\n\n在寻求帮助前，你要：\n\n确定你的R版本和R包版本，及环境。\n给出一个复现问题的最小示例（reprex）。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#acknowledgments",
    "href": "Books/Advanced R(2e)/1 Introduction.html#acknowledgments",
    "title": "1 Introduction",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n…",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#conventions",
    "href": "Books/Advanced R(2e)/1 Introduction.html#conventions",
    "title": "1 Introduction",
    "section": "Conventions",
    "text": "Conventions\n对本书中的一些符号进行说明：\n\nf() 表示函数\ng 表示变量和函数参数\nh/ 表示路径\n#&gt; 表示终端运行结果\nset.seed(1014) 每章固定随机数种子",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#colophon",
    "href": "Books/Advanced R(2e)/1 Introduction.html#colophon",
    "title": "1 Introduction",
    "section": "Colophon",
    "text": "Colophon\n书中的R 和 R包版本会实时更新，请阅读原文了解详细信息。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Blog/Code chunks.html",
    "href": "Blog/Code chunks.html",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#label",
    "href": "Blog/Code chunks.html#label",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#execute",
    "href": "Blog/Code chunks.html#execute",
    "title": "quarto 中R代码块的设置",
    "section": "execute",
    "text": "execute\n可以使用execute选项来控制代码块；下面是对可用参数的总结。"
  },
  {
    "objectID": "Blog/Code chunks.html#knitr",
    "href": "Blog/Code chunks.html#knitr",
    "title": "quarto 中R代码块的设置",
    "section": "knitr",
    "text": "knitr\n因为quarto除对R代码块支持外，还支持python、Julia，所以除通用设置execute，quarto 还有R语言特有的设置——knitr。\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\n上面的设置可以自动将R代码的运行结果于代码拼接起来，并使用#&gt;作为注释，达到下面的效果。\n\n1 + 1\n#&gt; 2"
  },
  {
    "objectID": "Blog/Code chunks.html#行代码",
    "href": "Blog/Code chunks.html#行代码",
    "title": "quarto 中R代码块的设置",
    "section": "行代码",
    "text": "行代码\n处理上面使用```{r}的代码块，quarto还使用`r的行代码。"
  },
  {
    "objectID": "Blog/Object in R1.html#成为面对对象的五个条件",
    "href": "Blog/Object in R1.html#成为面对对象的五个条件",
    "title": "R 中的面向对象(1)",
    "section": "成为面对对象的五个条件",
    "text": "成为面对对象的五个条件\n\n类\n对象\n继承\n封装\n多态\n\n定义一个类，这个类有一些属性和方法，方法被封装为接口和实现；类可以实例化一个对象；类之间具有父子关系，子类可以继承父类的属性和方法；不同类的方法名是重复的，可以根据类选择对应的实现，这称之为多态。"
  },
  {
    "objectID": "Blog/Object in R1.html#为什么使用面向对象",
    "href": "Blog/Object in R1.html#为什么使用面向对象",
    "title": "R 中的面向对象(1)",
    "section": "为什么使用面向对象：",
    "text": "为什么使用面向对象：\n\n封装提供了标准的使用接口，能够降低系统的耦合度。\n继承允许子类继承父类的特性，提高了代码的重用性。\n多态允许相同函数对于不同的类有不同的行为，提高了代码的灵活性。\n\n想象一下，当你想更新一个函数的使用方法，但是又得保持和以前的兼容性，你只需要再创建一个子类，然后重新实现父类的方法，就可以了。"
  },
  {
    "objectID": "Blog/Object in R1.html#r-中的面向对象",
    "href": "Blog/Object in R1.html#r-中的面向对象",
    "title": "R 中的面向对象(1)",
    "section": "R 中的面向对象",
    "text": "R 中的面向对象\nR 语言中存在多种面向对象的编程，包括封装类的如RC，R6；泛函类的如S3，S4等。\n\n基于S3的面向对象编程基于泛型函数（generic function），不基于类层级结构,没有类的继承，没有严格的层级结构式继承。\n基于S4的面向对象编程，相对S3健全，实现了类的继承，具有严格的层级结构式类继承，但是是在函数封装过程中同S3一样，基于泛型函数。\n基于RC（也称S5）的面向对象编程则更加完善，符合上面的要求。\n基于R6包的面向对象编程，同样符合上面的要求。\n基于proto包的面向对象编程在ggplot2包中使用。\n基于R.oo包的面向对象编程类似S3。"
  },
  {
    "objectID": "Blog/Object in R1.html#sloop-包",
    "href": "Blog/Object in R1.html#sloop-包",
    "title": "R 中的面向对象(1)",
    "section": "sloop 包",
    "text": "sloop 包\n包中的函数sloop::otype()可以用来检查对象的面向对象编程类型。\n\nlibrary(sloop)\n\notype(1:10)\n#&gt; [1] \"base\"\n\notype(mtcars)\n#&gt; [1] \"S3\"\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\notype(mle_obj)\n#&gt; [1] \"S4\""
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html",
    "href": "Books/Advanced R(2e)/12 Base types.html",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此“对象”与面向对象（OOP）中的“对象”不同，前者指得是来自于S语言的base object，它比面向对象出现得更早。它们的关系可以表示为：\n\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#introduction",
    "href": "Books/Advanced R(2e)/12 Base types.html#introduction",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此“对象”与面向对象（OOP）中的“对象”不同，前者指得是来自于S语言的base object，它比面向对象出现得更早。它们的关系可以表示为：\n\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#base-vs-oo-objects",
    "href": "Books/Advanced R(2e)/12 Base types.html#base-vs-oo-objects",
    "title": "12 Base types",
    "section": "Base VS OO objects",
    "text": "Base VS OO objects\n区分二者的三种方法：\n\nis.object()：base object返回FALSE，OO object返回TRUE。\nsloop::otype()：base object返回base，OO object返回其他，如S3。\nattr()：base object返回NULL，OO object返回class属性。\n\n\nis.object(1:10)\n#&gt; [1] FALSE\nis.object(mtcars)\n#&gt; [1] TRUE\n\nsloop::otype(1:10)\n#&gt; [1] \"base\"\nsloop::otype(mtcars)\n#&gt; [1] \"S3\"\n\nattr(1:10, \"class\")\n#&gt; NULL\nattr(mtcars, \"class\")\n#&gt; [1] \"data.frame\"\n\n从技术上讲，base object 与 OO object 的本质区别就是OO object具有class属性。但是仅限于attr()函数，class()`函数会返回结果。\n\nx &lt;- 1:10\nclass(x)\n#&gt; [1] \"integer\"\nsloop::s3_class(x)\n#&gt; [1] \"integer\" \"numeric\"",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#base-types",
    "href": "Books/Advanced R(2e)/12 Base types.html#base-types",
    "title": "12 Base types",
    "section": "Base types",
    "text": "Base types\n无论是OO object还是base object，都有一个base type，使用typeof()来查看；不要使用mode()或storage.mode()，它们只适配S语言。\n\ntypeof(1:10)\n#&gt; [1] \"integer\"\n\ntypeof(mtcars)\n#&gt; [1] \"list\"\n\ntypeof(mean)\n#&gt; [1] \"closure\"\n\nR 的底层使用了C语言中的switch语句来对不同base type执行不同处理。想要新增一个base type需要修改R-core，所以通常不会随意增加base type。截至目前一共有25种base type，下面按照本书中出现的顺序列举。\n\nVector\n\n\n\nbase Type\nC Type\n\n\n\n\nNULL\nNILSXP\n\n\nlogical\nLGLSXP\n\n\ninteger\nINTSXP\n\n\ndouble\nREALSXP\n\n\ncomplex\nCPLXSXP\n\n\ncharacter\nSTRSXP\n\n\nlist\nVECSXP\n\n\nraw\nRAWSXP\n\n\n\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\ntypeof(1L)\n#&gt; [1] \"integer\"\ntypeof(1i)\n#&gt; [1] \"complex\"\n\n\n\nFunctions\n\n\n\nbase Type\nC Type\nfunction type\n\n\n\n\nclosure\nCLOSXP\nregular R functions\n\n\nspecial\nSPECIALSXP\ninternal functions\n\n\nbuiltin\nBUILTINSXP\nprimitive functions\n\n\n\n\ntypeof(mean)\n#&gt; [1] \"closure\"\ntypeof(`[`)\n#&gt; [1] \"special\"\ntypeof(sum)\n#&gt; [1] \"builtin\"\n\n\n\nEnvironments\n\n\n\nbase Type\nC Type\n\n\n\n\nenvironment\nENVSXP\n\n\n\n\ntypeof(globalenv())\n#&gt; [1] \"environment\"\n\n\n\nS4\n\n\n\nbase Type\nC Type\n\n\n\n\nS4\nS4SXP\n\n\n\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\ntypeof(mle_obj)\n#&gt; [1] \"S4\"\n\n\n\nLanguage components\n\n\n\nbase Type\nC Type\n\n\n\n\nsymbol\nSYMSXP\n\n\nlanguage\nLANGSXP\n\n\npairlist\nLISTSXP\n\n\nexpression\nEXPRSXP\n\n\n\n\ntypeof(quote(a))\n#&gt; [1] \"symbol\"\ntypeof(quote(a + 1))\n#&gt; [1] \"language\"\ntypeof(formals(mean))\n#&gt; [1] \"pairlist\"\ntypeof(expression(1 + 0:9))\n#&gt; [1] \"expression\"\n\n\n\nOthers\n\n\n\nbase Type\nC Type\n\n\n\n\nexternalptr\nEXTPTRSXP\n\n\nweakref\nWEAKREFSXP\n\n\nbytecode\nBCODESXP\n\n\npromise\nPROMSXP\n\n\n...\nDOTSXP\n\n\nany\nANYSXP\n\n\n\n\n\nNumeric type\n“numeric”在R中存在三种解读：\n\n某些地方，numeric是double的别名。例如as.numeric()和as.double()等价，numeric()和double()等价。\n在S3和S4系统中，“numeric”用作”integer type”或”double type”的缩写：\n\n\nsloop::s3_class(1)\n#&gt; [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#&gt; [1] \"integer\" \"numeric\"\n\n\nis.numeric()用来检测那些行为类似number的对象。例如，因子(factor)的本质是”integer type”，但是没有number的行为（求取一个因子的均值毫无意义）。\n\n\ntypeof(factor(\"x\"))\n#&gt; [1] \"integer\"\nis.numeric(factor(\"x\"))\n#&gt; [1] FALSE\n\n本书中的numeric表示integer或double。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html",
    "href": "Books/Advanced R(2e)/2 Names and values.html",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#introduction",
    "href": "Books/Advanced R(2e)/2 Names and values.html#introduction",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#binding-basics",
    "href": "Books/Advanced R(2e)/2 Names and values.html#binding-basics",
    "title": "2 Names and values",
    "section": "Binding basics",
    "text": "Binding basics\n考虑下面的代码：\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\n我们创建了一个名为x，值为1,2,3的对象，然后复制了一份讲其命名为y。那么，R在内存中是否也复制了一份，也即消耗了2倍的内存呢？事实上，此时消耗的内存并不是两倍，实际情况如下图所示。\n\n解释一下：\n\nc(1,2,3)创建了对象，并占用内存，地址为0x74b。\n&lt;- 为对象绑定一个名字，即x。\ny &lt;- x虽然将x复制了一份，但是x和y的值相同，都是对象c(1,2,3)，所以内存地址是不变。\n\n也即是说：内存和&lt;-后面的对象有关系，后面的不变，内存地址不变，内存消耗几乎不变；&lt;-前面的只是对象绑定的名字，因为实际的内存地址会随着终端变动而发生变动，需要绑定一个标签，你在代码的其他地方可以调用。\n查看对象的地址可以使用lobstr::obj_addr()，当你运行时，结果肯定与我的结果不同，因为终端发生了变动。\n\nobj_addr(x)\n#&gt; [1] \"0x55d0df84afd8\"\nobj_addr(y)\n#&gt; [1] \"0x55d0df84afd8\"\n\n请注意：上述说的“x和y的值相同”，与“创建值相同的两个对象”不同。\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 2, 3)\nobj_addr(a)\n#&gt; [1] \"0x55d0e04a6578\"\nobj_addr(b)\n#&gt; [1] \"0x55d0e04a5c18\"\n\n\nNon-syntactic names\nR 中对变量名的要求：必须由字母、数字、.、_构成，但_、数字、.+数字不能位于开头；不能使用关键字，查看关键字?Reserved；使用` 可以将任意字符包裹起来当作变量名；不建议使用'或\"将变量名包裹。\n\n_abc &lt;- 1\n\nif &lt;- 10\n\n`_abc` &lt;- 1\n`_abc`\n\n`if` &lt;- 10\n`if`\n#&gt; Error in parse(text = input): &lt;text&gt;:1:2: unexpected symbol\n#&gt; 1: _abc\n#&gt;      ^\n\n\n\nExercises\n\n下面所指的mean函数内存地址都相同。\n\n\nobj_addr(mean)\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(base::mean)\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(get(\"mean\"))\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(evalq(mean))\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(match.fun(\"mean\"))\n#&gt; [1] \"0x55d0d8d06cf0\"\n\n\nutils::read.csv()添加参数check.names = FALSE可以抑制列名的强制转换。\nmake.names()在将非法名转换为合法名时，会遵循下面的规则：\n\n必要时添加前缀X。\n非法字符转换为.。\n缺失值转换为NA。\nR中的关键字后添加.。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#copy-on-modify",
    "href": "Books/Advanced R(2e)/2 Names and values.html#copy-on-modify",
    "title": "2 Names and values",
    "section": "Copy-on-modify",
    "text": "Copy-on-modify\n诚如上述，当对象相同时，没有发生内存的消耗；但是如果对y进行了值得修改，那么内存会发生变动，如下所示。\n\ny[[3]] &lt;- 4\nx\n#&gt; [1] 1 2 3\ny\n#&gt; [1] 1 2 4\nobj_addr(x)\n#&gt; [1] \"0x55d0df84afd8\"\nobj_addr(y)\n#&gt; [1] \"0x55d0e0e6d1c8\"\n\nx绑定得原对象值未改变，R 创建新的对象，重新与y进行绑定。\n\n如果你修改多次对象，R 会创建多个新的对象，然后重新绑定，但是旧的对象不会消失，仍然存在于内存中，如下所示。\n\ny[[3]] &lt;- 5\nobj_addr(y)\n#&gt; [1] \"0x55d0e0c68198\"\n\n\n\n\n\n\n\nNote\n\n\n\n请注意：在Rstudio中进行上述内存地址检查时，会有所不同。\n\n\n\ntracemem()\ntracemem()可以跟踪对象，在对象发生变动时显示变动情况，如下所示。\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x55d0df84afd8&gt;\n\ny &lt;- x\ny[[3]] &lt;- 4L\n#&gt; tracemem[0x55d0df84afd8 -&gt; 0x55d0df8f8288]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\ny[[3]] &lt;- 5L\n\n使用untracemem()可以停止跟踪，如下所示。\n\nuntracemem(y)\ny[[3]] &lt;- 6L\n\n\n\nFunction calls\n函数生成对象时遵循相同的规则，如下所示。\n\nf &lt;- function(a) {\n  a\n}\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x55d0df84afd8&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\n\n解释一下：\n\n黄色部分表示函数，有参数a。\n灰色部分表示执行环境，返回函数运行后的结果a。\n因为返回结果和x一致，没有改变对象，所以仍然绑定相同的对象。\n当函数返回结果与x不一致时，会创建新的对象，重新绑定。\n\n\n\nLists\n与上面的向量不同，list格式的对象不仅本身有内存地址指定，它的元素也有内存地址指定。\n下面是一个简单的list对象，虽然看似简单，但是在内存分配上却不简单。\n\nl1 &lt;- list(1, 2, 3)\n\n\n当复制list对象时，同样内存不会发生改变：\n\nl2 &lt;- l1\n\n\n当复制的对象l2发生元素变动时，虽然R会创建一个新的内存地址，但同上面的情况略有不同：对list的复制是浅复制，不会复制所有的元素。与浅复制相对的是深复制，在R 3.1.0之前，都是深复制。\n\nl2[[3]] &lt;- 4\n\n\n使用lobstr::ref()可以查看list中每个元素的内存地址。注意对一个list单独使用，和对两个list同时使用的结果中前面的数字有不同（自己尝试一下）。\n\nref(l1, l2)\n#&gt; █ [1:0x55d0e0ae7878] &lt;list&gt; \n#&gt; ├─[2:0x55d0e0f33df8] &lt;dbl&gt; \n#&gt; ├─[3:0x55d0e0f33c38] &lt;dbl&gt; \n#&gt; └─[4:0x55d0e0f33a78] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [5:0x55d0decabc68] &lt;list&gt; \n#&gt; ├─[2:0x55d0e0f33df8] \n#&gt; ├─[3:0x55d0e0f33c38] \n#&gt; └─[6:0x55d0de935b58] &lt;dbl&gt;\n\n关于list中的内存指向，你可以试着嵌套一些复杂的list，然后观察内存分配情况。\n\n\nData frames\ndata.frame 其本质就是list，所以它的行为同list一样。\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nref(d1, d2, d3)\n#&gt; █ [1:0x55d0dfd0a848] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x55d0dfc799f8] &lt;dbl&gt; \n#&gt; └─y = [3:0x55d0dfc799a8] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [4:0x55d0dfd42ee8] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x55d0dfc799f8] \n#&gt; └─y = [5:0x55d0dfcc9848] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [6:0x55d0dfd70f68] &lt;df[,2]&gt; \n#&gt; ├─x = [7:0x55d0dfd41b98] &lt;dbl&gt; \n#&gt; └─y = [8:0x55d0dfd41b48] &lt;dbl&gt;\n\n\n\nCharacter vectors\n对于字符串类型的向量，R 使用全局字符串池来储存字符串。\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\ny &lt;- c(\"a\", \"d\")\nz &lt;- list(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n#&gt; █ [1:0x55d0e0566f78] &lt;chr&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] \n#&gt; ├─[3:0x55d0d92ae280] &lt;string: \"abc\"&gt; \n#&gt; └─[4:0x55d0d91f9d30] &lt;string: \"d\"&gt;\nref(y, character = TRUE)\n#&gt; █ [1:0x55d0e0776c78] &lt;chr&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; └─[3:0x55d0d91f9d30] &lt;string: \"d\"&gt;\nref(z, character = TRUE)\n#&gt; █ [1:0x55d0e0565a88] &lt;list&gt; \n#&gt; ├─█ [2:0x55d0df3484b8] &lt;chr&gt; \n#&gt; │ └─[3:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; ├─█ [4:0x55d0df3482f8] &lt;chr&gt; \n#&gt; │ └─[3:0x55d0d8d8bd90] \n#&gt; ├─█ [5:0x55d0df348138] &lt;chr&gt; \n#&gt; │ └─[6:0x55d0d92ae280] &lt;string: \"abc\"&gt; \n#&gt; └─█ [7:0x55d0df347f78] &lt;chr&gt; \n#&gt;   └─[8:0x55d0d91f9d30] &lt;string: \"d\"&gt;\n\n\n\n\nExercises\n\n1:10在内存中创建了对象，但是没有绑定，R无法对没有name的对象进行操作。\nx最先是integer类型，x[[3]] &lt;- 4 使用了double类型的数据替换，会导致R先复制一份double类型的向量，然后再替换数据。数据类型见下一章。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#object-size",
    "href": "Books/Advanced R(2e)/2 Names and values.html#object-size",
    "title": "2 Names and values",
    "section": "Object size",
    "text": "Object size\n使用lobstr::obj_size()可以查看对象的大小。\n\nobj_size(letters)\n#&gt; 1.71 kB\nobj_size(ggplot2::diamonds)\n#&gt; 3.46 MB\n\nlist对象，因为有上述的浅复制机制，实际大小会与想象的不同。\n\nx &lt;- runif(1e6)\nobj_size(x)\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n#&gt; 8.00 MB\n\n上述对象中，y比x要略大一些，大约80b，因为包含了三份空元素的list大小是80b。\n\nobj_size(list(NULL, NULL, NULL))\n#&gt; 80 B\n\n字符串向量也有相同的现象。\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n#&gt; 136 B\nobj_size(rep(banana, 100))\n#&gt; 928 B\n\n\nExercises\n…",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#modify-in-place",
    "href": "Books/Advanced R(2e)/2 Names and values.html#modify-in-place",
    "title": "2 Names and values",
    "section": "Modify-in-place",
    "text": "Modify-in-place\n诚如上述，当复制的对象发生值的改动，R会复制一份新，然后再修改值。但存在两个特例：\n\n当对象只绑定了一个name时，会直接修改对象的值。\n环境变量是一个特殊的对象，它总是直接修改对象的值。\n\n\nObjects with a single binding\n上面提到的“当对象只绑定了一个name时，会直接修改对象的值”，我在实际使用中，发现内存地址会发生变化。我简单的在不同系统中进行了实验，推测可能是系统原因。\n\nv &lt;- c(1, 2, 3)\nlobstr::obj_addr(v)\n#&gt; [1] \"0x55d0de95c0e8\"\nv[[3]] &lt;- 4\nlobstr::obj_addr(v)\n#&gt; [1] \"0x55d0de9607e8\"\n\n在R中存在下面两种情况，使得无法准确预测是否会发生复制:\n\nR 对于对象所绑定的name统计只能统计为：0，1，many；一旦对象绑定了多个name，那么就会始终被认为是many，无法回退。\n绝大多数函数都会复制对象，除非是用C语言实现的函数。\n\n例如下面的示例（按道理，上面的示例应该是不会发生变化的）：\n\n# 复制一份对象，a,b的地址是一样的\na &lt;- c(1,2,3)\nb &lt;- a\nlobstr::obj_addr(a)\n#&gt; [1] \"0x55d0df898108\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x55d0df898108\"\n# 当把名字a绑定另外一个对象后，在修改b的值，b的内存地址会发生变化\na &lt;- c(2,3,4)\nb[[3]] &lt;- 4\nlobstr::obj_addr(a)\n#&gt; [1] \"0x55d0df983d48\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x55d0df9f9588\"\n\n上面所描述的对象复制过程，也是R base中for loop缓慢的原因，即for loop本身并不慢，而是因为每次循环都会发生复制修改对象的操作，导致运行缓慢。下面示例中每次循环都会发生两次复制，而转换为list结构时，总共只发生一次复制。\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\n\n# 每次循环都复制两次\ncat(tracemem(x), \"\\n\")\n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x564653d5bca8 -&gt; 0x564656d3b6e8]:\n#&gt; tracemem[0x564656d3b6e8 -&gt; 0x564656d3b838]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3b838 -&gt; 0x564656d3b9f8]:\n#&gt; tracemem[0x564656d3b9f8 -&gt; 0x564656d3bbb8]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bbb8 -&gt; 0x564656d3be58]:\n#&gt; tracemem[0x564656d3be58 -&gt; 0x564656d3bf38]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bf38 -&gt; 0x564656d3c248]:\n#&gt; tracemem[0x564656d3c248 -&gt; 0x564656d3c558]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3c558 -&gt; 0x564656d3cc58]:\n#&gt; tracemem[0x564656d3cc58 -&gt; 0x564656d37838]: [[&lt;-.data.frame [[&lt;-\nuntracemem(x)\n\n\n\n# 总共复制一次\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n#&gt; &lt;0x55d0db6c7c68&gt;\n\nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x55d0db6c7c68 -&gt; 0x55d0df9b5568]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\n\n\nEnvironments\n环境变量储存着对象和name之间的绑定关系，它总是直接修改对象的值，不会进行复制。因为环境本质是一个查找表，存储变量名及其值，如果它们像向量或列表那样每次修改时都进行复制的话，会导致显著的性能开销。\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x55d0d98d3df8\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x55d0d98d3df8\"\n\n\n\ne1$c &lt;- 4\ne2$c\n#&gt; [1] 4\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x55d0d98d3df8\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x55d0d98d3df8\"",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#unbinding-and-the-garbage-collector",
    "href": "Books/Advanced R(2e)/2 Names and values.html#unbinding-and-the-garbage-collector",
    "title": "2 Names and values",
    "section": "Unbinding and the garbage collector",
    "text": "Unbinding and the garbage collector\n关于garbage collector（gc），可以总结为以下几点：\n\nrm()只是解除name绑定，不会清除对象。\nR 环境中没有name绑定的对象，使用gc()会被清除掉。\nR 会在内存不足时自动运行gc()，使用gcinfo(TRUE)后，R每次gc()都会输出信息。\n你无需手动运行gc()，这是没有必要的操作。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Foundations Introduction.html",
    "href": "Books/Advanced R(2e)/Foundations Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "第二章：object和它的name之间的区别。认识到它们的区别，你会在复制对象时更加的小心，因为这涉及内存的消耗，你会明白哪些操作是廉价的，哪些是昂贵的。\n第三章：vector的类型和属性(attributes)。\n第四章：子集操作。\n第五章：控制流，if,for,switch(),while等语句。\n第六章：函数function构建细节，运行机制，退出机制；lazy 语式。\n第七章：R环境的数据结构。\n第八章：控制如何输出错误，警告，信息等。\n\n\n\n\n Back to top",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html",
    "href": "Books/R4DS2/26 Iteration.html",
    "title": "26 Iteration",
    "section": "",
    "text": "在tidyverse中有一些常见的循环操作，如：\n\n绘制分面——facet_wrap(),facet_grid()\n分组总结–group_by(),summarise()\nlist-column解压——unnest_wider(),unnest_longer()\n\n下面我们学习另外一些循环技巧。\n\nlibrary(tidyverse)",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#选择列",
    "href": "Books/R4DS2/26 Iteration.html#选择列",
    "title": "26 Iteration",
    "section": "选择列",
    "text": "选择列\n.cols控制选择哪几列，是一个tidy-select类，类似于dplyr中的select()，可以使用适配select()的函数，如starts_with()、contains()等。\n更多有过关于tidy-select的内容，可以参考?dplyr_tidy_select。\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 × 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数",
    "href": "Books/R4DS2/26 Iteration.html#函数",
    "title": "26 Iteration",
    "section": "函数",
    "text": "函数\n.fns参数提供across()进行call的函数，可以是 - 函数名，例如mean，注意此处函数后不能有() - purrr-style lambda，例如~mean(.x, na.rm = TRUE) - 上述两种函数组成的named list，例如list(mean = mean,n_miss = ~ sum(is.na(.x))\n\n\n\n函数名\n\n# 函数名后有`()`会报错。\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ℹ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\n\n\n\n\npurrr-style lambda\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, ~ median(., na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\n\n\n\n\n函数list\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#列名",
    "href": "Books/R4DS2/26 Iteration.html#列名",
    "title": "26 Iteration",
    "section": "列名",
    "text": "列名\n如果你仔细观察，上面例子中的列名类似于{.col}_{.fn}（这也是为什么函数list是要有name属性的原因）。\n.names参数控制列名定义规则，使用{.col}表示原始列名，{.fn}表示函数名；单个函数默认{.col}，多个函数默认{.col}_{.fn}。\nacross()在与mutate()联用时会将原来的列覆盖，因为.names()默认是{.col}，所以看不出来，当参数值改变后就会直观的体现出来：\n\n\n\n与mutate联用\n\ndf_miss |&gt;\n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n#&gt; # A tibble: 5 × 8\n#&gt;        a      b      c     d a_na_zero b_na_zero c_na_zero d_na_zero\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60      0.434    -1.25      0         1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     0        -1.43     -0.297     0.776\n#&gt; 3 -0.156 -0.980 NA     1.15     -0.156    -0.980     0         1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13     -2.61     -0.683    -0.785     2.13 \n#&gt; 5  1.11  NA     -0.387 0.704     1.11      0        -0.387     0.704",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "href": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "title": "26 Iteration",
    "section": "filter()中的循环",
    "text": "filter()中的循环\ndplyr 提供了两个across()的变体:\n\nif_any()：至少有一个条件返回TRUE\nif_all()：所有条件返回TRUE\n\n\n# same as df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# same as df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "href": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "title": "26 Iteration",
    "section": "与piovt_longer()对比",
    "text": "与piovt_longer()对比\n使用piovt_longer()可以实现across()，反之则不成立。例如下面的两个例子\n\n\n\nacross\n\ndf |&gt;\n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\npivot_longer 复现\n\nlong &lt;- df |&gt;\n  pivot_longer(a:d) |&gt;\n  group_by(name) |&gt;\n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong |&gt;\n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\n只能使用pivot_longer\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\ndf_long &lt;- df_paired |&gt;\n  pivot_longer(\n    everything(),\n    names_to = c(\"group\", \".value\"),\n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 × 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ℹ 34 more rows\n\ndf_long |&gt;\n  group_by(group) |&gt;\n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 × 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "href": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "title": "26 Iteration",
    "section": "返回结果不同",
    "text": "返回结果不同\nmap()函数会返回一个list，其变体则不同。\n\n返回输入值\nwalk()函数只能隐性返回输入，对.f生成的结果没有处理，这在循环绘图中十分便利。\nres &lt;- 1:4 |&gt;\n  walk(\\(x) {\n    hist(rnorm(100, x))\n  })\n\nres\n#&gt; [1] 1 2 3 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n返回结果结构与输入相同\nmodify()函数会输出一个与输入结构完全相同的结果，常用来修改元素类型。\n\n# Convert to characters\niris |&gt; str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\niris |&gt;\n  modify(as.character) |&gt;\n  str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: chr  \"5.1\" \"4.9\" \"4.7\" \"4.6\" ...\n#&gt;  $ Sepal.Width : chr  \"3.5\" \"3\" \"3.2\" \"3.1\" ...\n#&gt;  $ Petal.Length: chr  \"1.4\" \"1.4\" \"1.3\" \"1.5\" ...\n#&gt;  $ Petal.Width : chr  \"0.2\" \"0.2\" \"0.2\" \"0.2\" ...\n#&gt;  $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n其还有变体modify_if()，modify_at()，modify2()，imodify()，使用方法相似，具体差异同下面讲到的一样。\n\n\n返回原子向量\n这一类有map_lgl(),map_int(),map_dbl(),map_chr(),map_vec()；要求返回的原子向量类型为函数名后缀规定的类型，否则报错。例如：map_lgl()函数要求返回结果为由TRUE和FALSE构成的向量，否则报错。map_vec()函数提供了参数.ptype，可以指定返回结果的类型。\n\nnumbers &lt;- list(1, 2, 3, 4)\n\nmap_lgl(numbers, ~ .x %% 2 == 0)\n#&gt; [1] FALSE  TRUE FALSE  TRUE\n\nmap_lgl(numbers, ~ .x * 2)\n#&gt; Error in `map_lgl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a number to a logical.\n\n\n\n返回数据框\n这一类有map_dfc(),map_dfr()，这两类函数在官方文档中已经不再推荐使用，而是使用map() + list_rbind()/list_cbind()的组合方式。\n\n# map ---------------------------------------------\n# Was:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map_dfr(\\(mod) as.data.frame(t(as.matrix(coef(mod)))))\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438\n# Now:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map(\\(mod) as.data.frame(t(as.matrix(coef(mod))))) |&gt;\n  list_rbind()\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "href": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "title": "26 Iteration",
    "section": "输入元素不同",
    "text": "输入元素不同\n这一类有：\n\n对不同位置元素操作：map_at(),map_if(),map_depth()。\n要求元素类型为长度是1的list：lmap()和其变体lmap_at(),lmap_if()。\n\n\nmap_at()\n通过参数.at，提供元素在输入中的位置或name属性，针对特定元素进行操作。\n\nl3 &lt;- list(\n  a = 1:3,\n  b = LETTERS[1:3],\n  c = 7:9\n)\n\nl3 |&gt;\n  map_at(.at = c(\"a\", \"c\"), ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_if()\n通过参数.p，提供元素要满足的条件，针对特定元素进行操作，可以是判断函数，也可以是逻辑向量。\n\nl3 |&gt;\n  map_if(.p = is.numeric, ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_depth()\n通过参数.depth，提供元素的深度，针对该深度处的元素进行操作。\n\nx &lt;- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))\nx |&gt; str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: int [1:2] 1 2\n#&gt;   ..$ bar: int [1:2] 3 4\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: int [1:2] 5 6\n\nx |&gt;\n  map_depth(2, \\(y) paste(y, collapse = \"/\")) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n# Equivalent to:\nx |&gt;\n  map(\\(y) map(y, \\(z) paste(z, collapse = \"/\"))) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n\n\nlmap() 类\nlmap()与map()的不同之处在于，后者提取使用[[i]]来提取list中的元素，返回一个向量，前者使用[i]提取list中的元素，返回一个list。\n由于lmap()操作对象是list，所以它可以使用list中的name属性；在返回结果时，它会使用c()将list合并。下面是一个示例：\n\nadd_minus &lt;- function(x) {\n  res1 &lt;- lapply(x, function(y) y - 1)\n  names(res1) &lt;- paste0(names(x), \"_minus\")\n  res2 &lt;- lapply(x, function(y) y + 1)\n  names(res2) &lt;- paste0(names(x), \"_plus\")\n  c(res1, res2)\n}\n\n# The output size varies each time we map f()\ntest &lt;- list(a = 1:4, c = 8:9)\ntest |&gt;\n  lmap(add_minus) |&gt;\n  str()\n#&gt; List of 4\n#&gt;  $ a_minus: num [1:4] 0 1 2 3\n#&gt;  $ a_plus : num [1:4] 2 3 4 5\n#&gt;  $ c_minus: num [1:2] 7 8\n#&gt;  $ c_plus : num [1:2] 9 10\n\n所以，lmap()对参数.x，.f有不同的要求：\n\n.x：list 或 data.frame\n.f：该函数输入为长度是1的list，输出是任意长度的list。",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "href": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "title": "26 Iteration",
    "section": "函数参数数目",
    "text": "函数参数数目\n这一类函数有map2()、pmap()和map2()的变体imap()。这些函数与map()的使用方法类似，只是多提供了一组或多组.f函数的参数。同时这些函数都有*_lgl(),*_int(), *_dbl(), *_chr(), *_vec(), *_dfc(), *_dfr(),*walk()等变体，使用方法同上。\n\nimap()\nimap()是map2(x, names(x), ...)或map2(x, seq_along(x), ...)的简写，其余使用方法相同。\n\nset.seed(123)\nimap_chr(sample(10), paste)\n#&gt;  [1] \"3 1\"  \"10 2\" \"2 3\"  \"8 4\"  \"6 5\"  \"9 6\"  \"1 7\"  \"7 8\"  \"5 9\"  \"4 10\"",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/index.html",
    "href": "Books/R4DS2/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍R for Data Science的学习笔记。\n原文见：R for Data Science (2e)\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/index.html",
    "href": "Books/Tidy Modeling with R/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Tidy Modeling with R的学习笔记。\n原文见：Tidy Modeling with R\ntidymodels R包官方网站：https://www.tidymodels.org\n本书主要包含两方面：\n\n如何使用tidymodels包进行机器学习建模\n统计建模中的实践经验\n\n下面是全文概览：\n\n第1章：概述模型的分类，强调什么是好的建模软件。\n第2章：回顾 tidyverse 语法。\n第3章：base R中的统计建模总览及其不足。\n第4~9章：tidymodel系列包的介绍：recipes，parsnip，workflows，yardstick等。\n第10~15章：模型性能评估与调参。\n第16~21章：如何理解和解构模型。\n\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html",
    "href": "Books/quarto/Project Basics.html",
    "title": "Project Basics",
    "section": "",
    "text": "原文：https://quarto.org/docs/projects/quarto-projects.html\nquarto的官方网站提供了许多创建项目的教程，如下图，如何创建项目，这里不再赘述。\n\n\n\n官网教程\n\n\n\n\n当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true\n\n\n\n\n使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#shared-metadata",
    "href": "Books/quarto/Project Basics.html#shared-metadata",
    "title": "Project Basics",
    "section": "",
    "text": "当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#rendering-projects",
    "href": "Books/quarto/Project Basics.html#rendering-projects",
    "title": "Project Basics",
    "section": "",
    "text": "使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nquarto 中R代码块的设置\n\n\n\n\n\n\nquarto\n\n\n\n\n\n\n\n\n\n2025-03-15\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nR 中的面向对象(1)\n\n\n\n\n\n\n面向对象\n\n\n\n\n\n\n\n\n\n2025-03-16\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nData Masking(1)\n\n\n\n\n\n\nrlang\n\n\ntidyverse\n\n\n\n\n\n\n\n\n\n2025-04-25\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\n相关性计算\n\n\n\n\n\n\ntriky skill\n\n\n\n\n\n\n\n\n\n2025-06-27\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\n绘制点脊图\n\n\n\n\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n2025-07-03\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\n替换多对字符串\n\n\n\n\n\n\npurrr\n\n\ntidyverse\n\n\n\n\n\n\n\n\n\n2025-07-24\n\n\n大番薯本薯\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html",
    "href": "Books/Advanced R(2e)/4 Subsetting.html",
    "title": "4 Subsetting",
    "section": "",
    "text": "R 中的提取子集操作上手很快，使用起来也很方便。但是想要掌握，需要理解并整合下面几点内容：\n\n有6种方法提取atomic向量的子集。\n有3种提取函数：[、[[和$。\n提取不同类型的对象，提取函数有不同的表现。\n提取函数可以搭配&lt;-来赋值。\n\n\n\n\n\n\n\nNote\n\n\n\n[、[[和$ 本质上是S3面向对象类型的函数\n\n\n\n\n\n4.2节：介绍[函数，及其在不同类型对象上的用法。\n4.3节：介绍[[和$函数，及其在不同类型对象上的用法。\n4.4节：介绍提取函数与&lt;-的搭配使用。\n4.5节：介绍8个实践案例。",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#introduction",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#introduction",
    "title": "4 Subsetting",
    "section": "",
    "text": "R 中的提取子集操作上手很快，使用起来也很方便。但是想要掌握，需要理解并整合下面几点内容：\n\n有6种方法提取atomic向量的子集。\n有3种提取函数：[、[[和$。\n提取不同类型的对象，提取函数有不同的表现。\n提取函数可以搭配&lt;-来赋值。\n\n\n\n\n\n\n\nNote\n\n\n\n[、[[和$ 本质上是S3面向对象类型的函数\n\n\n\n\n\n4.2节：介绍[函数，及其在不同类型对象上的用法。\n4.3节：介绍[[和$函数，及其在不同类型对象上的用法。\n4.4节：介绍提取函数与&lt;-的搭配使用。\n4.5节：介绍8个实践案例。",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#selecting-multiple-elements",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#selecting-multiple-elements",
    "title": "4 Subsetting",
    "section": "Selecting multiple elements",
    "text": "Selecting multiple elements\n\nAtomic vectors\n以提取atomic向量为例，介绍用作提取子集时的6种坐标：\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\n\n正整数：表示元素在向量中的位置。\n\n\nx[c(3, 1)]\n#&gt; [1] 3.3 2.1\nx[order(x)]\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n#&gt; [1] 4.2 4.2\n\n\n负整数：负号表示删除，正负不能同时存在。\n\n\nx[-c(3, 1)]\n#&gt; [1] 4.2 5.4\n\n\nx[c(-1, 2)]\n#&gt; Error in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n\n\n逻辑值：TRUE表示保留，FALSE表示删除，NA返回NA。在x[y]的模式中，如果二者长度不等，会发生循环，遵循R base中的循环原则：循环短的一方。\n\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n#&gt; [1] 4.2 3.3 5.4\nx[c(TRUE, NA, FALSE, TRUE)]\n#&gt; [1] 2.1  NA 5.4\n\n\nNothing：返回完整的对象，在后面对data.frame提取时有用。\n\n\nx[]\n#&gt; [1] 2.1 4.2 3.3 5.4\n\n\nZero：返回长度为0的向量。\n\n\nx[0]\n#&gt; numeric(0)\n\n\n字符串：有name属性的向量元素。\n\n\n(y &lt;- setNames(x, letters[1:4]))\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\n\n\n\n\n\n\nNote\n\n\n\n不要使用因子化的字符串向量提取子集，字符串向量因子化后，会视为整数。\n\ny[factor(\"b\")]\n#&gt;   a \n#&gt; 2.1\n\n\n\n\n\nLists\n[函数作用于list时，返回得仍然是一个list；[[和$函数作用于list时，返回得是list中的元素。\n\n\nMatrices and arrays\n对于多维的atomic Vector，只需要在每个维度上应用上述6种坐标，就可以得到子集。\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n#&gt;      A C\n\n因为Matrices和Arrays是带有特殊属性的向量，所以仍然可以只使用一维的向量来提取，但要注意：它们都是列向量。\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n#&gt; [1] \"4,1\" \"5,3\"\n\n可以使用一个两列matrix提取2维Matrices，三列matrix提取3维Arrays；一行表示一个坐标，返回一个向量。\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nselect\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    1\n#&gt; [2,]    3    1\n#&gt; [3,]    2    4\nvals[select]\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\n\n\nData frames and tibbles\nData.frame具有list和matrix的特性：\n\n当只提供一个index时，会将其视作list，返回列。\n当提供两个index时，将其视作matrix，返回矩阵。\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n\n# There's an important difference if you select a single\n# column: matrix subsetting simplifies by default, list\n# subsetting does not.\nstr(df[\"x\"])\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n#&gt;  int [1:3] 1 2 3\n\n对tibble使用[，始终返回tibble。\n\ntib &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(tib[\"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(tib[, \"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\n\n\nPreserving dimensionality\n[函数有额外的参数drop用于控制是否在只有一列时降维，默认为TRUE。\n正如上面例子中的结果一样，data.frame在列方向上的index长度为1时，会发生降维：df[\"x\"]没有发生降维，df[, \"x\"]则发生了降维。\n\nstr(df[, \"x\", drop = FALSE])\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\n\nmatrix则表现为任意维度的index长度为1时，都会发生降维：\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n#&gt;  int [1, 1:2] 1 3\n\n在factor中使用[时，也有参数drop；但该参数的意义为：是否丢弃没有值的级别，默认为FALSE。\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n#&gt; [1] a\n#&gt; Levels: a\n\n\n\nExercises\n…",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#selecting-a-single-element",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#selecting-a-single-element",
    "title": "4 Subsetting",
    "section": "Selecting a single element",
    "text": "Selecting a single element\n\n[[\n[[函数广泛应用在list或dataframe对象上，它与[函数的不同在于，返回得是降维的子对象。将一个list比作一列火车，[[返回的是火车中某车厢上的所有元素，[返回的是带有选取车厢的整列火车。\n\nx &lt;- list(1:3, \"a\", 4:6)\n\n\n\n\n使用[[函数时要注意：\n\n只能提供长度为1的整数或字符串作为index。\n当提供的长度大于1后，会递归地提取子对象。\n\n\nx1 &lt;- list(\n  1:3,\n  list( \"a\", \"b\"),\n  4:6\n)\n\nx1[[c(2,1)]]\n#&gt; [1] \"a\"\n# 等价于\nx1[[2]][[1]]\n#&gt; [1] \"a\"\n\n\n\n$\nx$y大致等于x[[\"y\", exact = FALSE]]。\n在使用$时，常见的错误是：使用当前环境变量中的某些变量来替代数据框或list中的name，此时推荐使用[[。\n\nvar &lt;- \"cyl\"\n# Doesn't work - mtcars$var translated to mtcars[[\"var\"]]\nmtcars$var\n#&gt; NULL\n\n# Instead use [[\nmtcars[[var]]\n#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n\n$与[[最大的不同是，$会自动地执行从左到右地部分匹配；可以添加options(warnPartialMatchDollar = TRUE)来添加提醒。\n\nx &lt;- list(abc = 1)\nx$a\n#&gt; [1] 1\nx[[\"a\"]]\n#&gt; NULL\n\n\noptions(warnPartialMatchDollar = TRUE)\nx$a\n#&gt; Warning in x$a: partial match of 'a' to 'abc'\n#&gt; [1] 1\n\n\n\nMissing and out-of-bounds indices\n在使用[[函数时，如果index无效，不同类型对象的结果不同。如下表中总结，三种类型的数据：atomic向量，list和NULL，四种无效的index：长度为0，超出范围（整数、字符串），缺失。\n\n\n\n\n\n\n\n\n\n\nrow[[col]]\nZero-length\nOut of bounds(Integer)\nOut of bounds(character)\nMissing\n\n\n\n\nAtomic\nError\nError\nError\nError\n\n\nList\nError\nError\nNULL\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\nNULL\n\n\n\n\nx &lt;- setNames(1:3, letters[1:3])\ny &lt;- list(A = 1:3, B = 4:6, C = 7:9)\nz &lt;- NULL\n\nx[[NULL]]\nx[[4]]\nx[[\"d\"]]\nx[[NA]]\n\ny[[NULL]]\ny[[4]]\ny[[\"D\"]]\ny[[NA]]\n\nz[[NULL]]\nz[[4]]\nz[[\"D\"]]\nz[[NA]]\n\n从表中可以看出，[[的结果存在非一致性。purrr包提供了另外两种取子集的函数purrr::pluck(),purrr::chuck()。purrr::pluck()可以设置元素缺失时的默认返回值（默认为NULL），purrr::chuck()总是返回错误。pluck()也允许混合整数和字符串的index。pluck()的优点，使得其在处理结构化数据json或web api结果时非常有用。\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n#&gt; [1] NA\n\n\n\n@ and slot()\n@和slot()设计到S4面向对象系统，我们将在后面的章节中学习。\n\n\nExercises\n…",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#subsetting-and-assignment",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#subsetting-and-assignment",
    "title": "4 Subsetting",
    "section": "Subsetting and assignment",
    "text": "Subsetting and assignment\n查看函数说明文档，如果包含FUN(x) &lt;-形式的函数，就支持赋值。\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n#&gt; [1] 101 102   3   4   5\n\n在使用赋值前，一定要检查好提取的子集长度等于赋的值长度、子集index唯一。因为base R的循环原则，会使得结果完全不符合预期。\n对于list，可以使用x[[i]] &lt;- NULL删除某个元素，如果是增加一个内容为NULL的元素可以使用x[i] &lt;- list(NULL)。\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\n前面讲到，提取空元素对atomic向量没有太多用处，但对数据框有重要作用：它可以保持数据框的数据结构：\n\nmtcars[] &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] TRUE\n\nmtcars &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] FALSE",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#applications",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#applications",
    "title": "4 Subsetting",
    "section": "Applications",
    "text": "Applications\n利用取子集的功能，你可以对数据框进行查找、拼接、排序、抽样、解压、删除等操作，下面是一些应用广泛的例子：\n\nLookup tables (character subsetting)\n创建查询表格，进行数据转换。\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\n# 去除name\nunname(lookup[x])\n#&gt; [1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"\n\n\n\nMatching and merging by hand (integer subsetting)\n使用match()函数与整数索引进行数据匹配和合并。\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\nRandom samples and bootstraps (integer subsetting)\n同上，使用整数索引，搭配sample()函数，模拟抽样与bootstrap。\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\nOrdering (integer subsetting)\n同上，使用整数索引，搭配order()函数，对数据框排序。\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\nExpanding aggregated counts (integer subsetting)\n使用函数rep()，将行相同且具有重复数的数据框解压。\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\nRemoving columns from data frames (character)\n删除数据框的某列。\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\ndf[setdiff(names(df), \"z\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\nSelecting rows based on a condition (logical subsetting)\n使用逻辑向量筛选数据框的行。\n\ndata(mtcars)\nmtcars[mtcars$gear == 5, ]\n#&gt;                 mpg cyl  disp  hp drat    wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n#&gt;                mpg cyl  disp  hp drat    wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n\n\nBoolean algebra versus sets (logical and integer )\nwhich()函数可以将布尔索引转换为整数索引。但x[which(y)]与x[y]仍然有一些差别：\n\n当布尔索引中存在缺失值NA时，对应得返回值也是NA。而which()会自动丢掉NA。\nx[-which(y)]与x[!y]不是等价的：如有y全部是FALSE，which(y)返回integer(0)，而-integer(0)仍然是integer(0)，最终前者返回一个空的向量，后者返回全部值。\n\n\nx &lt;- c(1, 2, 3, 4, NA, 5)\n\nx[which(x &gt; 2)]\n#&gt; [1] 3 4 5\nx[x &gt; 2]\n#&gt; [1]  3  4 NA  5\n\nx[-which(x &gt; 10)]\n#&gt; numeric(0)\nx[!x &gt; 10]\n#&gt; [1]  1  2  3  4 NA  5\n\n布尔向量的运算可以使用intersect()，`union()，setdiff()等函数进行等价替换。\n\n(x1 &lt;- 1:10 %% 2 == 0)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n#&gt; [1] 2 4 6 8 5",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html",
    "href": "Books/Advanced R(2e)/5 Control flow.html",
    "title": "5 Control flow",
    "section": "",
    "text": "R 中有两类主要的控制流类型工具：选择（if）和循环（for）。选择包含if、switch()等声明；循环包含for、while等声明。这里假定你已经学会了它们的基础用法，本章主要介绍一些技术细节和鲜为人知的高级用法。\n\n\n\n5.2节：介绍if、ifelse()、switch()函数。\n5.3节：介绍for、while、repeat等声明。",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#introduction",
    "href": "Books/Advanced R(2e)/5 Control flow.html#introduction",
    "title": "5 Control flow",
    "section": "",
    "text": "R 中有两类主要的控制流类型工具：选择（if）和循环（for）。选择包含if、switch()等声明；循环包含for、while等声明。这里假定你已经学会了它们的基础用法，本章主要介绍一些技术细节和鲜为人知的高级用法。\n\n\n\n5.2节：介绍if、ifelse()、switch()函数。\n5.3节：介绍for、while、repeat等声明。",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#choices",
    "href": "Books/Advanced R(2e)/5 Control flow.html#choices",
    "title": "5 Control flow",
    "section": "Choices",
    "text": "Choices\n下面是if-else语句的基本使用格式：\n\nif (condition) true_action\n\nif (condition) true_action else false_action\n\nif (condition1) {\n  true_action1\n} else if (condition2) {\n  true_action2\n} else {\n  false_action\n}\n\nif语句也可以进行赋值操作；在实际书写代码时，建议只有在if-else语句可以写为一行时，才使用赋值操作。\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n#&gt; [1] 1 2\n\n当if-else语句只有if声明时，如果条件不满足，则返回NULL。函数c()、paste()会自动去除返回值中的NULL值。\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n\nInvalid inputs\n需要注意的是，if声明中的条件返回值只能是长度为1的布尔值。如果长度大于1，在R 4.0版本前会选择第一个值，但在R 4.0版本后会报错。其他类型的输入也会报错。\n\nif (\"x\") 1\n#&gt; Error in if (\"x\") 1: argument is not interpretable as logical\nif (logical()) 1\n#&gt; Error in if (logical()) 1: argument is of length zero\nif (NA) 1\n#&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\nif (c(TRUE, FALSE)) 1\n#&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\n\n\nVectorised if\nif-else 语句只能判断一次，假如你想要判断很多次，可以使用ifelse()函数。该函数接受三个参数：条件，返回值，其他值。如果条件为TRUE，返回值作为结果，否则返回其他值。条件处可以是向量，返回的也是向量。（可以理解for循环if-else语句）\n\nx &lt;- c(1:10, NA, 12)\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\" NA    \"12\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n#&gt; [11] NA     \"even\"\n\n\n\n\n\n\n\nTip\n\n\n\n建议只有在yes和no条件的返回值类型一致时，再使用ifelse()函数。如果不同，因为c()是atomic向量，会强制进行类型转换。函数要求得条件如果不是布尔值，则会进行类型转换as.logical()，如果转换结果仍不是布尔值，则会返回转换后的值。\n\n\ndplyr包提供了等价函数case_when()，使用方法如下：\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n#&gt; [11] \"???\"  \"12\"\n\n\n\nswitch() statement\nswitch()语句是对if-else语句的压缩，例如你可以将下面的if-else语句:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\"\n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n简化为switch()语句:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\n\n再判断条件的末尾添加错误信息，可以提高代码的可读性，因为当不满足匹配条件时，switch()语句返回NULL。\n\n(switch(\"c\",\n  a = 1,\n  b = 2\n))\n#&gt; NULL\n\n如果不同的输入条件返回值相同，可以省略返回值，switch()会自动向下匹配，例如:\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n#&gt; [1] 4\nlegs(\"dog\")\n#&gt; [1] 4\n\n\n\n\n\n\n\nTip\n\n\n\nswitch()的输入可以是数值、字符串，但建议只使用字符串。\n\n\n\n\nExercises\n…",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#loops",
    "href": "Books/Advanced R(2e)/5 Control flow.html#loops",
    "title": "5 Control flow",
    "section": "Loops",
    "text": "Loops\nfor 循环的基本格式如下：\n\nfor (item in vector) perform_action\n\n有两种中断循环的方法：break和next。break用于跳出整个循环，next用于跳出当前循环，继续下一个循环。\n\nfor (i in 1:10) {\n  if (i &lt; 3) {\n    next\n  }\n\n  print(i)\n\n  if (i &gt;= 5) {\n    break\n  }\n}\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n\n\n\n\n\n\nNote\n\n\n\n要注意在环境变量中不要有与item名重复的变量。for循环会赋值给item变量，这样会导致item变量的值变化。\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n#&gt; [1] 3\n\n\n\n\nCommon pitfalls\n在使用for循环时，有三个常见的易错陷阱：\n\n进行赋值操作前，没有定义容纳结果的变量。\n使用1:length(x)作为索引，而不是seq_along(x)。\n直接索引S3对象。\n\n如果没有事先定义容器，会导致for循环十分缓慢。可以使用vector()函数，定义容器类型：\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n1:length(x)在x的长度为0时，会报错。因为:对升序和降序都兼容，使用seq_along()函数可以变相的解决该问题。seq_along()函数返回一个长度与x相同的等差向量。\n\nx &lt;- c(1, 2, 3, 1,2,3)\ny &lt;- numeric(0)\n\n1:length(x)\n#&gt; [1] 1 2 3 4 5 6\nseq_along(x)\n#&gt; [1] 1 2 3 4 5 6\n\n1:length(y) # 在for循环中报错\n#&gt; [1] 1 0\nseq_along(y)\n#&gt; integer(0)\n\n\nmeans &lt;- c()\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n#&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n直接迭代S3对象时，for循环会丢掉S3对象的属性：\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\"\n\n\n\nRelated tools\n当你不知道要迭代多少次，可以使用while()和repeat()，它们的基本格式如下：\n\n# 当满足条件时，执行动作，直到条件不满足\nwhile (condition) action\n# 无限循环，直到遇到 break\nrepeat(action)\n\n\nx &lt;- 0\nwhile (x &lt; 10) {\n  x &lt;- x + 1\n  print(x)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n\nrepeat {\n  print(x)\n  x &lt;- x + 1\n  if (x &gt; 10) {\n    break\n  }\n}\n#&gt; [1] 10\n\n理论上讲：所有for循环都可以用while循环替代，所有while循环都可以用repeat循环替代，但是反过来不行；这意味着for循环的灵活性很低，但是在实践中，我们应该使用灵活性低的for循环。\n在数据分析中，我们可以使用更高级的map()和apply()函数。\n\n\nExercises\n\n一定要避免使用1:length(x)，下面的例子，不会报错，但是返回结果不对。\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n#&gt; [[1]]\n#&gt; [1] NA\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in seq_along(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n#&gt; list()\n\n\nR的for循环只评估一次输入，即使for循环中对评估进行了更新，也不会改变，避免了无限循环的可能。\n\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n#&gt; [1] 1 2 3 2 4 6\n\n\nR的for循环对于item的更新发生在每次迭代开始前，for循环中对item进行的更新无效。\n\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html",
    "href": "Books/Advanced R(2e)/6 Functions.html",
    "title": "6 Functions",
    "section": "",
    "text": "在学习本章之前，你一定已经写过很多用来减少重复工作的函数，本章会将你在工作中的一些知识进行整合提升，帮助你从理论的视角看待函数。在本章，你会看到一些有趣的小技巧和复杂技术，请一定要留心，这些内容是后面章节中的基石。\n\n\n\n下面的代码运行时会报错吗？\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n\n无论运行成功或失败，函数如何都执行一些操作？\n\n\n\n\n\n6.2节：构成函数的三要素和原始函数（primitive function）。\n6.3节：函数联合使用的三种方法及其优劣。\n6.4节：词法作用域规则（rules of lexical scoping）——如何根据名字找到对应的值。\n6.5节：参数评估原则：只在第一次使用时评估，避免循环。\n6.6节：特殊参数...。\n6.7节：函数退出机制。\n6.8节：四种函数格式。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#introduction",
    "href": "Books/Advanced R(2e)/6 Functions.html#introduction",
    "title": "6 Functions",
    "section": "",
    "text": "在学习本章之前，你一定已经写过很多用来减少重复工作的函数，本章会将你在工作中的一些知识进行整合提升，帮助你从理论的视角看待函数。在本章，你会看到一些有趣的小技巧和复杂技术，请一定要留心，这些内容是后面章节中的基石。\n\n\n\n下面的代码运行时会报错吗？\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n\n无论运行成功或失败，函数如何都执行一些操作？\n\n\n\n\n\n6.2节：构成函数的三要素和原始函数（primitive function）。\n6.3节：函数联合使用的三种方法及其优劣。\n6.4节：词法作用域规则（rules of lexical scoping）——如何根据名字找到对应的值。\n6.5节：参数评估原则：只在第一次使用时评估，避免循环。\n6.6节：特殊参数...。\n6.7节：函数退出机制。\n6.8节：四种函数格式。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-fundamentals",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-fundamentals",
    "title": "6 Functions",
    "section": "Function fundamentals",
    "text": "Function fundamentals\n\nFunction components\n函数由三部分组成：\n\nformals()：参数和函数名，控制如何调用函数。\nbody()：函数具体实现。\nenvironment()：环境，决定函数如何找到参数对应的值。\n\n在这三部分中，formals和body十分显性，构建出函数时就可以直观地看到；environment相对隐性，需要使用函数environment()。\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n\nbody(f02)\n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nenvironment(f02)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n与R中的其他对象一样，函数也会拥有一些属性。一个常见的属性是srcref（source reference），记录了函数的源代码，如下所示。\n\nattr(f02, \"srcref\")\n#&gt; NULL\n\n\n\nPrimitive functions\n原始函数（primitive function）是一个例外，不包含上面的三要素。\n\nsum\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#&gt; .Primitive(\"[\")\n\n它们的base type不同。（base type 见第12章）\n\ntypeof(sum)\n#&gt; [1] \"builtin\"\ntypeof(`[`)\n#&gt; [1] \"special\"\n\n因为它们的底层是C语言，所以formals()、body()和environment()返回值都是NULL。\n\nformals(sum)\n#&gt; NULL\nbody(sum)\n#&gt; NULL\nenvironment(sum)\n#&gt; NULL\n\n\n\nFirst-class functions\n所谓的first-class，就是指函数本身就是对象，可以用来赋值给变量，可以传递给函数等等。创建函数只需要function()来定义，使用&lt;-进行绑定。\n如果一个函数没有绑定名字，那么它就是匿名函数。匿名函数通常用在lapply()等函数中，用来实现高效的数据处理。\n\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x)^2, 0, pi)\n\n有关R函数的闭包特性，见第7章。\n\n\nInvoking a function\n使用函数的常见方式是myfun(param1, param2, ...)，如果你有了一组参数数据，可以使用do.call()来调用函数。\n\nargs &lt;- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#&gt; [1] 5.5\n\n\n\nExercises\n\n使用is.function()来判断一个对象是否是函数。对于原始函数，使用is.primitive()。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-composition",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-composition",
    "title": "6 Functions",
    "section": "Function composition",
    "text": "Function composition\nbase R 提供了两种函数组合使用的方式。例如，当你想使用sqrt()和mean()计算某个群体的方差：\n\nx &lt;- runif(100)\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\n\n第一种方法：\n\nsqrt(mean(square(deviation(x))))\n#&gt; [1] 0.2744786\n\n第二种方法：\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n#&gt; [1] 0.2744786\n\nmagrittr包提供了第三种方式——管道符%&gt;%（R 4.0 之后可以之间使用 |&gt; 代替）。\n\nlibrary(magrittr)\n\nx %&gt;%\n  deviation() %&gt;%\n  square() %&gt;%\n  mean() %&gt;%\n  sqrt()\n#&gt; [1] 0.2744786",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#lexical-scoping",
    "href": "Books/Advanced R(2e)/6 Functions.html#lexical-scoping",
    "title": "6 Functions",
    "section": "Lexical scoping",
    "text": "Lexical scoping\n在第二章中，我们讲到为对象命名；在这里，我们介绍它的反面，根据名字找到对象——词法作用域(lexical scoping)。\nR 的词法作用域遵循下面四个规则：\n\nName masking——函数内部的变量优先于函数外部的变量。\nFunctions versus variables——当某个函数与变量同名时，R自动找到对应的对象。\nA fresh start——函数每次执行都是独立的。\nDynamic lookup——函数只有在运行时才会查找对应的对象。\n\n\nName masking\n函数查找变量时，首先查找函数内的变量，然后再查找函数外，即——由内到外逐级查找，直至找到为止。\n\nx &lt;- 10\ny &lt;- 20\nz &lt;- 30\ng05 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y, z)\n}\ng05()\n#&gt; [1]  1  2 30\n\n\n\nFunctions versus variables\n诚如上述，函数也是普通的对象，在进行函数的查找时，遵循相同的规则。\n\ng07 &lt;- function(x) x + 1\ng08 &lt;- function() {\n  g07 &lt;- function(x) x + 100\n  g07(10)\n}\ng08()\n#&gt; [1] 110\n\n如果，函数名和变量名重复（函数和变量在不同的环境中）时，R会自动找到对应类型的对象，例如下面的g09。实际编写代码时，我们要尽可能避免这种情况的发生，因为十分歧义和迷惑。\n\ng09 &lt;- function(x) x + 100\ng10 &lt;- function() {\n  g09 &lt;- 10\n  g09(g09)\n}\ng10()\n#&gt; [1] 110\n\n\n\nA fresh start\n下面的例子，每次运行g11()结果都是相同的，因为每次运行函数时，都会创建一个变量域（环境），它们之间相互独立。\n\ng11 &lt;- function() {\n  if (!exists(\"a\")) {\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng11()\n#&gt; [1] 1\ng11()\n#&gt; [1] 1\n\n当你使用a &lt;- g11()时，就打破了独立。\n\na &lt;- g11()\ng11()\n#&gt; [1] 2\ng11()\n#&gt; [1] 2\n\n\n\nDynamic lookup\n函数只有在运行时才会根据名字查找对象，也即前后环境不一致时，函数前后运行值也就不一样。\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n#&gt; [1] 16\n\nx &lt;- 20\ng12()\n#&gt; [1] 21\n\n使用codetools::findGlobals()可以里列出函数内的外部依赖项。\n\ncodetools::findGlobals(g12)\n#&gt; [1] \"+\" \"x\"\n\nenvironment(g12) &lt;- emptyenv()\ng12()\n#&gt; Error in x + 1: could not find function \"+\"\n\n\n\nExercises\n…",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#lazy-evaluation",
    "href": "Books/Advanced R(2e)/6 Functions.html#lazy-evaluation",
    "title": "6 Functions",
    "section": "Lazy evaluation",
    "text": "Lazy evaluation\nR 函数中的参数具有延迟评估（Lazy evaluation）特点：只有参数被使用时，才会对其进行评估（运行）。\n\nh01 &lt;- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#&gt; [1] 10\n\n这一特性允许解析耗时的参数只有在函数运行且被调用时进行解析。\n\nPromises\n延迟评估由一种被称为promise或thunk的数据结构赋能（这种数据结构，本人也不是很了解，可以GPT一下）。\npromise有三种类型：\n\n表达式，如1 + 1。\n创建的环境，如：函数自己的变量域。\n\n\ny &lt;- 10\nh02 &lt;- function(x) {\n  y &lt;- 100\n  x + 1\n}\n\nh02(y)\n#&gt; [1] 11\nh02(y &lt;- 1000)\n#&gt; [1] 1001\ny\n#&gt; [1] 1000\n\n\n无需重复计算的值，如下面的message结果只打印一次。\n\n\ndouble &lt;- function(x) {\n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 &lt;- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#&gt; [1] 40 40\n\nx &lt;- double(20)\nh03(x)\n#&gt; [1] 40 40\n\npromise类型的延迟评估具有一种“薛定谔的猫”的特点，任何尝试用R去评估它的操作都会破坏其promise特性。\n\n\nDefault arguments\n延迟评估，允许函数在设置默认参数时，引用函数内部变量域，例如下面的例子。在base R中的许多函数都有类似的应用，但是不推荐这样使用，这样会增加函数理解的困难。\n\nh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n\n  c(x, y, z)\n}\n\nh04()\n#&gt; [1]   1   2 110\n\n另外一个需要注意的是：将要延迟评估的表达式，“作为默认参数”和“直接传递给函数”，是两种不同的情况。下面的示例中，ls()作为默认参数时，评估的是函数内部的变量域，而不是外部环境。\n\nh05 &lt;- function(x = ls()) {\n  a &lt;- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#&gt; [1] \"a\" \"x\"\n\nh05(ls())\n#&gt;  [1] \"a\"         \"args\"      \"deviation\" \"double\"    \"f02\"       \"g05\"      \n#&gt;  [7] \"g07\"       \"g08\"       \"g09\"       \"g10\"       \"g11\"       \"g12\"      \n#&gt; [13] \"h01\"       \"h02\"       \"h03\"       \"h04\"       \"h05\"       \"out\"      \n#&gt; [19] \"square\"    \"status\"    \"x\"         \"y\"         \"z\"\n\n\n\nMissing arguments\n函数missing()可以用来判断函数参数值来源，若来自于默认值，那么返回TRUE，否则返回FALSE。\n\nh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\nstr(h06(10))\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10\n\n\n\nExercises\n\n下面代码发生的过程：\n\npromisex = {y &lt;- 1; 2}在函数f1自己创建的环境中被评估，赋值1给y，返回数值2。\npromise最终的运行结果——2，赋值给函数参数x。\n因为Name masking，不使用函数默认值，使用先前赋值为1的y。\n因为函数内部评估不影响外部变量，所以最外面的y仍为10。\n\n\n\ny &lt;- 10\nf1 &lt;- function(x = {\n                 y &lt;- 1\n                 2\n               }, y = 0) {\n  c(x, y)\n}\nf1()\n#&gt; [1] 2 1\ny\n#&gt; [1] 10",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#dot-dot-dot",
    "href": "Books/Advanced R(2e)/6 Functions.html#dot-dot-dot",
    "title": "6 Functions",
    "section": "...(dot-dot-dot)",
    "text": "...(dot-dot-dot)\n...是R函数的一个特殊参数，它使得R函数可以有任意数目的参数。\n\n应用...\n...主要应用在下面两种情况：\n\n要传递额外参数给另外一个函数。\n\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\n# 常见的apply家族函数\nx &lt;- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#&gt; List of 2\n#&gt;  $ : num 2\n#&gt;  $ : num 5\n\n\nS3面向对象中的方法函数，如下面的print()函数，对于不同类使用不同参数。S3面向对象详见第13章。\n\n\nprint(factor(letters), max.levels = 4)\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; 26 Levels: a b c ... z\n\nprint(y ~ x, showEnv = TRUE)\n#&gt; y ~ x\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n\n解析...\n\n可以使用..N的形式，来访问...中的第N个参数。\n\n\ni03 &lt;- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#&gt; List of 2\n#&gt;  $ first: num 1\n#&gt;  $ third: num 3\n\n\n可以使用list(...)将其转换为list，储存起来。\n\n\ni04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2\n\n\nrlang包提供了额外的解析方法。\n\n\nrlang::list2()\nrlang::enquos()",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#exiting-a-function",
    "href": "Books/Advanced R(2e)/6 Functions.html#exiting-a-function",
    "title": "6 Functions",
    "section": "Exiting a function",
    "text": "Exiting a function\n大多数函数的退出机制有两种：\n\n显性或隐性的返回一个值，表示运行成功。\n抛出错误信息，表示运行失败。\n\n\nImplicit versus explicit returns\n\n使用return()指定返回值。\n如果不使用return()指定返回值，默认使用最后运行代码的值作为返回值。\n\n\nj01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#&gt; [1] 0\nj01(15)\n#&gt; [1] 10\n\nj02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\nj02(5)\n#&gt; [1] 0\nj02(15)\n#&gt; [1] 10\n\n\n\nInvisible values\n如果没有将函数的返回值赋值给某个变量，函数会将结果打印出来。\n\nj03 &lt;- function() 1\nx &lt;- j03()\nj03()\n#&gt; [1] 1\n\n使用invisible()可以阻止函数自动打印。\n\nj04 &lt;- function() invisible(1)\nj04()\nprint(j04())\n#&gt; [1] 1\n(j04())\n#&gt; [1] 1\n\n使用withVisible()可以获取函数的返回值和是否可见。\n\nstr(withVisible(j04()))\n#&gt; List of 2\n#&gt;  $ value  : num 1\n#&gt;  $ visible: logi FALSE\n\n最常见的隐藏返回值的函数就是&lt;-。\n\na &lt;- 2\n(a &lt;- 2)\n#&gt; [1] 2\n\n\n\nErrors\n当函数运行失败时，应当使用stop()函数抛出错误信息，并终止函数运行。抛出错误信息是为了让使用者知道函数运行失败的原因，以及如何处理。\n\nj05 &lt;- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#&gt; Error in j05(): I'm an error\n\n\n\nExit handlers\n在函数处理过程中，经常会有更新当前工作路径、绘图参数等全局变量，在函数运行结束后又要复原这些全局变量的操作。此时可以使用on.exit()函数来添加函数在退出时的操作。下面的示例显示了：无论函数运行成功还是失败，on.exit()函数都会执行。\n\nj06 &lt;- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n\n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#&gt; Hello\n#&gt; Goodbye!\n#&gt; [1] 10\n\nj06(FALSE)\n#&gt; Hello\n#&gt; Error in j06(FALSE): Error\n\non.exit()函数的另外两个参数：\n\nadd：当有多个退出操作时，如果add为FALSE则新的操作会覆盖原来的操作，推荐总是设置为TRUE。\nafter：当有多个退出操作时，如果after为FALSE，新的操作会最先执行。\n\n\nj08 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = FALSE)\n}\nj08()\n\nj09 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE, after = TRUE)\n  on.exit(message(\"b\"), add = TRUE, after = TRUE)\n  on.exit(message(\"c\"), add = TRUE, after = FALSE)\n}\nj09()\n\n\n\nExercises\n了解一下sink(),capture.output()函数。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-forms",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-forms",
    "title": "6 Functions",
    "section": "Function forms",
    "text": "Function forms\n\n\n\n\n\n\nTip\n\n\n\nR 里面的两句slogan：\n\nEverything that exists is an object.\nEverything that happens is a function call. — John Chambers\n\n\n\nR 中的函数有四种变体：\n\nprefix：函数名在参数前，例如mean(x)。\ninfix：函数名在参数之间，例如x + y的+；可以使用%前后包裹函数名，进行自定义。\nreplacement：带有&lt;-赋值操作的函数，例如names(df) &lt;- c(\"a\", \"b\")。\nspecial：例如[[、if、for等。\n\n\nRewriting to prefix form\n任何形式的函数都可以改写成prefix形式。\n\nx + y\n`+`(x, y)\n\nnames(df) &lt;- c(\"x\", \"y\", \"z\")\n`names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n\nfor (i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n\nR 的这种特性，可以让你随意地更改R中的基本函数。下面是一个更新了(函数的例子，大约10次中有1次，返回值会加1。\n\n`(` &lt;- function(e1) {\n  if (is.numeric(e1) && runif(1) &lt; 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#&gt;  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#&gt; [37] 3 3 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\n\n\n\nPrefix form\nprefix 格式的函数可以通过下面三种方式检索参数（也是检索优先级，由高至低）：\n\n使用参数名。\n使用参数名部分匹配。\n使用参数位置。\n\n\nk01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\n\n\nstr(k01(1, 2, 3))\nstr(k01(2, 3, abcdef = 1)) 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n\n# But this doesn't work because abbreviation is ambiguous\nstr(k01(1, 3, b = 1))\n#&gt; Error in parse(text = input): &lt;text&gt;:2:28: unexpected numeric constant\n#&gt; 1: str(k01(1, 2, 3))\n#&gt; 2: str(k01(2, 3, abcdef = 1)) 3\n#&gt;                               ^\n\n通常使用位置的参数是函数参数中最常用的几个，不推荐使用部分匹配设置参数。很遗憾，在R中无法禁用模糊匹配，但可以设置options(warnPartialMatchArgs = TRUE)，生成警告信息。\n\noptions(warnPartialMatchArgs = TRUE)\nx &lt;- k01(a = 1, 2, 3)\n\n\n\nInfix form\ninfix 格式的函数要求只能有两个参数。在base R中有许多这种格式的函数：:, ::, :::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &, &&, |, ||, ~, &lt;-, and &lt;&lt;-。也可以使用%前后包裹函数名，进行自定义。例如%*%,%in%等。\n\n`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#&gt; [1] \"new string\"\n\n%之间的函数名可以是除%外的任意字符，需要转义的字符只需在定义时进行转义，使用时无须转义。\n\n`% %` &lt;- function(a, b) paste(a, b)\n`%/\\\\%` &lt;- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#&gt; [1] \"a b\"\n\"a\" %/\\% \"b\"\n#&gt; [1] \"a b\"\n\ninfix 格式的函数总是将其左右两端的参数作为输入。\n\n`%-%` &lt;- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#&gt; [1] \"((a %-% b) %-% c)\"\n\n\n\nReplacement form\nreplacement 格式的函数要求：\n\n至少两个参数，分别是待赋值的对象和值。\n必须返回更新值后的对象。\n\n\n`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\n\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\n如果你要添加额外参数，需要将其放置在x和value之间。\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\nmodify(x, 1) &lt;- 10\nx\n#&gt;  [1] 10  5  3  4  5  6  7  8  9 10\n\n使用tracemem()追踪内存地址的变化。\n\nx &lt;- 1:10\ntracemem(x)\n#&gt; [1] \"&lt;0x5586ac400b08&gt;\"\n\nsecond(x) &lt;- 6L\n#&gt; tracemem[0x5586ac400b08 -&gt; 0x5586b3037368]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n#&gt; tracemem[0x5586b3037368 -&gt; 0x5586b3036488]: second&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\n\n\nSepcial forms\n下面是一些特殊格式的函数和它转换为prefix后的格式\n\n\n\n\n\n\n\nspecial form\nprefix form\n\n\n\n\n(x)\n`(`(x)\n\n\n{x}\n`{`(x)\n\n\nx[i]\n`[`(x, i)\n\n\nx[[i]]\n`[[`(x, i)\n\n\nif (cond) true\n`if`(cond, true)\n\n\nif (cond) true else false\n`if`(cond, true, false)\n\n\nfor(var in seq) action\n`for`(var, seq, action)\n\n\nwhile (cond) action\n`while`(cond, action)\n\n\nrepeat expr\n`repeat`(expr)\n\n\nnext\n`next`()\n\n\nbreak\n`break`()\n\n\nfunction(arg1, arg2) {body}\n`function`(alist(arg1, arg2), body, env )\n\n\n\n\n\nExercises\n…",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Blog/dot dot dot.html",
    "href": "Blog/dot dot dot.html",
    "title": "评估参数…",
    "section": "",
    "text": "rlang::list2()\n#&gt; list()\nrlang::enquos()\n#&gt; &lt;list_of&lt;quosure&gt;&gt;\n#&gt; \n#&gt; named list()\nsum()\n#&gt; [1] 0\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Blog/Data Masking.html",
    "href": "Blog/Data Masking.html",
    "title": "Data Masking(1)",
    "section": "",
    "text": "library(tidyverse)\nlibrary(rlang)"
  },
  {
    "objectID": "Blog/Data Masking.html#什么是data-masking",
    "href": "Blog/Data Masking.html#什么是data-masking",
    "title": "Data Masking(1)",
    "section": "什么是data-masking",
    "text": "什么是data-masking\nData-masking 是一种允许直接调用数据框中的列名作为一个正常环境变量的技术。例如下例，使用with函数实现该目的：\n\n# Unmasked programming\nmean(mtcars$cyl + mtcars$am)\n#&gt; [1] 6.59375\n\n# Referring to columns is an error - Where is the data?\nmean(cyl + am)\n#&gt; Error: object 'cyl' not found\n\n# Data-masking\nwith(mtcars, mean(cyl + am))\n#&gt; [1] 6.59375"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-带来的问题",
    "href": "Blog/Data Masking.html#data-masking-带来的问题",
    "title": "Data Masking(1)",
    "section": "data-masking 带来的问题",
    "text": "data-masking 带来的问题\n虽然 data-masking 技术使得操作数据框十分方便，但会增加创造函数的困难。例如下面例子中的var,var2在函数bodys中并不表示参数，而是被 data-masking 解释为数据data中的列。\n\nmy_mean &lt;- function(data, var1, var2) {\n  dplyr::summarise(data, mean(var1 + var2))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt; Error in `dplyr::summarise()`:\n#&gt; ℹ In argument: `mean(var1 + var2)`.\n#&gt; Caused by error:\n#&gt; ! object 'cyl' not found\n\n使用{{可以避免 data-masking 带来的问题，因为它会把var1和var2解释为参数而不是数据data中的列。\n\nmy_mean &lt;- function(data, var1, var2) {\n  dplyr::summarise(data, mean({{ var1 }} + {{ var2 }}))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt;   mean(cyl + am)\n#&gt; 1        6.59375"
  },
  {
    "objectID": "Blog/Data Masking.html#masking-具体是什么意思",
    "href": "Blog/Data Masking.html#masking-具体是什么意思",
    "title": "Data Masking(1)",
    "section": "masking 具体是什么意思？",
    "text": "masking 具体是什么意思？\n从上面的例子中也可以看出，所谓的masking，就是词法作用域的优先级。相同变量名在data-masking中会被优先解释为数据框中的列，而非外部环境中的变量。rlang 包所构建的tidy eval框架提供了pronouns来声明变量的所属环境。\n\ncyl &lt;- 1000\n\nmtcars %&gt;%\n  dplyr::summarise(\n    mean_data = mean(.data$cyl),\n    mean_env = mean(.env$cyl)\n  )\n#&gt;   mean_data mean_env\n#&gt; 1    6.1875     1000"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-如何工作",
    "href": "Blog/Data Masking.html#data-masking-如何工作",
    "title": "Data Masking(1)",
    "section": "data-masking 如何工作？",
    "text": "data-masking 如何工作？\ndata-masking 依赖R语言的三个特点：\n\ndefuse 变量，如 base R 中的substitute()、rlang 中的enquo(),{{等。\nfirst class environment。环境在R中一个类似list的特殊对象，R 允许将list或dataframe转换为环境。\n\n\nas.environment(mtcars)\n#&gt; &lt;environment: 0x000001e1585adca0&gt;\n\n\n评估函数——eval()(base)、eval_tidy()(rlang)。\n\n也即：先将变量名转换为defused状态，变得不可用，然后将dataframe转换为环境，最后在转换后的环境中重新评估变量。"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-编程模式",
    "href": "Blog/Data Masking.html#data-masking-编程模式",
    "title": "Data Masking(1)",
    "section": "data-masking 编程模式",
    "text": "data-masking 编程模式\n诚如上述，在函数中使用 data-masking，需要特殊处理才能正确解析参数。在rlang官网上，有四种解决方案。\n\nforwarding pattern\n\n\n使用{{\n{{用来直接解析单个参数，并且不丢失原有的信息（观察下面例子列名）。\n\nmy_summarise &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise({{ var }})\n}\n\nmtcars %&gt;% my_summarise(mean(cyl))\n#&gt;   mean(cyl)\n#&gt; 1    6.1875\n\nx &lt;- \"cyl\"\nmtcars %&gt;% my_summarise(mean(.data[[x]]))\n#&gt;   mean(.data[[\"cyl\"]])\n#&gt; 1               6.1875\n\n\n\n...\n... 不要求额外的语法设置，可以直接使用，用来解析多个参数。\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(...)\n}\n\nmtcars %&gt;% my_group_by(cyl = cyl * 100, am)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21     600   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21     600   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8   400   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4   600   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7   800   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1   600   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\nmy_select &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::select(...)\n}\n\nmtcars %&gt;% my_select(starts_with(\"c\"), vs:carb)\n#&gt;                     cyl carb vs am gear\n#&gt; Mazda RX4             6    4  0  1    4\n#&gt; Mazda RX4 Wag         6    4  0  1    4\n#&gt; Datsun 710            4    1  1  1    4\n#&gt; Hornet 4 Drive        6    1  1  0    3\n#&gt; Hornet Sportabout     8    2  0  0    3\n#&gt; Valiant               6    1  1  0    3\n#&gt; Duster 360            8    4  0  0    3\n#&gt; Merc 240D             4    2  1  0    4\n#&gt; Merc 230              4    2  1  0    4\n#&gt; Merc 280              6    4  1  0    4\n#&gt; Merc 280C             6    4  1  0    4\n#&gt; Merc 450SE            8    3  0  0    3\n#&gt; Merc 450SL            8    3  0  0    3\n#&gt; Merc 450SLC           8    3  0  0    3\n#&gt; Cadillac Fleetwood    8    4  0  0    3\n#&gt; Lincoln Continental   8    4  0  0    3\n#&gt; Chrysler Imperial     8    4  0  0    3\n#&gt; Fiat 128              4    1  1  1    4\n#&gt; Honda Civic           4    2  1  1    4\n#&gt; Toyota Corolla        4    1  1  1    4\n#&gt; Toyota Corona         4    1  1  0    3\n#&gt; Dodge Challenger      8    2  0  0    3\n#&gt; AMC Javelin           8    2  0  0    3\n#&gt; Camaro Z28            8    4  0  0    3\n#&gt; Pontiac Firebird      8    2  0  0    3\n#&gt; Fiat X1-9             4    1  1  1    4\n#&gt; Porsche 914-2         4    2  0  1    5\n#&gt; Lotus Europa          4    2  1  1    5\n#&gt; Ford Pantera L        8    4  0  1    5\n#&gt; Ferrari Dino          6    6  0  1    5\n#&gt; Maserati Bora         8    8  0  1    5\n#&gt; Volvo 142E            4    2  1  1    4\n\n有些函数会将多个参数同时传递给函数中的一个参数，如下例所示。此时c()生成的不是向量，而是tidy-select组合。\n\nmy_pivot_longer &lt;- function(.data, ...) {\n  .data %&gt;% tidyr::pivot_longer(c(...))\n}\n\nmtcars %&gt;% my_pivot_longer(starts_with(\"c\"), vs:carb)\n#&gt; # A tibble: 160 × 8\n#&gt;     mpg  disp    hp  drat    wt  qsec name  value\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1    21   160   110   3.9  2.62  16.5 cyl       6\n#&gt; 2    21   160   110   3.9  2.62  16.5 carb      4\n#&gt; 3    21   160   110   3.9  2.62  16.5 vs        0\n#&gt; 4    21   160   110   3.9  2.62  16.5 am        1\n#&gt; 5    21   160   110   3.9  2.62  16.5 gear      4\n#&gt; 6    21   160   110   3.9  2.88  17.0 cyl       6\n#&gt; # ℹ 154 more rows\n\n\n\nname pattern\n使用tidy eval框架提供的pronouns，可以直接使用参数。\n\nmy_mean &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise(mean = mean(.data[[var]]))\n}\n\nmy_mean(mtcars, \"cyl\")\n#&gt;     mean\n#&gt; 1 6.1875\n\n遗憾的是，这种方法只能处理单个参数的情况。\n\nmtcars %&gt;% dplyr::summarise(.data[c(\"cyl\", \"am\")])\n#&gt; Error in `dplyr::summarise()`:\n#&gt; ℹ In argument: `.data[c(\"cyl\", \"am\")]`.\n#&gt; Caused by error in `.data[c(\"cyl\", \"am\")]`:\n#&gt; ! `[` is not supported by the `.data` pronoun, use `[[` or $ instead.\n\n\n\nbridge pattern\n使用中间桥梁函数解析参数，如across()、transmute()等\n\nacross()\n\nmy_group_by &lt;- function(data, var) {\n  data %&gt;% dplyr::group_by(across({{ var }}))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb [9]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(across(c(...)))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"), vs:gear)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb, vs, am, gear [15]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\nmy_group_by &lt;- function(data, vars) {\n  data %&gt;% dplyr::group_by(across(all_of(vars)))\n}\n\nmtcars %&gt;% my_group_by(c(\"cyl\", \"am\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\n\n\ntransmute()\n\nmy_pivot_longer &lt;- function(data, ...) {\n  # Forward `...` in data-mask context with `transmute()`\n  # and save the inputs names\n  inputs &lt;- dplyr::transmute(data, ...)\n  names &lt;- names(inputs)\n\n  # Update the data with the inputs\n  data &lt;- dplyr::mutate(data, !!!inputs)\n\n  # Select the inputs by name with `all_of()`\n  tidyr::pivot_longer(data, cols = all_of(names))\n}\n\nmtcars %&gt;% my_pivot_longer(cyl, am = am * 100)\n#&gt; # A tibble: 64 × 11\n#&gt;     mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1  21     160   110  3.9   2.62  16.5     0     4     4 cyl       6\n#&gt; 2  21     160   110  3.9   2.62  16.5     0     4     4 am      100\n#&gt; 3  21     160   110  3.9   2.88  17.0     0     4     4 cyl       6\n#&gt; 4  21     160   110  3.9   2.88  17.0     0     4     4 am      100\n#&gt; 5  22.8   108    93  3.85  2.32  18.6     1     4     1 cyl       4\n#&gt; 6  22.8   108    93  3.85  2.32  18.6     1     4     1 am      100\n#&gt; # ℹ 58 more rows\n\n使用transmute()创建新的数据框，然后提取name，最后更新数据框。\n\n\nTransformation patterns\n对多个参数执行相同的操作，有下面两种类型：\n\nTransforming inputs with across()\n\nmy_mean &lt;- function(data, ...) {\n  data %&gt;% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE)))\n}\n\nmtcars %&gt;% my_mean(cyl, carb)\n#&gt;      cyl   carb\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(foo = cyl, bar = carb)\n#&gt;      foo    bar\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(starts_with(\"c\"), mpg:disp)\n#&gt;      cyl   carb      mpg     disp\n#&gt; 1 6.1875 2.8125 20.09062 230.7219\n\n\n\nTransforming inputs with if_all() and if_any()\n\nfilter_non_baseline &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::filter(if_all(c(...), ~ .x != min(.x, na.rm = TRUE)))\n}\n\nmtcars %&gt;% filter_non_baseline(vs, am, gear)\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
    "objectID": "Blog/| and & in R.html",
    "href": "Blog/| and & in R.html",
    "title": "R 中的 | 与 &",
    "section": "",
    "text": "`%||%` &lt;- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; [1] FALSE\n#&gt; [1] FALSE\nx_ok(1)\n#&gt; [1] TRUE\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE\n#&gt; [1] FALSE\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; logical(0)\n#&gt; logical(0)\nx_ok(1)\n#&gt; [1] TRUE\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE FALSE FALSE\n#&gt; [1] FALSE FALSE FALSE\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Books/Js4R/01 Overview.html",
    "href": "Books/Js4R/01 Overview.html",
    "title": "01 Overview",
    "section": "",
    "text": "将风马牛不相及的两种语言——R、Javascript 结合使用，目的是为了取长补短，发挥各自优势（实际上我只知道R，Javascript 却完全不懂，我只想单纯想用R写出web）。\n一个直白的原因是：R 想实现的功能可能在Javascript 中已经存在，我们没有必要重新发明轮子，为 R 打包一个调用 JavaScript 的API即可。例如rmapshaper包，提供了调用 JavaScript 对GeoJSON文件进行修改的API。\n\nlibrary(rmapshaper)\n\n# get data\ndata(states, package = \"geojsonio\")\n\nstates_json &lt;- geojsonio::geojson_json(\n  states,\n  geometry = \"polygon\",\n  group = \"group\"\n)\nstates_sp &lt;- geojsonio::geojson_sp(states_json)\n\n# print shape file size\nprint(object.size(states_sp), units = \"Mb\")\n#&gt; 0.4 Mb\n#&gt; 0.4 Mb\n\n# simplify with rmapshaper\nstates_sm &lt;- rmapshaper::ms_simplify(states_sp, keep = 0.05)\n\n# print reduced size\nprint(object.size(states_sm), units = \"Mb\")\n#&gt; 0.2 Mb\n\n另外一个原因是：JavaScript 可以做 R 不能做的事。例如下面的plotly包，生成一个可交互的图形。\n\nlibrary(plotly)\n\nplot_ly(diamonds, x = ~cut, color = ~clarity, width = \"100%\")\n\n\n\n\n\n最后一个原因：JavaScript 可以与 R 协同工作，改进我们交流的方式，例如shiny应用——显示一个等待框。\n\nlibrary(shiny)\nlibrary(waiter)\n\nui &lt;- fluidPage(\n  use_waiter(), # include dependencies\n  actionButton(\"show\", \"Show loading for 3 seconds\")\n)\n\nserver &lt;- function(input, output, session) {\n  # create a waiter\n  w &lt;- Waiter$new()\n\n  # on button click\n  observeEvent(input$show, {\n    w$show()\n    Sys.sleep(3)\n    w$hide()\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#rationale为什么结合r与javascript",
    "href": "Books/Js4R/01 Overview.html#rationale为什么结合r与javascript",
    "title": "01 Overview",
    "section": "",
    "text": "将风马牛不相及的两种语言——R、Javascript 结合使用，目的是为了取长补短，发挥各自优势（实际上我只知道R，Javascript 却完全不懂，我只想单纯想用R写出web）。\n一个直白的原因是：R 想实现的功能可能在Javascript 中已经存在，我们没有必要重新发明轮子，为 R 打包一个调用 JavaScript 的API即可。例如rmapshaper包，提供了调用 JavaScript 对GeoJSON文件进行修改的API。\n\nlibrary(rmapshaper)\n\n# get data\ndata(states, package = \"geojsonio\")\n\nstates_json &lt;- geojsonio::geojson_json(\n  states,\n  geometry = \"polygon\",\n  group = \"group\"\n)\nstates_sp &lt;- geojsonio::geojson_sp(states_json)\n\n# print shape file size\nprint(object.size(states_sp), units = \"Mb\")\n#&gt; 0.4 Mb\n#&gt; 0.4 Mb\n\n# simplify with rmapshaper\nstates_sm &lt;- rmapshaper::ms_simplify(states_sp, keep = 0.05)\n\n# print reduced size\nprint(object.size(states_sm), units = \"Mb\")\n#&gt; 0.2 Mb\n\n另外一个原因是：JavaScript 可以做 R 不能做的事。例如下面的plotly包，生成一个可交互的图形。\n\nlibrary(plotly)\n\nplot_ly(diamonds, x = ~cut, color = ~clarity, width = \"100%\")\n\n\n\n\n\n最后一个原因：JavaScript 可以与 R 协同工作，改进我们交流的方式，例如shiny应用——显示一个等待框。\n\nlibrary(shiny)\nlibrary(waiter)\n\nui &lt;- fluidPage(\n  use_waiter(), # include dependencies\n  actionButton(\"show\", \"Show loading for 3 seconds\")\n)\n\nserver &lt;- function(input, output, session) {\n  # create a waiter\n  w &lt;- Waiter$new()\n\n  # on button click\n  observeEvent(input$show, {\n    w$show()\n    Sys.sleep(3)\n    w$hide()\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#methods结合r与javascript的方法",
    "href": "Books/Js4R/01 Overview.html#methods结合r与javascript的方法",
    "title": "01 Overview",
    "section": "Methods(结合R与Javascript的方法)",
    "text": "Methods(结合R与Javascript的方法)\n上面示例，都结合了R与Javascript，但是它们的方法不同。\n\nV8\nV8 是一个基于Chrome的 JavaScript 引擎，它允许我们使用R语言调用JavaScript代码。这是rmapshaper包中调用JavaScript代码的基础。\n\nlibrary(V8)\n\nctx &lt;- v8()\n\nctx$eval(\"2 + 2\") # this is evaluated in JavaScript!\n#&gt; [1] \"4\"\n#&gt; [1] \"4\"\n\n\n\nhtmlwidgets\nhtmlwidgets 调用JavaScript库，生成可交互的图像。上面的plotly包就是基于htmlwidgets包，同时还有DT、highcharts、leaflet等。\n\n\nshiny\nshiny 框架允许创建web应用，使得前后端进行数据传输。",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#methods-amiss没有提及的方法",
    "href": "Books/Js4R/01 Overview.html#methods-amiss没有提及的方法",
    "title": "01 Overview",
    "section": "Methods Amiss(没有提及的方法)",
    "text": "Methods Amiss(没有提及的方法)\n除上面三种框架外，还有两种方法没有提及：\n\nreactR & vueR\nReactR 包，类似于htmlwidgets，但是它适用于 React 框架；而且，它不仅限于可视化输出，还提供了构建输入的功能，例如，下拉菜单等。reactable 包，类似于DT包，生成可交互的表格，但是它使用React框架。\n\nreactable::reactable(iris[1:5, ], showPagination = TRUE)\n\n\n\n\n\nvueR 包与reactR 类似，但是它使用Vue框架。\n\n\nr2d3\nr2d3 包，允许我们使用R语言调用D3 JavaScript库(d3.js)，生成图片，但它的底层逻辑与htmlwidgets完全不同。\n\n# 你需要创建一个 JavaScript 文件 chord.js\n# chord.js 代码见 https://rstudio.github.io/r2d3/articles/gallery/chord/\nlibrary(r2d3)\nr2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = \"chord.js\")",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html",
    "href": "Books/Js4R/00 Preface.html",
    "title": "00 Preface",
    "section": "",
    "text": "本书的主要内容是如何将Javascript与R有机结合，使得能在R中书写网页应用。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#引言",
    "href": "Books/Js4R/00 Preface.html#引言",
    "title": "00 Preface",
    "section": "引言",
    "text": "引言\n很多R语言使用者对shiny，rmarkdown等或多或少的熟悉，却不熟悉web核心技术——JavaScript，本书旨在通过揭示 JavaScript 在多大程度上能够极大地增强数据科学流水线的各个阶段，从分析到结果传达，来弥补这一缺陷。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#目录",
    "href": "Books/Js4R/00 Preface.html#目录",
    "title": "00 Preface",
    "section": "目录",
    "text": "目录",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html",
    "href": "Books/Js4R/02 Prerequisites.html",
    "title": "02 Prerequisites",
    "section": "",
    "text": "本章介绍一些后续会用到的必要知识：\n即：以shiny框架为基础，通过Json格式数据，沟通R与JavaScript，将这种沟通方式打包为R包，方便调用与测试。"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#构建r包",
    "href": "Books/Js4R/02 Prerequisites.html#构建r包",
    "title": "02 Prerequisites",
    "section": "构建R包",
    "text": "构建R包\n这里简单简绍构建R包的方法，具体可参考 R Packages\n\ninstall.packages(c(\"devtools\", \"usethis\"))\n\n\n创建R包\n使用Rstudio创建R包：File &gt; New Project &gt; New Directory &gt; R Package\n\n使用usethis创建R包，Rstudio使用相同的命令创建R包。\n\n# 在当前工作目录下创建名为test的R包，同时自动设置工作目录为test包路径\nusethis::create_package(\"test\")\n# getwd()\n\n\n\nMetadata\n每个R包都有DESCRIPTION文件，该文件包含包名、版本、作者、依赖等信息。例如下面是test包的默认DESCRIPTION文件：\nPackage: test\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R:\n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\n假如你创建了一个依赖stringr包的脚本string.R，那么你需要在DESCRIPTION文件中添加依赖项。如果有多个，使用,分割。\nImports:\n  stringr,\n  dplyr\n也可以使用usethis添加依赖项。\n\n# add stringr under Imports\nusethis::use_package(\"stringr\")\n\nSuggests与Imports类似，但不会强制安装。\n\n\nR code\nR 包有着严格的结构要求，R/目录只能用来存放以.R结尾的R文件。上面的string.R文件就是在R/目录下。\n\n\nDocumentation\nroxygen2包可以识别在R函数前添加#'开头的注释，自动生成使用?进行查询的函数说明文档。这些说明文档以.Rd结尾，存放在man/目录下。\n在注释中，可以使用一些roxygen2标签，如@param、@example、@importFrom、@export等。\n\n@param: 参数说明，参数类型，参数描述。\n@example: 函数使用示例。\n@importFrom: 导入R包，该包中的函数。\n@export: 导出函数，使得该函数可以被用户调用。\n\n\n#' Strings Length\n#'\n#' Returns the number of characters in strings.\n#'\n#' @param strings A vector of character strings.\n#'\n#' @example string_length(c(\"hello\", \"world\"))\n#'\n#' @importFrom stringr str_length\n#'\n#' @export\nstring_length &lt;- function(strings) {\n  str_length(strings) # namespace removed\n}\n\nroxygen2 包会收集函数名，生成NAMESPACE文件，该文件包含了被该包导入和导出的函数。例如将上面的code替换之前的string.R文件，然后使用devtools::document()命令，生成man/文件夹和NAMESPACE文件。\n\n\nInstalled files\n在inst/目录下，用来存放一些能够被用户使用system.file()获取的文件。在本书中，你会见到很多这种用法。\n\n# return path to `inst/dependency.js` in `myPackage`\npath &lt;- system.file(\"dependency.js\", package = \"myPackage\")\n\n\n\nBuild, load and install\n在使用devtools::document()生成说明文档后，可以使用devtools::install()进行本地安装。但在实际开发R包时，通常使用devtools::load_all()进行本地加载。下面是一个开发R包的惯用流程：\n\nWrite some code\nRun devtools::document() (if documentation tags have changed)\nRun devtools::load_all()\nRepeat"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#json",
    "href": "Books/Js4R/02 Prerequisites.html#json",
    "title": "02 Prerequisites",
    "section": "Json",
    "text": "Json\nJSON (JavaScript Object Notation) 是一种流行的数据交换格式。在R中，我们使用jsonlite包进行序列化与反序列化。\n\nSerialising\nJson数据格式类似R中的list，可以存放除dataframe外的任何数据。下面是一个简单示例，参数pretty控制输出格式是否有空格。\n\n# install.packages(\"jsonlite\")\nlibrary(jsonlite)\n\nlst &lt;- list(\n  a = 1,\n  b = list(\n    c = c(\"A\", \"B\")\n  ),\n  d = 1:5\n)\n\ntoJSON(lst, pretty = TRUE)\n#&gt; {\n#&gt;   \"a\": [1],\n#&gt;   \"b\": {\n#&gt;     \"c\": [\"A\", \"B\"]\n#&gt;   },\n#&gt;   \"d\": [1, 2, 3, 4, 5]\n#&gt; }\n\n仔细观察上面的R list对象和json结果，a = 1虽然是单个数字，但其在R中实际是长度为1的向量，所以json中表现为\"a\": [1]。\n\nx &lt;- 1\nlength(x)\n#&gt; [1] 1\nis.vector(x)\n#&gt; [1] TRUE\n\n可以使用参数auto_unbox = TRUE来自动去除长度为1的向量中的[]，并且转换为json中的特殊数据类型：integer、number、boolean等。\n\ntoJSON(lst, pretty = TRUE, auto_unbox = TRUE)\n#&gt; {\n#&gt;   \"a\": 1,\n#&gt;   \"b\": {\n#&gt;     \"c\": [\"A\", \"B\"]\n#&gt;   },\n#&gt;   \"d\": [1, 2, 3, 4, 5]\n#&gt; }\n\n要注意，如果你将a=1变为a=list(1)，那么toJSON(lst, pretty = TRUE, auto_unbox = TRUE)将返回\"a\": [1]，而不是\"a\": 1。\n\n\nTabular Data\n如果数据是dataframe，jsonlite会逐行将dataframe转换为json。\n\n# subset of built-in dataset\ndf &lt;- cars[1:2, ]\n\ntoJSON(df, pretty = TRUE)\n#&gt; [\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 2\n#&gt;   },\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 10\n#&gt;   }\n#&gt; ]\n\n上面的代码也可以使用下面的步骤实现：去除行名，按行生成list。\n\nrow.names(df) &lt;- NULL\ndf_list &lt;- apply(df, 1, as.list)\n\ntoJSON(df_list, pretty = TRUE, auto_unbox = TRUE)\n#&gt; [\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 2\n#&gt;   },\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 10\n#&gt;   }\n#&gt; ]\n\njsonlite在读取json时，会自动将这种格式的数据转换为dataframe。\n\nclass(df_list)\n#&gt; [1] \"list\"\njson &lt;- toJSON(df_list)\nfromJSON(json)\n#&gt;   speed dist\n#&gt; 1     4    2\n#&gt; 2     4   10"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#javascript",
    "href": "Books/Js4R/02 Prerequisites.html#javascript",
    "title": "02 Prerequisites",
    "section": "JavaScript",
    "text": "JavaScript\nJavaScript的简介请自查。\n\nVariable Declaration and Scope\n一个与R显著不同的地方是：Javascript需要使用var,let,const来声明变量。\n\nvar: 可以只声明一个变量但不赋值，后续可以进行赋值更新。\nconst: 声明一个常量，不能进行赋值更新。\nlet: 常用于在if,switch,for和while中，声明一个变量，不能进行赋值更新。\n\nvar y; // declare\ny = [1,2,3]; // define it as array\ny = 'string'; // change to character string\n\nconst x = 1; // declare constant\nx = 2; // error\n\nif(true){\n  let x = 1;\n  var y = 1;\n}\n\nconsole.log(x) // error x does not exist\nconsole.log(y) // works\n\n\nDocument Object Model\nhtml中的DOM结构会被JavaScript解析为document对象，通过document对象，JavaScript可以访问和修改HTML结构。例如下面通过getElementById方法获取id为content的p元素，并修改其内容。\n &lt;!–– index.html ––&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"content\"&gt;Trying JavaScript!&lt;/p&gt;\n  &lt;/body&gt;\n  &lt;script&gt;\n    var cnt = document.getElementById(\"content\");\n    cnt.innerText = \"The text has changed\";\n  &lt;/script&gt;\n&lt;/html&gt;\n同CSS一样，使用quarySelector选择器来选择元素时，#开头表示选择id，.开头表示选择class。\n &lt;!–– index.html ––&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"content\" class=\"stuff\"&gt;Trying JavaScript!&lt;/p&gt;\n  &lt;/body&gt;\n  &lt;script&gt;\n    // select by id\n    var x = document.getElementById(\"content\");\n    var y = document.querySelector(\"#content\");\n\n    console.log(x == y); // true\n\n    // select by class\n    var z = document.querySelector(\".stuff\");\n  &lt;/script&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#shiny",
    "href": "Books/Js4R/02 Prerequisites.html#shiny",
    "title": "02 Prerequisites",
    "section": "Shiny",
    "text": "Shiny\n静态文件指的是会被客户端下载的文件，如图片、css、js等。R包中的inst文件夹就是用来存放静态文件的，同样可以用来存放Shiny 应用的静态文件。\n有两种将静态文件引入到shiny中的方式：\n\n手动引入。\n使用htmltools包引入。\n\n\nServing Static Files\n使用addResourcePath()声明静态文件路径，参数prefix为URL中显示的路径名，directoryPath为静态文件路径。\n运行下面的shiny应用，可以通过files/script.js(127.0.0.1:3000/files/script.js)访问到script.js文件。\n\n# run from root of app (where app.R is located)\ndir.create(\"assets\")\nwriteLines(\"console.log('Hello JS!');\", con = \"assets/script.js\")\n\n\n# app.R\nlibrary(shiny)\n\n# serve the files\naddResourcePath(prefix = \"files\", directoryPath = \"assets\")\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"files/script.js\")\n  ),\n  h1(\"R and JavaScript\")\n)\n\nserver &lt;- function(input, output) {}\n\nshinyApp(ui, server)\nshinyApp(ui, server)\n\n上面的步骤使得客户端可以访问到静态文件。仍需要在代码中添加使用这些静态文件的相关代码。下面的例子会在浏览器终端console中打印”Hello JS!“。\n\n# app.R\nlibrary(shiny)\n\n# serve the files\naddResourcePath(prefix = \"files\", directoryPath = \"assets\")\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"files/script.js\")\n  ),\n  h1(\"R and JavaScript\")\n)\n\nserver &lt;- function(input, output) {}\n\nshinyApp(ui, server)\n\n\n\nHtmltools\nhtmltools中的htmlDependency()函数可以创建shiny依赖性并且只加载一次。参数src可以是一个URL(href)或者一个本地文件夹路径(file)，文件夹中存放script和stylesheet参数提供的文件。\n\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = c(file = \"path/to/directory\"),\n  script = \"script.js\",\n  stylesheet = \"styles.css\"\n)\n\n\n# dependency to the latest jQuery\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = c(\n    href = \"https://cdn.jsdelivr.net/gh/jquery/jquery/dist/\"\n  ),\n  script = \"jquery.min.js\"\n)\n\n同样地，实际最终地html中会生成如下代码：\n&lt;script\n  src=\"https://cdn.jsdelivr.net/gh/jquery/jquery/\n    dist/jquery.min.js\"&gt;\n&lt;/script&gt;\nhtmltools::htmlDependency也可以接受一个package参数，用来定位R包中地依赖文件。下面例子中最终的路径为myPackage/inst/assets/script.js。\n\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = \"assets\",\n  script = c(file = \"script.js\"),\n  package = \"myPackage\" # user package\n)\n\n创建好的依赖对象，只需放入到UI中即可使用。\n\nui &lt;- fluidPage(\n  dependency\n)"
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html",
    "href": "Books/Js4R/03 Introduction to Widgets.html",
    "title": "03 Introduction to Widgets",
    "section": "",
    "text": "本书此部分介绍如何通过htmlwidgets包整合R与JavaScript。htmlwidgets包起源于2012年的rCharts包，该包常用来数据可视化，但不限于此。在学习如何编写自己的第一个widget前，本章先介绍一些已经在CRAN上存在的widgets，通过它们，了解htmlwidgets包如何工作。",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#plotly-package",
    "href": "Books/Js4R/03 Introduction to Widgets.html#plotly-package",
    "title": "03 Introduction to Widgets",
    "section": "plotly package",
    "text": "plotly package\nplotly包提供了plotly.js在R中的API接口，可以绘制超40种，包括3D，统计，地理等方面的图形。\n有关plotly包的更多介绍见：Interactive web-based data visualization with R, plotly, and shiny。\n下面是一个可以交互的简单示例：\n\nlibrary(plotly)\n\nplot_ly(cars, x = ~speed, y = ~dist) %&gt;%\n  add_markers()\n\n\n\nplotly scatter plot\n\n\nplotly包也可以使用ggplotly()函数将ggplot2绘制的静态图进行转换（仅支持部分类型图）：\n\np &lt;- ggplot(diamonds, aes(x = log(carat), y = log(price))) +\n  geom_hex(bins = 100)\nggplotly(p)\n\n\n\nInteractive ggplot2 with plotly\n\n\nplotly包使用类似ggplot2包中的geom语法——add_*添加图层。\n\nplot_ly(mtcars, x = ~disp) %&gt;%\n  add_markers(y = ~mpg, text = rownames(mtcars)) %&gt;%\n  add_lines(y = ~ fitted(loess(mpg ~ disp)))\n\n\n\nMultiple layers with plotly",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#dt-package",
    "href": "Books/Js4R/03 Introduction to Widgets.html#dt-package",
    "title": "03 Introduction to Widgets",
    "section": "DT package",
    "text": "DT package\nDT package 可以根据data.frame创建交互表格。\n\nDT::datatable(cars)\n\n\n\nInteractive table with DT\n\n\nDT 创建的表格也十分常见地用在shiny中。\n\nlibrary(DT)\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(8, DTOutput(\"myTable\")),\n    column(\n      4,\n      h4(\"Indices of selected rows\"),\n      verbatimTextOutput(\"selected\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$myTable &lt;- renderDT({\n    datatable(mtcars)\n  })\n\n  output$selected &lt;- renderPrint({\n    input$myTable_rows_selected\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#crosstalk",
    "href": "Books/Js4R/03 Introduction to Widgets.html#crosstalk",
    "title": "03 Introduction to Widgets",
    "section": "Crosstalk",
    "text": "Crosstalk\ncrosstalk包允许多个htmlwidgets之间进行数据交流。下面是一个共享数据的图标与散点图的示例。更多支持的widgets见：Crosstalk.\n\nlibrary(DT)\nlibrary(plotly)\nlibrary(crosstalk)\n\nsd &lt;- SharedData$new(iris[, c(\"Sepal.Length\", \"Sepal.Width\")])\n\nbscols(\n  device = \"lg\",\n  datatable(sd, width = \"100%\"),\n  plot_ly(sd, x = ~Sepal.Length, y = ~Sepal.Width)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nDT and plotly with crosstalk",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html",
    "href": "Books/Js4R/04 Basics of Building Widgets.html",
    "title": "04 Basics of Building Widgets",
    "section": "",
    "text": "将某个JavaScript库整合到R中的第一步就是：学习这个JavaScript库。\n\n阅读库的简介，了解这个库的功能，输入，输出。\n阅读安装文档，了解这个库的依赖。\n以某个例子为切入点，深入了解将库整合到R中的难易程度。\n阅读API文档，准确把握API的使用。\n多使用库，实现对库API的精简与提升。",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#read-and-study",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#read-and-study",
    "title": "04 Basics of Building Widgets",
    "section": "",
    "text": "将某个JavaScript库整合到R中的第一步就是：学习这个JavaScript库。\n\n阅读库的简介，了解这个库的功能，输入，输出。\n阅读安装文档，了解这个库的依赖。\n以某个例子为切入点，深入了解将库整合到R中的难易程度。\n阅读API文档，准确把握API的使用。\n多使用库，实现对库API的精简与提升。",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#candidate-libraries",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#candidate-libraries",
    "title": "04 Basics of Building Widgets",
    "section": "Candidate Libraries",
    "text": "Candidate Libraries\n下面介绍一些htmlwidgets中常见的JavaScript库，并展示这些库在html中使用的共通点：\n\n引入js库\n声明一个展示图片的div。\njs获取图片的div位置，使用绘图结果替代div中的内容。\n\n\nPlotly.js\nplotly.js是plotlyR包的底层依赖库。其官方文档地址为：https://plotly.com/javascript 。下面是一个在html文本中简单使用的例子。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- div to hold visualisation --&gt;\n  &lt;div id=\"chart\" style=\"width:600px;height:400px;\"&gt;&lt;/div&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    el = document.getElementById('chart');\n    Plotly.newPlot(el, [{\n      x: [1, 2, 3, 4, 5],\n      y: [1, 2, 4, 8, 16]\n    }]\n    );\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\nHighchart.js\nhighchart.js 是另外一个常见的绘图库，但不是全部免费，其官网为：https://www.highcharts.com 。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://code.highcharts.com/highcharts.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- div to hold visualisation --&gt;\n  &lt;div id=\"chart\" style=\"width:100%;height:400px;\"&gt;&lt;/div&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    var myChart = Highcharts.chart('chart', {\n        xAxis: {\n            categories: ['Apples', 'Bananas', 'Oranges']\n        },\n        series: [{\n            name: 'Jane',\n            data: [1, 0, 4]\n        }, {\n            name: 'John',\n            data: [5, 7, 3]\n        }]\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nChart.js\nchart.js 以免费和便捷API出名，其官网为：https://www.chartjs.org 。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://cdn.jsdelivr.net/npm/chart.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- canvas to hold visualisation --&gt;\n  &lt;canvas id=\"chart\"&gt;&lt;/canvas&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    var el = document.getElementById('chart').getContext('2d');\n    var myChart = new Chart(el, {\n      type: 'bar',\n      data: {\n        labels: [\n          'Red', 'Blue', 'Yellow', 'Green',\n          'Purple', 'Orange'],\n        datasets: [{\n          label: '# of Votes',\n          data: [12, 19, 3, 5, 2, 3]\n        }]\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#plotly-chart",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#plotly-chart",
    "title": "04 Basics of Building Widgets",
    "section": "Plotly Chart",
    "text": "Plotly Chart\n\nPlotly = await require(\"@observablehq/plotly\")\n\n// 绘制图表\nPlotly.newPlot([{\n  x: [1, 2, 3, 4, 5],\n  y: [1, 2, 4, 8, 16]\n}]);"
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#how-it-works",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#how-it-works",
    "title": "04 Basics of Building Widgets",
    "section": "How it works",
    "text": "How it works\n\n创建一个html文件。\n在html文件中引入Chart.js库。\n创建一个html元素（例如div），用于绘制图表。\nR将绘图数据转换为能被绘图模块使用的JSON格式，并嵌入到html文件中。\n上述所有元素能在Rmarkdown，Shiny或其他环境中运行。\n\n\n\n\n\n\nflowchart LR\n    subgraph i1[R environment]\n        A[Data]\n        B[Chart options]\n    end\n    subgraph i2[HTML]\n        C[JSON]\n        D[Dependencies]\n        E[JavaScript]\n        F[HTML element]\n    end\n    A --&gt;C\n    B --&gt;C\n    C --&gt;E\n    D --&gt;E\n    E --&gt;F\n    style i1 fill:#FFF\n    style i2 fill:#FFF",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html",
    "href": "Books/Js4R/05 Your First Widget.html",
    "title": "05 Your First Widget",
    "section": "",
    "text": "通过R包的形式创建widget可以使事情变得简单一些，下面我们以一个playgroundR包例，创建一个widget。\n首先使用usethis::create_package()创建一个R包。\nusethis::create_package(\"playground\")\n使用htmlwidgets::scaffoldWidget()函数自动创建一个widget脚手架——“play”：生成play.R，play.js，play.yaml三个文件。你可以在一个包中使用该函数创建多个widget。\nplay.R脚本中定义了三个函数：\n\nplay()：widget的核心API。\nrender*()：在shiny服务器中处理widget的函数。\n*output()：在shinyUI界面处理widget的函数。\n\n.js脚本包含生成可视化结果的JavaScript函数。\nhtmlwidgets::scaffoldWidget(\"play\")\n生成R包说明文档并加载函数，此时已经可以初步使用“play”widget了（虽然此时只能显示文本信息）。\ndevtools::document()\ndevtools::load_all()\nplay(message = \"This is a widget!\")\n\n在Rstudio中，你可以点击“Viewer”中的，在浏览器中打开生成的网页，然后使用浏览器调试工具进行调试，十分方便后续开发。同样地，在vscode中，你可以使用htmlwidgets::saveWidget()函数将widget保存为HTML文件，然后在浏览器中进行调试。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#the-scaffold",
    "href": "Books/Js4R/05 Your First Widget.html#the-scaffold",
    "title": "05 Your First Widget",
    "section": "",
    "text": "通过R包的形式创建widget可以使事情变得简单一些，下面我们以一个playgroundR包例，创建一个widget。\n首先使用usethis::create_package()创建一个R包。\nusethis::create_package(\"playground\")\n使用htmlwidgets::scaffoldWidget()函数自动创建一个widget脚手架——“play”：生成play.R，play.js，play.yaml三个文件。你可以在一个包中使用该函数创建多个widget。\nplay.R脚本中定义了三个函数：\n\nplay()：widget的核心API。\nrender*()：在shiny服务器中处理widget的函数。\n*output()：在shinyUI界面处理widget的函数。\n\n.js脚本包含生成可视化结果的JavaScript函数。\nhtmlwidgets::scaffoldWidget(\"play\")\n生成R包说明文档并加载函数，此时已经可以初步使用“play”widget了（虽然此时只能显示文本信息）。\ndevtools::document()\ndevtools::load_all()\nplay(message = \"This is a widget!\")\n\n在Rstudio中，你可以点击“Viewer”中的，在浏览器中打开生成的网页，然后使用浏览器调试工具进行调试，十分方便后续开发。同样地，在vscode中，你可以使用htmlwidgets::saveWidget()函数将widget保存为HTML文件，然后在浏览器中进行调试。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#the-html-output",
    "href": "Books/Js4R/05 Your First Widget.html#the-html-output",
    "title": "05 Your First Widget",
    "section": "The HTML Output",
    "text": "The HTML Output\n下面是上面play(\"This is a widget!\")生成的html文件中body标签的内容。生成内容的逻辑同上一章的内容。\n&lt;div id=\"htmlwidget_container\"&gt;\n  &lt;div\n    id=\"htmlwidget-c21cca0e76e520b46fc7\"\n    style=\"width:960px;height:500px;\"\n    class=\"play html-widget\"&gt;\n    This is a widget!\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script\n  type=\"application/json\"\n  data-for=\"htmlwidget-c21cca0e76e520b46fc7\"&gt;\n  {\"x\":{\"message\":\"This is a widget!\"},\"evals\":[],\"jsHooks\":[]}\n&lt;/script&gt;\n上面的html源码中，div元素由play()函数创建，它的class属性与widget（play）相关，id属性由elementId参数指定，如果没有指定，则生成随机id。script中JSON数据的x与play()函数中的x参数一致。\n# specify the id\nplay(\"This is another widget\", elementId = \"myViz\")\n&lt;!-- div bears id specified in R --&gt;\n&lt;div id=\"myViz\"\n  style=\"width:960px;height:500px;\"\n  class=\"play html-widget\"&gt;\n  This is another widget\n&lt;/div&gt;\n仔细观察script，会发现它的data-for属性与elementId相关。\n&lt;script type=\"application/json\"\n  data-for=\"myViz\"&gt;\n  {\"x\":{\"message\":\"This is a widget!\"},\"evals\":[],\"jsHooks\":[]}\n&lt;/script&gt;",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#javascript-files",
    "href": "Books/Js4R/05 Your First Widget.html#javascript-files",
    "title": "05 Your First Widget",
    "section": "JavaScript Files",
    "text": "JavaScript Files\nhtmlwidgets::scaffoldWidget(\"play\")自动生成的play.js文件包含以下内容：\nHTMLWidgets.widget({\n\n  name: 'play',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // TODO: code to render the widget, e.g.\n        el.innerText = x.message;\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n结合play.R文件中的htmlwidgets::createWidget()内容，我们可以大致将htmlwidgets在创建和渲染的过程描述如下：\n\n\n\n\n\nflowchart LR\n  subgraph i1[R]\n    A[\"play(id)\"]\n  end\n  subgraph i2[HTML]\n    B[\"&lt;scipt data-for=id&gt;\"]\n    C[\"dependencies(play.js)\"]\n    D[JavaScript]\n    E[\"&lt;div class=play id=id&gt;\"]\n    B--&gt;|import|D\n    C--&gt;|use|D\n    D--&gt;|Generate viz|E\n  end\n  A--&gt;|id|B\n  A--&gt;|id and class|E\n  style i1 fill:#FFF\n  style i2 fill:#FFF\n\n\n\n\n\n\nfactory函数的返回值是两个函数resize和renderValue。前者用来动态调整结果框的大小，后者用来生成结果框，我们先关注renderValue函数。该函数使用参数x中的message值来替代html中的元素el.innerText，其中x.message是JSON格式的提取元素方式，类似R中list的x$message。\n你可以在play.js中添加如下代码，并重新加载函数，重新生成网页，然后使用浏览器调试工具查看结果。\n// el.innerText = x.message; 后续添加\nconsole.log(x);\nel.innerText = x.message;\n\n使用相同的方法，我们可以查看一下el对象的具体信息。\nconsole.log(el);\n\n可以发现，el对象就是play()函数同时创建的div元素。如果你熟悉JavaScript，你可以使用document.getElementById来获取el对象，同时修改元素的位置，颜色，大小等。\n// print the id of the element\nconsole.log(el.id);\nel.innerText = x.message;\n\n在play.js中使用的innerText只能替换文本，而innerHTML则可以替换任何HTML元素。将el.innerText = x.message;修改为el.innerHTML = x.message;，重新加载函数后运行play(\"&lt;h1&gt;Using HTML!&lt;/h1&gt;\")。生成下图：\n\n上面的例子使得play()函数更加灵活，但是使用\"&lt;h1&gt;Using HTML!&lt;/h1&gt;\"未免有些麻烦。好在shiny和htmltools提供了一些工具，使得创建HTML元素更加容易。\n\nhtml &lt;- shiny::h1(\"HTML tag\")\n\nclass(html)\n#&gt; [1] \"shiny.tag\"\n\n# returns string\nas.character(html)\n#&gt; [1] \"&lt;h1&gt;HTML tag&lt;/h1&gt;\"\n\n修改play()函数中对message的处理:\n# forward options using x\nx = list(\n  message = as.character(message)\n)\n重新加载函数后，就可以直接使用shiny或htmltools创建的HTML元素作为message了。\nplay(\n  shiny::h2(\"Chocolate is a colour\", style = \"color:chocolate;\")\n)\n\n综上，play()函数的内容会通过对象x传递到html中，并被JavaScript解析，然后替换同时由play()生成的div中的内容。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html",
    "href": "Books/Js4R/06 A Realistic Widget.html",
    "title": "06 A Realistic Widget",
    "section": "",
    "text": "本章我们创建一个名为peity的R包，它以peity.js为基础，创建内联图（类似小图标的东西）。\n具体工作原理是：先加载JavaScript库，然后$(\"#bar\").peity(\"bar\")将span标签中的数据转换成图表。",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#示例图表",
    "href": "Books/Js4R/06 A Realistic Widget.html#示例图表",
    "title": "06 A Realistic Widget",
    "section": "示例图表",
    "text": "示例图表\n以下是一个使用 peity 创建的简单条形图：\n\n5,3,9,6,5,9,7,3,5,2"
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#dependencies",
    "href": "Books/Js4R/06 A Realistic Widget.html#dependencies",
    "title": "06 A Realistic Widget",
    "section": "Dependencies",
    "text": "Dependencies\n创建好包和scaffold后，我们需要为包添加JavaScript依赖库。分别为上述两个依赖库peity.js和jQuery创建单独目录，并放置源文件，这样可以使包变得更加鲁棒。\ndir.create(\"./inst/htmlwidgets/jquery\")\ndir.create(\"./inst/htmlwidgets/peity\")\n\npeity &lt;- paste0(\n  \"https://raw.githubusercontent.com/benpickles/\",\n  \"peity/master/jquery.peity.min.js\"\n)\njquery &lt;- paste0(\n  \"https://code.jquery.com/jquery-3.5.1.min.js\"\n)\n\ndownload.file(\n  jquery, \"./inst/htmlwidgets/jquery/jquery.min.js\"\n)\ndownload.file(\n  peity, \"./inst/htmlwidgets/peity/jquery.peity.min.js\"\n)\n完成后，R包目录下的结构大致如下：\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   └── peity.R\n└── inst\n    └── htmlwidgets\n        ├── jquery\n        │   └── jquery.min.js\n        ├── peity\n        │   └── jquery.peity.min.js\n        ├── peity.js\n        └── peity.yaml\n配置依赖的文件为inst/htmlwidgets/peity.yaml文件，它的最开始几行是一个模板。\n# (uncomment to add a dependency)\n# dependencies:\n#  - name:\n#    version:\n#    src:\n#    script:\n#    stylesheet:\n正确添加依赖项：依赖性的顺序很重要，因为peity.js依赖jquery.js，所以它最后被添加。scr自动指向R包目录中的inst/文件夹。\ndependencies:\n  - name: jQuery\n    version: 3.5.1\n    src: htmlwidgets/jquery\n    script: jquery.min.js\n  - name: peity\n    version: 3.3.0\n    src: htmlwidgets/peity\n    script: jquery.peity.min.js\n加载peity包，使用peity(\"test\")函数生成测试网页，点击Rstudio中Viewer处的，使用浏览器工具，你可以看到在网页&lt;head&gt;处加载了jquery.min.js和jquery.peity.min.js\ndevtools::load_all()\nsystem.file(\"htmlwidgets/peity\", package = \"peity\")\n#&gt; \"/home/me/packages/peity/inst/htmlwidgets/peity\"\npeity(\"test\")",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#implementation",
    "href": "Books/Js4R/06 A Realistic Widget.html#implementation",
    "title": "06 A Realistic Widget",
    "section": "Implementation",
    "text": "Implementation\npeity.js的使用方法相对简单：piety函数应用到id = 'elementId'块，函数第一个参数使绘图类型，第二个参数是可选的JSON参数。\n$(\"#elementId\").peity(\"bar\", {\n  fill: [\"red\", \"green\", \"blue\"]\n})\npiety函数使用的数据不是由参数传入，而是由块提供：\n&lt;span id=\"elementId\"&gt;5,3,9,6&lt;/span&gt;\n那么，要想实现R调用JavaScript，我们需要R：\n\n创建一个有数据的块，传递块给peity函数。\n传递peity函数的参数。\n\n上一章节中，我们讲到playground包会自动创建一个块，并传递message给块，最终显示在网页上；peity包同样：\npeity(c(1,5,6,2))\n&lt;div\n  id=\"htmlwidget-495cf47d1a2a4a56c851\"\n  style=\"width:960px;height:500px;\"\n  class=\"play html-widget\"&gt;\n  1,5,6,2\n&lt;/div&gt;\n与message相同的传递方式，我们可以将数据和参数通过x对象进行传递。更新./R/peity.R文件中的函数，如下所示：\npeity &lt;- function(data, type = c(\"bar\", \"line\", \"pie\", \"donut\"),\n  ..., width = NULL, height = NULL, elementId = NULL) {\n\n  type &lt;- match.arg(type)\n\n  # forward options using x\n  x = list(\n    data = data,\n    type = type,\n    options = list(...)\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'peity',\n    x,\n    width = width,\n    height = height,\n    package = 'peity',\n    elementId = elementId\n  )\n}\n与message相同的处理方式，在./inst/htmlwidgets/peity.js文件中，添加对传入的x对象处理，运行js中的peity函数。\nrenderValue: function(x) {\n\n  // insert data\n  el.innerText = x.data;\n\n  // run peity\n  // $(\"#\" + el.id).peity(x.type, x.options)\n  $(el).peity(x.type, x.options)\n\n}\n重新加载函数，运行如下代码会显示\n\n  5,3,9,6,7\n\n\n  2, 1.8198638, 0.9582295, 0.2660590, 1.1532798\n\n\n  1/4\n\n\n  3,5\n\n\n\nlibrary(htmltools)\n\nbrowsable(\n  tagList(\n    peity(runif(5)),\n    peity(runif(5), type = \"line\"),\n    peity(\"1/4\", type = \"pie\", fill = c(\"#c6d9fd\", \"#4d89f9\")),\n    peity(c(3,5), type = \"donut\")\n  )\n)",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#html-element",
    "href": "Books/Js4R/06 A Realistic Widget.html#html-element",
    "title": "06 A Realistic Widget",
    "section": "HTML Element",
    "text": "HTML Element\npiety.js生成的图像用来插入到某行中，通常搭配&lt;span&gt;标签。如果你检查上例中html源码，会发现生成的图是被&lt;div&gt;标签包裹。\n\n为了实现被&lt;span&gt;标签包裹，我们需要在./R/piety.R中定义一个函数，将&lt;div&gt;标签替换为&lt;span&gt;标签，示例如下：\npeity_html &lt;- function(...){\n  htmltools::tags$span(...)\n}\n你可以重新加载函数，再次检查html源码中使用的标签。\n函数名peity_html是一种固定的格式——widgetName_html。该函数会被htmlwidgets自动搜索，如果有就使用函数中的标签，如果没有就使用默认的&lt;div&gt;。参数...为固定参数，用来传递id,class,style等不确定参数。你也可以写出如下具有固定参数的格式。\nmyWidget_html &lt;- function(..., class){\n  htmltools::tags$div(..., class = c(class, \"my-class\"))\n}\n重新运行下面的代码会生成\nWe can now 5,3,9,6,7 use peity 2, 1.8198638, 0.9582295, 0.2660590, 1.1532798 inline with text! 4,2\n\nbrowsable(\n  tagList(\n    p(\n      \"We can now\", peity(runif(5)),\n      \"use peity\", peity(runif(5), type = \"line\"),\n      \"inline with text!\",\n      peity(c(4,2), type = \"donut\")\n    )\n  )\n)",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html",
    "href": "Books/Js4R/07 The Full Monty.html",
    "title": "07 The Full Monty",
    "section": "",
    "text": "本章以gio.js库为基础，学习输入数据的处理方式。gio.js用来在三维地球图上，通过曲线绘制国家之间的联系。下面是该库的一个简单示例：",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#creating-package",
    "href": "Books/Js4R/07 The Full Monty.html#creating-package",
    "title": "07 The Full Monty",
    "section": "Creating Package",
    "text": "Creating Package\n同上一章一样：\n\n首先创建gioR包及scaffold：\n\nusethis::create_package(\"gio\")\nhtmlwidgets::scaffoldWidget(\"gio\")\n\n然后下载依赖JS库，修改inst/htmlwidgets/gio.yaml文件\n\n# create directories for JS dependencies\ndir.create(\"./inst/htmlwidgets/three\", recursive = TRUE)\ndir.create(\"./inst/htmlwidgets/gio\", recursive = TRUE)\n\n# download JS dependencies\nthree &lt;- paste0(\n  \"https://cdnjs.cloudflare.com/ajax/\",\n  \"libs/three.js/110/three.min.js\"\n)\ngio &lt;- paste0(\n  \"https://raw.githubusercontent.com/\",\n  \"syt123450/giojs/master/build/gio.min.js\"\n)\n\ndownload.file(three, \"./inst/htmlwidgets/three/three.min.js\")\ndownload.file(gio, \"./inst/htmlwidgets/gio/gio.min.js\")\ndependencies:\n  - name: three\n    version: 110\n    src: htmlwidgets/three\n    script: three.min.js\n  - name: gio\n    version: 2.0\n    src: htmlwidgets/gio\n    script: gio.min.js\n\n修改int/htmlwidgets/gio.js文件中的函数：因为gio.js直接使用widget创建的el对象，所以我们无需使用var container = document.getElementById(\"globe\")来获取el对象，而是直接使用el对象；同时需要的数据由x对象传入。\n\n// gio.js\nHTMLWidgets.widget({\n\n  name: 'gio',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // var container = document.getElementById(\"globe\");\n        var controller = new GIO.Controller(el);\n        controller.addData(x.data);\n        controller.init();\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n\n最后修改R/gio.R文件：上面的js需要输入对象x要有data属性，所以这里需要修改gio函数的参数和x的数据结构。\n\n# 注意：将message修改为data\ngio &lt;- function(data, width = NULL, height = NULL, elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n最后运行devtools::document();devtools::load_all()加载函数，使用gio(data)创建widget。",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#working-with-data",
    "href": "Books/Js4R/07 The Full Monty.html#working-with-data",
    "title": "07 The Full Monty",
    "section": "Working with Data",
    "text": "Working with Data\n现在只需要我们创建gio.js需要的json数据，即可创建gio.js的widget。阅读jio.js的文档，其要求的数据结构为：e——exporting country, i——importing country, v——value。\n[\n  {\n    \"e\": \"CN\",\n    \"i\": \"US\",\n    \"v\": 3300000\n  },\n  {\n    \"e\": \"CN\",\n    \"i\": \"RU\",\n    \"v\": 10000\n  }\n]\n我们使用R读取该JSON数据，会发现数据结构转为data.frame。\n\n# data.frame to test\narcs &lt;- jsonlite::fromJSON(\n  '[\n    {\n      \"e\": \"CN\",\n      \"i\": \"US\",\n      \"v\": 3300000\n    },\n    {\n      \"e\": \"CN\",\n      \"i\": \"RU\",\n      \"v\": 10000\n    }\n  ]'\n)\n\nprint(arcs)\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n\n当我们直接将arcs传入gio函数时，会发现只有一个空白的widget。使用console.log或查看HTML源码，会发现传入的数据结构和预期的不符。\n{\n  \"x\":{\n    \"data\":{\n      \"e\":[\"CN\",\"CN\"],\n      \"i\":[\"US\",\"RU\"],\n      \"v\":[3300000,10000]\n    }\n  },\n  \"evals\":[],\n  \"jsHooks\":[]\n}\n\n出现上述情况的原因是：row-wise的JSON被jsonlite::fromJSON自动转换为了dataframe，而htmlwidgets的createWidget函数会自动将dataframe转为column-wise的JSON，从而导致数据结构不符。\n\n# column-wise\njsonlite::toJSON(arcs, dataframe = \"columns\")\n#&gt; {\"e\":[\"CN\",\"CN\"],\"i\":[\"US\",\"RU\"],\"v\":[3300000,10000]}\n# row-wise\njsonlite::toJSON(arcs, dataframe = \"rows\")\n#&gt; [{\"e\":\"CN\",\"i\":\"US\",\"v\":3300000},{\"e\":\"CN\",\"i\":\"RU\",\"v\":10000}]",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#transforming-data",
    "href": "Books/Js4R/07 The Full Monty.html#transforming-data",
    "title": "07 The Full Monty",
    "section": "Transforming Data",
    "text": "Transforming Data\n下面介绍一些确保dataframe被row-wise的方法。\n\nUsing JavaScript\nhtmlwidgets JavaScript 库提供了dataframeToD3函数，将column-wise的JSON转为row-wise的JSON。\n// gio.js\nrenderValue: function(x) {\n\n  // long to wide\n  x.data = HTMLWidgets.dataframeToD3(x.data);\n\n  var controller = new GIO.Controller(el);\n  controller.addData(x.data);\n  controller.init();\n\n}\n\n\nModify Serialiser\n正如前面讲到的那样，我们可以设置htmlwidgets的createWidget函数自动将dataframe转为row-wise的JSON。\n下面是createWidget函数的底层逻辑，可以看到只要修改dataframe参数为\"rows\"即可。\nfunction (x, ..., dataframe = \"columns\", null = \"null\",\nna = \"null\", auto_unbox = TRUE, use_signif = TRUE,\n  digits = getOption(\"shiny.json.digits\", 16), force = TRUE,\n  POSIXt = \"ISO8601\", UTC = TRUE, rownames = FALSE,\n  keep_vec_names = TRUE, strict_atomic = TRUE)\n{\n  if (strict_atomic)\n      x &lt;- I(x)\n  jsonlite::toJSON(x, dataframe = dataframe, null = null, na = na,\n    auto_unbox = auto_unbox, digits = digits, force = force,\n    use_signif = use_signif, POSIXt = POSIXt, UTC = UTC,\n    rownames = rownames, keep_vec_names = keep_vec_names,\n    json_verbatim = TRUE, ...)\n}\nhtmlwidgets巧妙地利用了属性，可以将rows设置为x对象的TOJSON_ARGS属性，从而实现row-wise处理。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # serialise data.frames to wide (not long as default)\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n\nReplace Serialiser\n也可以为x对象添加TOJSON_FUNC属性值，直接替换serialiser函数。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # replace serialiser\n  attr(x, 'TOJSON_FUNC') &lt;- gio_serialiser\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n# serialiser\ngio_serialiser &lt;- function(x){\n  jsonify::to_json(x, unbox = TRUE)\n}\n\n\nModify the Data\n我们也可以直接修改data数据类型。\nx = list(\n  data = apply(data, 1, as.list)\n)\n\n\nPros and Cons\n上述每种方法都有其优缺点。最好的方法可能是仅在需要的地方修改默认序列化器（Modify Serialiser），这是本书其余部分使用的方法。完全替换序列化器（Replace Serialiser）应该是不必要的，只有在你非常熟悉序列化并真正看到需要它时才这样做。此外，HTMLWidgets 的序列化器扩展了 jsonlite, 允许转换 JavaScript 代码，这将在后面派上用场。在 JavaScript 中转换 data （Using JavaScript）有一个缺点，HTMLWidgets.dataframeToD3 不能应用于整个 x 对象，它只会作用于包含column-wise data (x.data) 的子集，这往往会导致代码笨拙，因为在不同地方使用该函数。",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#on-print-method",
    "href": "Books/Js4R/07 The Full Monty.html#on-print-method",
    "title": "07 The Full Monty",
    "section": "On Print Method",
    "text": "On Print Method\ngio.js提供了一些themes，我们可以为其x对象添加style`属性。\n// gio.js\nrenderValue: function(x) {\n\n  var controller = new GIO.Controller(el);\n  controller.addData(x.data);\n\n  controller.setStyle(x.style); // set style\n\n  controller.init();\n\n}\n此时，我们除了前面讲到的修改R/gio.R文件中函数的data对象，还可以直接为x对象添加style。使用print()我们可以清楚地看到数据结构。\n\ng &lt;- gio(arcs) # nothing renders\ng # visualisation renders\n\n\n\n\n\n\nprint(g$x)\n#&gt; $data\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n#&gt; \n#&gt; attr(,\"TOJSON_ARGS\")\n#&gt; attr(,\"TOJSON_ARGS\")$dataframe\n#&gt; [1] \"rows\"\n\n在R/gio.R文件中，创建添加属性的函数：\n#' @export\ngio_style &lt;- function(g, style = \"magic\"){\n  g$x$style &lt;- style\n  return(g)\n}\ng1 &lt;- gio(arcs)\ng2 &lt;- gio_style(g1, \"juicyCake\")\n\ng2\nhtmlwidgets系列包也可以被magrittr包支持，使用usethis::use_pipe()可以方便的实现管道符操作。\n\nlibrary(magrittr)\n\ngio(arcs) %&gt;%\n  gio_style(\"juicyCake\")",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#总结",
    "href": "Books/Js4R/00 Preface.html#总结",
    "title": "00 Preface",
    "section": "总结",
    "text": "总结\n\nmyWidget()函数中包含的htmlwidgets::createWidget会：\n\n自动创建element，默认是div，可以通过myWidget_html()函数进行修改。\n解析x对象的属性，如TOJSON_ARGS, TOJSON_FUNC，配置数据转换方式。\n\nhtmlwidgets::createWidget创建的x对象，可以直接在外部进行赋值。如gio$x$style &lt;- \"juicyCake\"。\nusethis::use_pipe()可以实现管道符操作。\n实现crosstalk支持的步骤：\n\nR脚本改造为能接收共享数据对象，获取数据的data，group，key信息，添加crosstalk依赖库。\n根据JS依赖库获取key信息，然后JS脚本使用sel_handle.set发送key信息\nJS脚本使用sel_handle.on监听事件发送改变后，获取key信息。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html",
    "href": "Books/Js4R/08 Advanced Topics.html",
    "title": "08 Advanced Topics",
    "section": "",
    "text": "本章在gio包的基础上，主要讨论下面几点：",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#shared-variables",
    "href": "Books/Js4R/08 Advanced Topics.html#shared-variables",
    "title": "08 Advanced Topics",
    "section": "Shared Variables",
    "text": "Shared Variables\n在此之前，需要先了解如何共享变量。以gio包为例，将controller变量定义在’factory函数内，renderValue函数外时，controller变量就可以被定义在factory中的函数访问，例如resize`函数。\nHTMLWidgets.widget({\n\n  name: 'gio',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n    var controller;\n\n    return {\n\n      renderValue: function(x) {\n\n        controller = new GIO.Controller(el); // declared outside\n\n        // add data\n        controller.addData(x.data);\n\n        // define style\n        controller.setStyle(x.style);\n\n        // render\n        controller.init();\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#sizing",
    "href": "Books/Js4R/08 Advanced Topics.html#sizing",
    "title": "08 Advanced Topics",
    "section": "Sizing",
    "text": "Sizing\nwidget的大小有两种调控方式：一种是绝对大小——px，另一种是相对（窗口）占比——x%，为了适配不同设备，通常宽度使用百分比设置，高度自适应。\ngio包中的gio()函数有width和height参数，分别调控widget的宽度和高度，其中width参数默认为400px，高度自适应。\narcs &lt;- jsonlite::fromJSON(\n  '[\n    {\n      \"e\": \"CN\",\n      \"i\": \"US\",\n      \"v\": 3300000\n    },\n    {\n      \"e\": \"CN\",\n      \"i\": \"RU\",\n      \"v\": 10000\n    }\n  ]'\n)\n\ngio(arcs)\n\n你可以试着改变宽度：\ngio(arcs, width = 500) # 500 pixels wide\ngio(arcs, width = \"100%\") # fits width\n这种调控方式适用于使用者，下面是针对开发者设置默认大小的方法。\n\nSizing Policy\n在htmlwidgets::createWidget()函数中，添加sizingPolicy参数，设置widget的默认大小和填充；参数值由htmlwidgets::sizingPolicy()函数配置。不同的配置可以适配不同的使用环境，如：RStudio viewer，Web browser，R markdown等。\n# create widget\nhtmlwidgets::createWidget(\n  name = 'gio',\n  x,\n  width = width,\n  height = height,\n  package = 'gio',\n  elementId = elementId,\n  sizingPolicy = htmlwidgets::sizingPolicy(\n    defaultWidth = \"100%\",\n    padding = 0,\n    browser.fill = TRUE\n  )\n)\n\n\n\nResizing\n前面我们讲过gio.js中的renderValue函数，当controller变量共享后，我们可以在resize函数中，对widget的大小进行重新渲染。gio.js由于底层自动调整widget大小，所以调整大小的函数resizeUpdate没有参数。\n...\nresize: function(width, height) {\n  controller.resizeUpdate();\n}\n...\n\n此处控制widget大小的函数由JS库决定，例如gio.js库是resizeUpdate，plotly.js库是relayout，highcharts.js库是setSize，charts.js库是resize。\n// plotly.js\nPlotly.relayout('chartid', {width: width, height: height});\n// highcharts.js\nchart.setSize(width, height);\n// charts.js\nchart.resize();",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#pre-render-hooks-and-security",
    "href": "Books/Js4R/08 Advanced Topics.html#pre-render-hooks-and-security",
    "title": "08 Advanced Topics",
    "section": "Pre Render Hooks and Security",
    "text": "Pre Render Hooks and Security\nhtmlwidgets::createWidget()函数通过参数preRenderHook接受一个函数，用来在生成widget前执行预处理。该函数接受一个完整的widget对象，输出一个修改过后的widget对象。这种操作不是很常见，但有时十分有用。\n例如，gio()函数的输入数据除了必要的e,v,i列外，如果存在其他列导致无法正确生成widget（实际无影响）时，我们需要确保输入数据的格式正确。\n# add a variable that should not be shared\narcs$secret_id &lt;- 1:2\n定义一个render_gio()函数，对输入数据进行格式控制。\n# preRenderHook function\nrender_gio &lt;- function(g){\n  # only keep relevant variables\n  g$x$data &lt;- g$x$data[,c(\"e\", \"v\", \"i\")]\n  return(g)\n}\n\n# create widget\nhtmlwidgets::createWidget(\n  name = 'gio',\n  x,\n  width = width,\n  height = height,\n  package = 'gio',\n  elementId = elementId,\n  sizingPolicy = htmlwidgets::sizingPolicy(\n    defaultWidth = \"100%\",\n    padding = 0,\n    browser.fill = TRUE\n  ),\n  preRenderHook = render_gio # pass renderer\n)",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#javascript-code",
    "href": "Books/Js4R/08 Advanced Topics.html#javascript-code",
    "title": "08 Advanced Topics",
    "section": "JavaScript Code",
    "text": "JavaScript Code\nJavaScript 代码无法通过JSON数据进行传递，需要特殊函数htmlwidgets::JS()进行转换。该函数为JavaScript代码字符串添加JS_EVAL属性，使其在被浏览器评估时可以被视作JavaScript代码。\n\n# serialised as string\njsonlite::toJSON(\"var x = 3;\")\n#&gt; [\"var x = 3;\"]\nhtmlwidgets::JS(\"var x = 3;\")\n#&gt; [1] \"var x = 3;\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"JS_EVAL\"",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#prepend-and-append-content",
    "href": "Books/Js4R/08 Advanced Topics.html#prepend-and-append-content",
    "title": "08 Advanced Topics",
    "section": "Prepend and Append Content",
    "text": "Prepend and Append Content\n使用htmlwidgets::prependContent()和htmlwidgets::appendContent()函数，可以在widget的前面或结尾添加额外的HTML内容（shiny，htmltools tags，a list of those）。注意：这两个函数在shiny中不起作用。\n#' @export\ngio_title &lt;- function(g, title){\n  title &lt;- htmltools::h3(title)\n  htmlwidgets::prependContent(g, title)\n}\ngio(arcs) %&gt;%\n  gio_title(\"Gio.js htmlwidget!\")",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#dependencies",
    "href": "Books/Js4R/08 Advanced Topics.html#dependencies",
    "title": "08 Advanced Topics",
    "section": "Dependencies",
    "text": "Dependencies\n前面讲到在inst/htmlwidgets/gio.yaml中添加JS库依赖，但这种方法适合添加通用型库，如果某些库仅是某些功能需要，则可以使用htmltools::htmlDependency()函数为widget对象单独添加依赖（dependencies）。如果全部使用第一种方法，会导致widget特别大，影响widget的加载速度，某些依赖库甚至可以只将某些使用的函数单独打包，减少加载时的大小。\n下面我们使用JavaScript性能监控器stats.js库，为gio包添加展示诸如渲染帧率 (FPS) 或渲染可视化所需的毫秒数等信息。\ndir.create(\"htmlwidgets/stats\")\nurl &lt;- paste0(\n  \"https://raw.githubusercontent.com/mrdoob/\",\n  \"stats.js/master/build/stats.min.js\"\n)\ndownload.file(url, destfile = \"htmlwidgets/stats/stats.min.js\")\ngio.js对stats.js的使用方法见这里。\n// enable stats\ncontroller.enableStats();\n参数dependencies由htmlwidgets::createWidget()生成，可以在函数内为widget添加该参数值，也可以直接在外部添加。\n\n通过system.file()获取stats.js的文件路径。\nhtmltools::htmlDependency()创建依赖项。\n将依赖项追加到widget对象的dependencies参数中。\n为x对象添加启动项。\n返回widget对象。\n\n#' @export\ngio_stats &lt;- function(g){\n\n  # create dependency\n  path &lt;- system.file(\"htmlwidgets/stats\", package = \"gio\")\n  dep &lt;- htmltools::htmlDependency(\n    name = \"stats\",\n    version = \"17\",\n    src = c(file = path),\n    script = \"stats.min.js\"\n  )\n\n  # append dependency to gio.js\n  g$dependencies &lt;- append(g$dependencies, list(dep))\n\n  # add stats variable\n  g$x$stats &lt;- TRUE\n\n  return(g)\n}\n同时修改inst/htmlwidgets/gio.js，将启动stat的代码添加到controller.init()之前。\n// gio.js\nif(x.stats)\n  controller.enableStats();\n\ncontroller.init();\n允许下面代码，可以看到左上角的实时信息。\n\n# create gio object\narcs %&gt;%\n  gio() %&gt;%\n  gio_stats()\n\n\n\n\n\n可以将上面两种方法类比于R包DESCRIPTION文件中的Imports和Suggests。",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#compatibility",
    "href": "Books/Js4R/08 Advanced Topics.html#compatibility",
    "title": "08 Advanced Topics",
    "section": "Compatibility",
    "text": "Compatibility\nhtmlwidgets::getDependency()函数可以提取widget R包中的依赖项，方便不同widget之间进行兼容，避免冲突。提取到的依赖项中第一个是htmlwidgets，最后一个是gio。\n\n# get dependencies of the gio package\nhtmlwidgets::getDependency(\"gio\")\n#&gt; [[1]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"htmlwidgets\"\n#&gt;  $ version   : chr \"1.6.4\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"www\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"htmlwidgets.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"htmlwidgets\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[2]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"three\"\n#&gt;  $ version   : chr \"110\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets/three\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"three.min.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[3]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"gio\"\n#&gt;  $ version   : chr \"2\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets/gio\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"gio.min.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[4]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"gio-binding\"\n#&gt;  $ version   : chr \"0.1.0\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"gio.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi FALSE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#unit-tests",
    "href": "Books/Js4R/08 Advanced Topics.html#unit-tests",
    "title": "08 Advanced Topics",
    "section": "Unit Tests",
    "text": "Unit Tests\n使用devtools::install()安装好gio包后，可以使用testthat包进行单元测试。\nlibrary(gio)\nlibrary(testthat)\n\ntest_that(\"gio has correct data\", {\n  g &lt;- gio(arcs)\n\n  # internally stored as data.frame\n  expect_is(g$x$data, \"data.frame\")\n\n  # gio does not work without data\n  expect_error(gio())\n})",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#performances",
    "href": "Books/Js4R/08 Advanced Topics.html#performances",
    "title": "08 Advanced Topics",
    "section": "Performances",
    "text": "Performances\n使用widget R包时，数据的传输过程为：\n\n加载到R中\nR将数据转换为JOSN格式\nJSON数据嵌入到HTML中\nJS解析JSON数据\n\n当数据较小时，不会影响浏览器的响应速度，但是当数据较大时，会拖慢浏览器的响应速度。可以使用额外的技术加快数据加载过程。例如下面的AJAX技术。\n# this would placed in the shiny UI\nload_json_from_ui &lt;- function(path_to_json){\n  script &lt;- paste0(\"\n    $.ajax({\n        url: '\", path_to_json, \"',\n        dataType: 'json',\n        async: true,\n        success: function(data){\n          console.log(data);\n          window.globalData = data;\n        }\n      });\"\n    )\n  shiny::tags$script(\n    script\n  )\n}",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html",
    "href": "Books/Js4R/09 Linking Widgets.html",
    "title": "09 Linking Widgets",
    "section": "",
    "text": "crosstalk包可以实现widget包之间数据共享，从而进行联动。例如选择图中的点，表格自动过滤出选择的点的相关数据。更多关于crosstalk见官网。",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-examples",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-examples",
    "title": "09 Linking Widgets",
    "section": "Crosstalk Examples",
    "text": "Crosstalk Examples\nR包plotly和DT支持crosstalk，可以创建一个共享数据的散点图与表格，表格中的数据根据选择的点自动过滤显示。共享数据由crosstalk::SharedData()创建，是一个R6类对象。下面的bscols()函数用来布局排列两个widget。\n\nlibrary(DT)\nlibrary(plotly)\nlibrary(crosstalk)\n\nshared &lt;- SharedData$new(cars)\n\nbscols(\n  plot_ly(shared, x = ~speed, y = ~dist),\n  datatable(shared, width = \"100%\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在shiny中使用crosstalk也十分方便，因为它可以接受reactive表达式创建共享数据。\nlibrary(DT)\nlibrary(shiny)\nlibrary(plotly)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  selectInput(\n    \"specie\", \"Specie\",\n    choices = c(\"setosa\", \"versicolor\", \"virginica\")\n  ),\n  fluidRow(\n    column(6, DTOutput(\"table\")),\n    column(6, plotlyOutput(\"plot\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  reactive_data &lt;- reactive({\n    iris[iris$Species == input$specie, ]\n  })\n\n  sd &lt;- SharedData$new(reactive_data)\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n\n  output$plot &lt;- renderPlotly({\n    plot_ly(sd, x = ~Sepal.Length, y = ~Sepal.Width)\n  })\n}\n\nshinyApp(ui, server)\nSharedData对象的data方法有参数withSelection，当为TRUE时，数据会添加一列selected_，值为TRUE或FALSE，表示该行是否被选中。\nlibrary(DT)\nlibrary(shiny)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(4, uiOutput(\"text\")),\n    column(8, DTOutput(\"table\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  sd &lt;- SharedData$new(cars)\n\n  output$text &lt;- renderUI({\n    # get selected rows\n    n_selected &lt;- sd$data(withSelection = TRUE) %&gt;%\n      dplyr::filter(selected_ == TRUE) %&gt;%\n      nrow()\n\n    h3(n_selected, \"selected items\")\n  })\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n}\n\nshinyApp(ui, server)\n\nSharedData对象也有selection方法，可以主动过滤选中的行。\nlibrary(DT)\nlibrary(shiny)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(4, actionButton(\"random\", \"Select a random row\")),\n    column(8, DTOutput(\"table\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  sd &lt;- SharedData$new(cars)\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n\n  selected &lt;- c()\n  observeEvent(input$random, {\n    smp &lt;- c(1:50)[!1:50 %in% selected]\n    selected &lt;&lt;- append(selected, sample(smp, 1))\n    sd$selection(selected)\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-requirements",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-requirements",
    "title": "09 Linking Widgets",
    "section": "Crosstalk Requirements",
    "text": "Crosstalk Requirements\ncrosstalk包适用于长数据格式，即每行是一个特征，数据的交互是对行进行筛选。直白地讲，它支持散点图似的特征数据，不支持直方图似的总结数据。",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#how-it-works",
    "href": "Books/Js4R/09 Linking Widgets.html#how-it-works",
    "title": "09 Linking Widgets",
    "section": "How it Works",
    "text": "How it Works\ncrosstalk包实现widgets之间数据共享的底层逻辑是JavaScript。事实上，无论在Rstudio的Viewer中，shiny中，还是Rmarkdown中，crosstalk包都可以适用。\n\n\n\n\n\nflowchart LR\n    subgraph i1[R]\n        direction LR\n        A[DataFrame]\n        B[Shared Dataset]\n        A --&gt;B\n    end\n    subgraph i2[JavaScript]\n        direction LR\n        C[Widget1]\n        D[Widget2]\n        C &lt;--&gt; D\n    end\n    i1 --&gt;i2\n    style i1 fill:#FFF\n    style i2 fill:#FFF\n\n\n\n\n\n\n\nKeys\nSharedData$new()在创建共享数据时，会为数据中的每一行添加键（key）。如果dataframe有行名，使用行名作为键，否则自动创建行数索引作为键。你可以将创建过程想象为添加了key列，但实际上这一列并不存在。key可以重复。\n\nsd_cars &lt;- SharedData$new(cars[1:2, ])\n\n\n共享数据中的key你可以使用key方法获取，也可以在创建时指定key。\n\nsd_cars$key()\n#&gt; [1] \"1\" \"2\"\n\n\n# assign keys\ndf &lt;- data.frame(x = runif(5))\nsd &lt;- SharedData$new(df, key = letters[1:5])\nsd$key()\n#&gt; [1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\nCommunication Lines\n在某种意义上，虽然crosstalk建立了通信线路来传输键值，但各自开发的组件必须处理发送到其他组件的键值以及如何处理接收到的键值（这些键值是在其他组件中被选择或过滤的）。即，有两种这样的通信线路：一种用于筛选要显示的数据点的行键值，另一种用于选择（crosstalk称为“链接刷选”）以突出显示特定数据点（使其他数据点淡出）。\n在JavaScript中，一个组件会接收所选和过滤的数据点的键值，并且当观察到过滤或选择时，必须将这些选定或过滤的键值“发送”给其他组件。因此，crosstalk可以实现在多个组件之间共享数据并实现交互式可视化分析的功能。\n\n\nGroups\nSharedData$new()在创建共享数据时，会给数据添加group属性，用来共享key。\n\n下例中，虽然创建了两个SharedData对象，但它们都共享了同一组key。\n\nshared_cars &lt;- SharedData$new(mtcars, group = \"cars\")\nshared_cars_head &lt;- SharedData$new(head(mtcars), group = \"cars\")",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-with-gio",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-with-gio",
    "title": "09 Linking Widgets",
    "section": "Crosstalk with Gio",
    "text": "Crosstalk with Gio\n考虑到gio.js使用的数据格式略有不同：每一行是一条边，整个数据是一个网络，前端更新某个节点时，会带出不同的相连节点，也即选中某个节点实际会返回多行值。我们需要提醒使用者：创建共享数据时，指定数据中的e列或i列作为key，使用其他列作为key也可以，但是会增加额外的步骤，使机制更加复杂。\n\n#  keys = target\nshared_arcs &lt;- crosstalk::SharedData$new(arcs, key = arcs$e)\n# keys = source\nshared_arcs &lt;- crosstalk::SharedData$new(arcs, key = arcs$i)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#r-code",
    "href": "Books/Js4R/09 Linking Widgets.html#r-code",
    "title": "09 Linking Widgets",
    "section": "R code",
    "text": "R code\n为了适配crosstalk，R/gio.R文件中的函数gio()需要修改为能使用由crosstalk::SharedData$new()创建的共享数据对象。该对象是R6类，有三个属性，可以用三个函数分别提取属性内容。\n\norigData：原始数据\ngroupName：所属组\nkey：分配给每一行的key\n\n\nclass(shared_arcs)\n#&gt; [1] \"SharedData\" \"R6\"\n\n# original data\nshared_arcs$origData()\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n# groupName\nshared_arcs$groupName()\n#&gt; [1] \"SharedDataaa3d2a04\"\n# keys\nshared_arcs$key()\n#&gt; [1] \"US\" \"RU\"\n\n每个构件都必须使用origData和groupName方法，key方法可能不适用于每个构件，但如果可视化库包含 key/id 系统，它将非常有用。gio.js没有这样的系统，所以我们不使用key方法。group的信息需要传递给x对象，以便在需要时可以被JavaScript端访问；同时还需要用crosstalkLibs获取crosstalk所需的JavaScript依赖库。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # defaults to NULL\n  group &lt;- NULL\n  deps &lt;- NULL\n\n  # uses crosstalk\n  if (crosstalk::is.SharedData(data)) {\n    group &lt;- data$groupName()\n    data &lt;- data$origData()\n    deps &lt;- crosstalk::crosstalkLibs()\n  }\n\n  # forward options using x\n  x = list(\n    data = data,\n    style = \"default\",\n    crosstalk = list(group = group) # pass group\n  )\n\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId,\n    sizingPolicy = htmlwidgets::sizingPolicy(\n      padding = 0,\n      browser.fill = TRUE,\n      defaultWidth = \"100%\"\n    ),\n    preRenderHook = render_gio,\n    # add crosstalk dependency\n    dependencies = deps\n  )\n}",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#javascript-code",
    "href": "Books/Js4R/09 Linking Widgets.html#javascript-code",
    "title": "09 Linking Widgets",
    "section": "JavaScript Code",
    "text": "JavaScript Code\ninst/htmlwidgets/gio.js中需要在factory函数中添加key的选择处理器。\nvar sel_handle = new crosstalk.SelectionHandle();\n接着在renderValue函数中为处理器添加group信息（上述R code处理后结果）。\n一定要注意的是：我们不仅需要将key信息发送到其他组件中，还需要接收其他组件传入的key信息。\n\nSend Selected Keys\n为了将选择的key信息发送出去，我们首先要获取被客户选择的key信息（callback）。获取方式因不同的JS库而不同，JS库通常都会提供callback函数或者触发事件来获取key信息。gio.js获取key信息方式如下，通过定义callback函数，可以返回：选中的国家及其关联的国家。\n// define callback function\nfunction callback (selectedCountry, relatedCountries) {\n  console.log(selectedCountry);\n  // console.log(relatedCountries);\n}\n\n// use callback function\ncontroller.onCountryPicked(callback);\n{name: \"LIBYA\", lat: 25, lon: 17, center: n, ISOCode: \"LY\"}\n因为我们要将选中的key信息发送给其他组件，所以需要修改callback函数；考虑到crosstalk创建的共享数据使用的key最好是ISOcode，所以直接返回JSON对象的ISOcode字段。注意sel_handle.set需要的输入是null或array，selectedCountry.ISOCode必须用[]包裹起来。\nfunction callback (selectedCountry) {\n  sel_handle.set([selectedCountry.ISOCode]);\n}\n\ncontroller.onCountryPicked(callback);\n\n\nSet Selected Keys\n除了要发送key信息，组件也需要接收其他组件发送的key信息。使用sel_handle.on()来监听其他组件发送的key信息。\n// placed in factory function\nsel_handle.on(\"change\", function(e) {\n  console.log(e);\n});\n返回的e包含下面信息：\n\noldValue： 之前选中的key\nsender：变更key的组件\nvalue： 当前选中的key\n\n{\n  oldValue: [],\n  sender: n {\n    _eventRelay: e,\n    _emitter: t,\n    _group: \"SharedDatac7682f87\",\n    _var: r,\n    _varOnChangeSub: \"sub1\",\n    …\n  },\n  value: [\"AE\"]\n}\n当监听到变更时，可以将变更的key传递给controller.switchCountry()进行变更处理。通常需要清除之前的key，但gio.js始终都需要一个key，所以此处不作处理。\n// placed in factory function\nsel_handle.on(\"change\", function(e) {\n\n  // selection comes from another widget\n  if (e.sender !== sel_handle) {\n    // clear the selection\n    // not possible with gio.js\n  }\n  controller.switchCountry(e.value[0]);\n});",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#using-crosstalk-with-gio",
    "href": "Books/Js4R/09 Linking Widgets.html#using-crosstalk-with-gio",
    "title": "09 Linking Widgets",
    "section": "Using Crosstalk with Gio",
    "text": "Using Crosstalk with Gio\n现在，gio包已经支持crosstalk了，下面是两个例子。\n\nlibrary(DT)\nlibrary(gio)\nlibrary(crosstalk)\n\n# url &lt;- paste0(\n#   \"https://raw.githubusercontent.com/JohnCoene/\",\n#   \"javascript-for-r/master/data/countries.json\"\n# )\nurl &lt;- \"countries.json\"\narcs &lt;- jsonlite::fromJSON(url)\n\n# Wrap data frame in SharedData\n# key is importing country\nsd &lt;- SharedData$new(arcs, key = arcs$i)\n\nbscols(\n  gio(sd),\n  datatable(sd, width = \"100%\", selection = \"single\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用group参数，将数据中的边与节点进行关联。\n\n\nlibrary(gio)\nlibrary(plotly)\nlibrary(crosstalk)\n\n# url &lt;- paste0(\n#   \"https://raw.githubusercontent.com/JohnCoene/\",\n#   \"javascript-for-r/master/data/countries.json\"\n# )\nurl &lt;- \"countries.json\"\narcs &lt;- jsonlite::fromJSON(url)\n\n# Wrap data frame in SharedData\nedges_sd &lt;- SharedData$new(\n  arcs,\n  key = arcs$i, group = \"sharedGroup\"\n)\n\n# create nodes\niso2c &lt;- unique(arcs$i)\nnodes &lt;- data.frame(\n  country = iso2c,\n  y = rnorm(length(iso2c))\n)\nnodes_sd &lt;- SharedData$new(\n  nodes,\n  key = nodes$country,\n  group = \"sharedGroup\"\n)\n\nbscols(\n  plot_ly(data = nodes_sd, type = \"bar\", x = ~country, y = ~y) %&gt;%\n    config(displayModeBar = FALSE),\n  gio(edges_sd)\n)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html",
    "href": "Books/Js4R/10 Final Revisions.html",
    "title": "10 Final Revisions",
    "section": "",
    "text": "本章我们将完善gio包中面向使用者的API。",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#htmlwidgets-and-data",
    "href": "Books/Js4R/10 Final Revisions.html#htmlwidgets-and-data",
    "title": "10 Final Revisions",
    "section": "Htmlwidgets and Data",
    "text": "Htmlwidgets and Data\n仔细观察前面R/gio.R的gio函数，我们会发现：如果面向使用者，gio函数的‘要求’过于严格了，必须每一行是一条边，而且有三列，列名必须是e，i，v。与编写其他R包类型，我们需要优化gio函数参数，使其更加鲁棒。一种方法是使用类似ggplot2::aes()函数的非标准性评估，如下示例。\ngio &lt;- function(data, source, target, value, ...,\n  width = NULL, height = NULL, elementId = NULL) {\n\n  # defaults to NULL\n  group &lt;- NULL\n\n  if (crosstalk::is.SharedData(data)) {\n    group &lt;- data$groupName()\n    data &lt;- data$origData()\n  }\n\n  # non-standard evaluation\n  data &lt;- dplyr::select(\n    data,\n    i = {{ source }},\n    e = {{ target }},\n    v = {{ value }}\n  )\n\n  # forward options using x\n  x = list(\n    configs = list(...),\n    data = data,\n    style = \"default\",\n    crosstalk = list(group = group)\n  )\n\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId,\n    sizingPolicy = htmlwidgets::sizingPolicy(\n      padding = 0,\n      browser.fill = TRUE,\n      defaultWidth = \"100%\"\n    ),\n    preRenderHook = render_gio,\n    dependencies = crosstalk::crosstalkLibs()\n  )\n}\n改造过的函数使用起来会更加上手：参数名含义直接明了，第一个参数提供数据，后面三个参数提供对应列。\n# mock up data\ncountries &lt;- c(\"US\", \"BE\", \"FR\", \"DE\")\ndf &lt;- data.frame(\n  from = countries,\n  to = rev(countries),\n  traded = runif(4)\n)\n\n# use gio\ngio(df, source = from, target = to, value = traded)",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#plethora-of-options",
    "href": "Books/Js4R/10 Final Revisions.html#plethora-of-options",
    "title": "10 Final Revisions",
    "section": "Plethora of Options",
    "text": "Plethora of Options\ngio.js有许多配置项参数，如：\nvar configs = {\n  control: {\n    stats: false,\n    disableUnmentioned: false,\n    lightenMentioned: false,\n    inOnly: false,\n    outOnly: false,\n    initCountry: \"CN\",\n    halo: true\n  },\n  color: {\n    surface: 0xFFFFFF,\n    selected: null,\n    in: 0x154492,\n    out: 0xDD380C,\n    halo: 0xFFFFFF,\n    background: null\n  },\n  brightness: {\n    ocean: 0.5,\n    mentioned: 0.5,\n    related: 0.5\n  }\n}\n\ncontroller = new Gio.controller(el, configs);\n不仅gio.js，JS库通常都会有丰富的配置项参数，我们不可能一一通过具体参数呈现，此时可以考虑...；如上例中的额外参数...，以list的格式传递给了x对象。\n在inst/htmlwidgets/gio.js中，可以将解析到的参数配置传递给controller。\n// use x.configs\ncontroller = new GIO.controller(el, x.configs);\n\ngio(\n  df, from, to, traded,\n  control = list(initCountry = \"US\"),\n  color = list(selected = \"#ff4d4d\")\n)",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#interface-design",
    "href": "Books/Js4R/10 Final Revisions.html#interface-design",
    "title": "10 Final Revisions",
    "section": "Interface Design",
    "text": "Interface Design\n\n始终记住你为客户开发的使用界面。\n你可以额外配置底层JS依赖库的选项，使其更加适配自己的风格。\n学习借鉴其他优秀R包的API风格，但也不要奉为金科玉律。",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#exercises",
    "href": "Books/Js4R/10 Final Revisions.html#exercises",
    "title": "10 Final Revisions",
    "section": "Exercises",
    "text": "Exercises\n学习下面的js库，练习创建一个简单的可视化应用。\n\nchart.js\ncytoscape.js\nToast UI charts\namcharts",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Blog/相关性计算.html",
    "href": "Blog/相关性计算.html",
    "title": "相关性计算",
    "section": "",
    "text": "近日，就相关性及其显著性的计算发生了一些讨论，现记录总结如下。"
  },
  {
    "objectID": "Blog/相关性计算.html#计算相关性及显著性",
    "href": "Blog/相关性计算.html#计算相关性及显著性",
    "title": "相关性计算",
    "section": "计算相关性及显著性",
    "text": "计算相关性及显著性\n共分为四步：\n\nstats::cor()计算相关性r。\n计算自由度n。\n构建正态分布统计量t。\n计算相关性显著性p。\n\n# x is matrix\n# 代码源于 psych::corr.test\nr &lt;- cor(x, use = use, method = method)\nn &lt;- t(!is.na(x)) %*% (!is.na(x))\nt &lt;- (r * sqrt(n - 2)) / sqrt(1 - r^2)\np &lt;- -2 * expm1(pt(abs(t), (n - 2), log.p = TRUE))\nse &lt;- sqrt((1 - r * r) / (n - 2))"
  },
  {
    "objectID": "Blog/相关性计算.html#cor函数参数use",
    "href": "Blog/相关性计算.html#cor函数参数use",
    "title": "相关性计算",
    "section": "cor函数参数use",
    "text": "cor函数参数use\n在上面四个步骤中，use参数往往会被忽略，但是它及其重要。use参数用来处理输入数据中的NA值，是大型数据处理时的主要限速步骤。\nuse参数的取值有：\n\n\"everything\": 忽略NA值，数据中的NA值导致相关性为NA值。\n\"all.obs\": 数据中有NA值时报错，只计算有完整数据对之间的相关性。\n\"complete.obs\": 允许数据中有NA值，计算前会整体地删除有NA值的行，删除后无法计算相关性时报错。\n\"na.or.complete\": 允许数据中有NA值，计算前会整体地删除有NA值的行，删除后无法计算相关性时输出NA值。\n\"pairwise.complete.obs\": 允许数据中有NA值，计算前会按变量单独地删除有NA值的行，删除后无法计算相关性时输出NA值。\n\n\nx &lt;- c(1, 2, NA, NA, NA)\ny &lt;- c(NA, 2, 5, 6, 6)\nz &lt;- c(NA, NA, 4, 7, 8)\n\ndat &lt;- data.frame(x, y, z)\n\ncor(dat, use = \"everything\")\n#&gt;    x  y  z\n#&gt; x  1 NA NA\n#&gt; y NA  1 NA\n#&gt; z NA NA  1\ncor(dat, use = \"all.obs\")\n#&gt; Error in cor(dat, use = \"all.obs\"): missing observations in cov/cor\ncor(dat, use = \"complete.obs\")\n#&gt; Error in cor(dat, use = \"complete.obs\"): no complete element pairs\ncor(dat, use = \"na.or.complete\")\n#&gt;    x  y  z\n#&gt; x NA NA NA\n#&gt; y NA NA NA\n#&gt; z NA NA NA\ncor(dat, use = \"pairwise.complete.obs\")\n#&gt;    x         y         z\n#&gt; x  1        NA        NA\n#&gt; y NA 1.0000000 0.9707253\n#&gt; z NA 0.9707253 1.0000000"
  },
  {
    "objectID": "Blog/相关性计算.html#显著性计算",
    "href": "Blog/相关性计算.html#显著性计算",
    "title": "相关性计算",
    "section": "显著性计算",
    "text": "显著性计算\n显著性的计算基于pt函数，该函数依据数据构建的统计量和自由度，计算该数据点出现的概率。上面的代码使用了对数化操作，能够提高计算的精度。\n考虑到use = \"pairwise\"时，每对相关性数据的自由度会不同，所以上面的代码采取了矩阵的计算方法。生成每对相关性数据的自由度和统计量。\n虽然当use = \"everything\"时，每对数据点之间自由度相同，可以使用标量进行计算，但是实际上矩阵 * 标量 = 矩阵，矩阵 * 矩阵 = 矩阵，并不会造成计算浪费。"
  },
  {
    "objectID": "Blog/相关性计算.html#测试",
    "href": "Blog/相关性计算.html#测试",
    "title": "相关性计算",
    "section": "测试",
    "text": "测试\n\n# 生成一个100行，10000列的随机矩阵，用来测试相关性\nx &lt;- matrix(rnorm(100 * 10000), nrow = 100)\n\nsystem.time({\n  r &lt;- cor(x, use = \"pairwise\", method = \"pearson\")\n})\n#&gt;    user  system elapsed \n#&gt;  40.554   0.774  42.857\nsystem.time({\n  r &lt;- cor(x, use = \"everything\", method = \"pearson\")\n})\n#&gt;    user  system elapsed \n#&gt;   7.001   0.698   7.057\nsystem.time({\n  n &lt;- t(!is.na(x)) %*% (!is.na(x))\n})\n#&gt;    user  system elapsed \n#&gt;   1.853   2.383   0.188\nsystem.time({\n  t &lt;- (r * sqrt(n - 2)) / sqrt(1 - r^2)\n})\n#&gt;    user  system elapsed \n#&gt;   1.054   1.131   2.003\nsystem.time({\n  p &lt;- -2 * expm1(pt(abs(t), (n - 2), log.p = TRUE))\n})\n#&gt;    user  system elapsed \n#&gt;  15.832   1.617  15.996\nsystem.time({\n  p &lt;- -2 * expm1(pt(abs(t), (dim(x)[1] - 2), log.p = TRUE))\n})\n#&gt;    user  system elapsed \n#&gt;  15.632   1.111  15.522"
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html",
    "href": "Books/Advanced R(2e)/7 Environments.html",
    "title": "7 Environments",
    "section": "",
    "text": "环境(enviroment, Env)是赋予作用域(scoping)能力的数据结构。本章会详细地介绍环境的数据结构，来提高对于作用域的理解。\n\n\n\n7.2节介绍环境的基本属性及如何创建一个自己的环境。\n7.3节通过一个模板函数，介绍与环境进行交互的方法。\n7.4节介绍4种特殊环境：R包环境，函数环境，函数执行换行，命名空间。\n7.5节介绍调用环境（caller）。\n7.6节简单讨论如何使用环境这一数据结构来解决一些特定问题。\n\n\n\n\n本章将使用 rlang 中的函数来处理环境。\n\nlibrary(rlang)\n\nrlang中的env_*()函数被设计用来在工作流中使用。所有的函数都接收一个环境作为参数，大多数会返回一个环境。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#introduction",
    "href": "Books/Advanced R(2e)/7 Environments.html#introduction",
    "title": "7 Environments",
    "section": "",
    "text": "环境(enviroment, Env)是赋予作用域(scoping)能力的数据结构。本章会详细地介绍环境的数据结构，来提高对于作用域的理解。\n\n\n\n7.2节介绍环境的基本属性及如何创建一个自己的环境。\n7.3节通过一个模板函数，介绍与环境进行交互的方法。\n7.4节介绍4种特殊环境：R包环境，函数环境，函数执行换行，命名空间。\n7.5节介绍调用环境（caller）。\n7.6节简单讨论如何使用环境这一数据结构来解决一些特定问题。\n\n\n\n\n本章将使用 rlang 中的函数来处理环境。\n\nlibrary(rlang)\n\nrlang中的env_*()函数被设计用来在工作流中使用。所有的函数都接收一个环境作为参数，大多数会返回一个环境。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#environment-basics",
    "href": "Books/Advanced R(2e)/7 Environments.html#environment-basics",
    "title": "7 Environments",
    "section": "Environment basics",
    "text": "Environment basics\n环境与有name属性的list很相似，但是有4点差异：\n\n要求name唯一。\nname不会被排序，即无法使用顺序来提取环境中的变量。\n赋值NULL时，环境会更改变量值，而不是删除变量。\n被修改时不会在内存中复制。\n\n\nBasics\n使用rlang::env()创建一个环境，与list类似，接收一个键值对集合。base::new.env()函数也可以创建环境，但是不能直接传递键值对集合，需要使用$&lt;-赋值。\n\ne1 &lt;- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n\ne2 &lt;- new.env()\ne2$a &lt;- FALSE\ne2$b &lt;- \"a\"\ne2$c &lt;- 2.3\ne2$d &lt;- 1:3\n\nidentical(e1, e2)\n#&gt; [1] FALSE\n\n\n环境具有引用语义：与大多数R对象不同，当你修改环境时，你是在原地修改它们，而不是创建副本。一个重要的含义是，环境可以自我包含。\n\ne1$d &lt;- e1\n\n\n在终端中直接运行环境仅会显示内存地址，使用env_print()可以打印更多环境信息，也可以使用env_names()直接输出目前环境中绑定过的变量名。\n\ne1\n#&gt; &lt;environment: 0x6403411bf7c0&gt;\nenv_print(e1)\n#&gt; &lt;environment: 0x6403411bf7c0&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;lgl&gt;\n#&gt; • b: &lt;chr&gt;\n#&gt; • c: &lt;dbl&gt;\n#&gt; • d: &lt;env&gt;\nenv_names(e1)\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n\n\n\nImportant environments\n这里介绍两个特殊环境，更多特殊的环境会在之后详细讲到：\n\n全局环境：就是当前交互终端的环境，global_env()或globalenv()获取。\n当前环境：当前执行代码的环境，current_env()或environment()获取，如果在终端中执行，那么等于全局环境。\n\n使用identical()判断两个环境是否相等，不能使用==，因为环境不是atomic或list类型。\n\nidentical(global_env(), current_env())\n#&gt; [1] TRUE\n\nglobal_env() == current_env()\n#&gt; Error in global_env() == current_env(): comparison (==) is possible only for atomic and list types\n\n\n\nParents\n使用env()创建环境时，提供一个没有name的参数即可设定环境的父环境。使用env_parent()或parent.env可以查看父环境。\n\ne2a &lt;- env(d = 4, e = 5)\ne2b &lt;- env(e2a, a = 1, b = 2, c = 3)\nenv_parent(e2b)\n#&gt; &lt;environment: 0x64033f224f70&gt;\nparent.env(e2b)\n#&gt; &lt;environment: 0x64033f224f70&gt;\nenv_parent(e2a)\n#&gt; &lt;environment: R_GlobalEnv&gt;\nparent.env(e2a)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n每个环境都有父环境，除了空环境（empty environment）。使用env_parents()可以查看所有父环境，空环境是根环境。\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\nenv_parents(e2b)\n#&gt; [[1]]   &lt;env: 0x64033f224f70&gt;\n#&gt; [[2]] $ &lt;env: global&gt;\nenv_parents(e2d)\n#&gt; [[1]]   &lt;env: 0x64033ce3bbd8&gt;\n#&gt; [[2]] $ &lt;env: empty&gt;\n\n\nenv_parents()通常只返回到全局环境。设置last = empty_env()可以返回所有父环境。\n\nenv_parents(e2b, last = empty_env())\n#&gt;  [[1]]   &lt;env: 0x64033f224f70&gt;\n#&gt;  [[2]] $ &lt;env: global&gt;\n#&gt;  [[3]] $ &lt;env: package:rlang&gt;\n#&gt;  [[4]] $ &lt;env: package:stats&gt;\n#&gt;  [[5]] $ &lt;env: package:graphics&gt;\n#&gt;  [[6]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[7]] $ &lt;env: package:datasets&gt;\n#&gt;  [[8]] $ &lt;env: renv:shims&gt;\n#&gt;  [[9]] $ &lt;env: package:utils&gt;\n#&gt; [[10]] $ &lt;env: package:methods&gt;\n#&gt; [[11]] $ &lt;env: Autoloads&gt;\n#&gt; [[12]] $ &lt;env: package:base&gt;\n#&gt; [[13]] $ &lt;env: empty&gt;\n\n\n\nSuper assignment, &lt;&lt;-\n常规赋值&lt;-会在当前环境中创建变量。超赋值&lt;&lt;-从不会在当前环境中创建变量，只是会修改变量，当前环境中没有就依次在父环境中搜索，直到全局环境。如果全局环境中也没有这个变量，就会在全局环境中创建这个变量。\n\nx &lt;- 0\nf &lt;- function() {\n  x &lt;&lt;- 1\n}\nf()\nx\n#&gt; [1] 1\n\n\n\nGetting and setting\n获取环境中的变量方法有$，[[，env_get()。\n\ne3 &lt;- env(x = 1, y = 2)\ne3$x\n#&gt; [1] 1\ne3$z &lt;- 3\ne3[[\"z\"]]\n#&gt; [1] 3\nenv_get(e3, \"z\")\n#&gt; [1] 3\n\n需要注意的是：[[不适用于数字索引，也不可以使用[。\n\ne3[[1]]\n#&gt; Error in e3[[1]]: wrong arguments for subsetting an environment\n\ne3[c(\"x\", \"y\")]\n#&gt; Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n\n变量不存在时，$，[[会返回NULL，但NULL在环境中有实际意义。 env_get()会返回错误，env_get()设置参数default后，可以给定默认值而不报错。\n\ne3$xyz\n#&gt; NULL\n\nenv_get(e3, \"xyz\")\n#&gt; Error in `env_get()`:\n#&gt; ! Can't find `xyz` in environment.\n\nenv_get(e3, \"xyz\", default = NA)\n#&gt; [1] NA\n\nrlang包还提供两种额外的设定变量值的方法：\n\nenv_poke()：只设置一个变量。\nenv_bind()：设置多个变量。\n\n\nenv_poke(e3, \"a\", 100)\ne3$a\n#&gt; [1] 100\n\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#&gt; [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n与list不同，当设置变量值为NULL时，并不会移除这个变量，而是实际有一个变量指向了NULL。env_has()可以用来检测环境中是否存在某个变量。env_unbind()会真实地解绑一个变量。\n\ne3$a &lt;- NULL\nenv_has(e3, \"a\")\n#&gt;    a \n#&gt; TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#&gt;     a \n#&gt; FALSE\n\n需要注意地是：env_unbind()不会删除变量，只是解绑变量与值的关系，删除变量是gc()的任务。在R base中存在功能与上述类似的函数：get()，assign()，exists()，rm()，这些函数被设计用来在当前环境中工作，其他环境中会略显不足。\n\n\nAdvanced bindings\nenv_bind()函数有两个变体：\n\nenv_bind_lazy()可以创建延迟绑定。在首次绑定前会先运行导致延迟的代码，然后再绑定。延迟绑定主要应用于R包中的autoload()，预先将数据集加载到内存中。\n\n\nenv_bind_lazy(current_env(), b = {\n  Sys.sleep(1)\n  1\n})\n\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       1\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\n\nenv_bind_active()可以创建实时绑定，每次重新绑定值。\n\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#&gt; [1] 0.08075014\nz1\n#&gt; [1] 0.834333\n\n更多见?delayedAssign()和?makeActiveBinding()。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#recursing-over-environments",
    "href": "Books/Advanced R(2e)/7 Environments.html#recursing-over-environments",
    "title": "7 Environments",
    "section": "Recursing over environments",
    "text": "Recursing over environments\n由于每个环境都会有一个父环境，可以利用这一特点，递归遍历环境，执行某些操作。下面是一个用来递归找到变量函数——where()的实现。\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\n\n首先判断是否是empty_env()，如果是则返回“找不到变量”，如果不是\n则判断当前环境是否包含这个变量，如果有则返回当前环境，如果没有\n则递归查询父环境。\n\n\nwhere(\"yyy\")\n#&gt; Error: Can't find yyy\n\nx &lt;- 5\nwhere(\"x\")\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n#&gt; &lt;environment: base&gt;\n\n用一幅图来展示上面的逻辑，想象下面两个环境：\n\ne4a &lt;- env(empty_env(), a = 1, b = 2)\ne4a\n#&gt; &lt;environment: 0x64033f466d88&gt;\ne4b &lt;- env(e4a, x = 10, a = 11)\ne4b\n#&gt; &lt;environment: 0x64033f3ce898&gt;\n\n\n\nwhere(\"a\", e4b)的结果是e4b。\nwhere(\"b\", e4b)的结果是e4a。\nwhere(\"c\", e4b)的结果是error。\n\n\nwhere(\"a\", e4b)\n#&gt; &lt;environment: 0x64033f3ce898&gt;\nwhere(\"b\", e4b)\n#&gt; &lt;environment: 0x64033f466d88&gt;\nwhere(\"c\", e4b)\n#&gt; Error: Can't find c\n\n总结这种递归查询环境的逻辑如下：\nf &lt;- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # base case\n  } else if (success) {\n    # success case\n  } else {\n    # recursive case\n    f(..., env = env_parent(env))\n  }\n}\n\nIteration versus recursion\n使用while循环改写上面的函数：\nf2 &lt;- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env &lt;- env_parent(env)\n  }\n\n  # base case\n}",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#special-environments",
    "href": "Books/Advanced R(2e)/7 Environments.html#special-environments",
    "title": "7 Environments",
    "section": "Special environments",
    "text": "Special environments\n许多环境是由R自行创建，例如：包环境，函数环境等，本节介绍四种特殊的环境——包环境，函数环境，函数运行环境，命名空间。\n\nPackage environments and the search path\n每次使用library()或require()时，都会将包环境变成全局环境的父环境，最先加载的包环境是后加载包环境的父环境。\n\n\n这些环境的关系也被称作搜索路径。你可以使用base::search()或rlang::search_envs()查看搜索路径。搜索路径的最后两个环境是固定的——Autoloads和base。\n\nsearch()\n#&gt;  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#&gt;  [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n#&gt;  [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n#&gt; [10] \"Autoloads\"         \"package:base\"\n\nsearch_envs()\n#&gt;  [[1]] $ &lt;env: global&gt;\n#&gt;  [[2]] $ &lt;env: package:rlang&gt;\n#&gt;  [[3]] $ &lt;env: package:stats&gt;\n#&gt;  [[4]] $ &lt;env: package:graphics&gt;\n#&gt;  [[5]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[6]] $ &lt;env: package:datasets&gt;\n#&gt;  [[7]] $ &lt;env: renv:shims&gt;\n#&gt;  [[8]] $ &lt;env: package:utils&gt;\n#&gt;  [[9]] $ &lt;env: package:methods&gt;\n#&gt; [[10]] $ &lt;env: Autoloads&gt;\n#&gt; [[11]] $ &lt;env: package:base&gt;\n\n\n\nThe function environment\n函数在被创建时，会自动绑定当前环境，这个环境被称作函数环境。函数与函数环境一起构成了“闭包”。\n使用rlang::fn_env()或base::environment()可以查看函数环境。\n\ny &lt;- 1\nf &lt;- function(x) x + y\nfn_env(f)\n#&gt; &lt;environment: R_GlobalEnv&gt;\nenvironment(f)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n上面的例子中，函数f()的函数环境是当前环境，其绑定的变量f在当前环境中。但实际上，这两种情况的环境并不总是相同。例如下面的例子，函数g()的函数环境是当前环境，但其绑定的变量g在环境e中。这两种的区别在于，前者定义了函数g如何寻找参数变量，后者定义了如何寻找函数g。（将e环境视作包环境，是不是更容易理解？）\n\ne &lt;- env()\ne$g &lt;- function(x) x\n\n\n\n\nExecution environments\n运行下面的函数，第一次，第二次，第n次的结果会怎样？\n\ng &lt;- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\n\ng(10)\n#&gt; [1] 1\ng(10)\n#&gt; [1] 1\n\n结果如上所示，每次的运行结果都相同。这是因为函数的执行环境在每次运行结束后，都会被清除，然后重新创建一个。它的父环境是函数环境。\n下面是一个各个环境之间关系的示意图：上面灰色方框表示执行环境，淡黄色框表示函数，右侧灰色框表示函数环境。\n\nh &lt;- function(x) {\n  # 1.\n  a &lt;- 2 # 2.\n  x + a\n}\ny &lt;- h(1) # 3.\n\n\n有些方法可以将执行环境保存下来。\n第一种就是直接返回：\n\nh2 &lt;- function(x) {\n  a &lt;- x * 2\n  current_env()\n}\n\ne &lt;- h2(x = 10)\nenv_print(e)\n#&gt; &lt;environment: 0x640342ee8650&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;dbl&gt;\n#&gt; • x: &lt;dbl&gt;\n\n另一种是将执行环境绑定到某个对象上，例如函数，成为函数环境：\n\nplus &lt;- function(x) {\n  function(y) x + y\n}\n\nplus_one &lt;- plus(1)\nplus_one\n#&gt; function (y) \n#&gt; x + y\n#&gt; &lt;environment: 0x6403442ad710&gt;\n\n\n\nplus_one(2)\n#&gt; [1] 3\n\n\n\n\nNamespaces\n命名空间规定了R包中的函数如何正确找到自己引用的函数。而不会因为前面加载的R包导致引用错误。\n例如下面的sd()函数：通过命名空间namespace指定var()函数来自于stats包。\n\nsd\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x64034413dfb8&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nR包中的函数都绑定一对环境——R包环境与命名空间。\n\nR包环境：针对使用者（user），告诉使用者如何引用函数。\n命名空间：针对R包自己，告诉R包中的函数如何引用其他函数。\n\n命名空间中的函数名集合包含R包环境中的，那些存在命名空间，但不存在R包环境中的函数，就是R包未导出的函数。\n\n前面说过，每个环境都有一个父环境。同样，每个命名空间环境都有一套相同的父环境：\n\n都有一个imports环境，定义了所有被R包使用的函数。R包开发者可以通过NAMESPACE文件来定义这个环境。\nimports环境的父环境是base包的命名空间。\nbase包的命名空间的父环境是全局环境R_GlobalEnv。\n\n\n最终父环境是全局环境，这一规则由于历史原因存在。按道理将不应该存在这一规则，因为这会导致在命名空间中不存在某个函数时，R会自动搜索全局环境。鉴于此，R CMD check会检查这种行为，并警告。\n将上述所有环境整合到一起，得到：\n\n函数和命名空间环境之间的绑定，是在加载R包时，因为创建了函数，触发创建函数环境导致的。也就是说，R包中函数的函数环境就是命名空间。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#call-stacks",
    "href": "Books/Advanced R(2e)/7 Environments.html#call-stacks",
    "title": "7 Environments",
    "section": "Call stacks",
    "text": "Call stacks\n最后一个特殊的环境是调用环境，可以通过rlang::caller_env()或base::parent.frame()查看。所谓调用环境就是调用函数的环境，如果你在函数A中调用函数B，那么B的调用环境就是函数A的函数环境。\n\ncaller_env()\n#&gt; &lt;environment: 0x640343382178&gt;\nparent.frame()\n#&gt; &lt;environment: 0x640343341cc0&gt;\n\n\nSimple call stacks\n函数之间的调用，会形成调用栈。下面是一个简单的函数调用栈。\n\nf &lt;- function(x) {\n  g(x = 2)\n}\ng &lt;- function(x) {\n  h(x = 3)\n}\nh &lt;- function(x) {\n  stop()\n}\n\n使用traceback()可以查看调用栈。\n\nf(x = 1)\n#&gt; Error in h(x = 3):\ntraceback()\n#&gt; No traceback available\n\n除了搭配stop() + traceback()，也可以使用lobstr::cst()直接查看调用栈。二者不同点在于栈的顺序相反。\n\nh &lt;- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#&gt;     ▆\n#&gt;  1. └─global f(x = 1)\n#&gt;  2.   └─global g(x = 2)\n#&gt;  3.     └─global h(x = 3)\n#&gt;  4.       └─lobstr::cst()\n\n\n\nLazy evaluation\n当函数的参数是函数返回值时，会触发延迟评估。调用栈会首先显示外层的调用，再显示内层的调用。\n\na &lt;- function(x) b(x)\nb &lt;- function(x) d(x)\nd &lt;- function(x) x\n\na(f())\n#&gt;     ▆\n#&gt;  1. ├─global a(f())\n#&gt;  2. │ └─global b(x)\n#&gt;  3. │   └─global d(x)\n#&gt;  4. └─global f()\n#&gt;  5.   └─global g(x = 2)\n#&gt;  6.     └─global h(x = 3)\n#&gt;  7.       └─lobstr::cst()\n\n\n\nFrames\n调用栈的每一层都被称为frame，是一种极其重要的内部数据结构，R代码只能访问其中部分数据，篡改frame会导致R崩溃。\n每个frame都三个关键点：\n\nexpr：调用的函数表达式，即在终端打印出的信息。\nenv：通常是函数表达式的执行环境。有两个例外：全局环境的frame是全局环境，eval()函数中的环境是任意的。\nparent：调用栈的栈（图中灰色线）。\n\n\n除此，frame还有退出机制on.exit(),return()等细节。\n\n\nDynamic scope\n在调用栈中检索变量的行为被称为动态作用域（dynamic scope）。动态作用域主要用于开发有助于交互式数据分析的函数，这是第 20 章讨论的主题之一。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#as-data-structures",
    "href": "Books/Advanced R(2e)/7 Environments.html#as-data-structures",
    "title": "7 Environments",
    "section": "As data structures",
    "text": "As data structures\n环境的数据结构可以作为一种引用语义，帮助解决下面三个常见的问题：\n\n避免大型数据的复制：在环境中，你永远也不会意外地创建副本。但是直接使用环境十分地不方便，推荐在第14章中讲到地R6类。\n管理R包的状态：创建一个额外的环境，在环境中记录状态。\n\n\nmy_env &lt;- new.env(parent = emptyenv())\nmy_env$a &lt;- 1\n\nget_a &lt;- function() {\n  my_env$a\n}\nset_a &lt;- function(value) {\n  old &lt;- my_env$a\n  my_env$a &lt;- value\n  invisible(old)\n}\n\n\n哈希映射 ：环境的数据结构就是一种哈希映射，可以缩短检索时间。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Blog/绘制点脊图.html",
    "href": "Blog/绘制点脊图.html",
    "title": "绘制点脊图",
    "section": "",
    "text": "最近在绘制气泡图时，发现点太密集了，想再绘制一个核密度图，来展示数据的分布。\n最先考虑的方案是：将geom_density()和geom_point()合并，创建一个新的geom。由于没有创建过自定义的geom，AI生成的结果不易修改，最终放弃。\n最后想到了ggridges包中可以分组单独绘制密度图，稍加修改得到最总的绘制结果。\n\nlibrary(ggplot2)\nlibrary(ggridges)\n\nset.seed(123)\ndf &lt;- data.frame(\n  category = factor(rep(LETTERS[1:3], each = 100)),\n  value = c(rnorm(100, 0), rnorm(100, 1), rnorm(100, 2))\n)\n\n# 调整 density_ridges 的 scale 参数，并设置点的位置\nggplot(df, aes(x = value, y = category)) +\n  geom_density_ridges(\n    aes(fill = category),\n    scale = 0.4, # 控制密度图的高度（较小值会使密度图更扁平）\n    rel_min_height = 0.01 # 设置最小高度以避免尾部过长\n  ) +\n  geom_point(aes(color = category), size = 5, position = position_nudge(y = -0.2))\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html",
    "href": "Books/Advanced R(2e)/8 Conditions.html",
    "title": "8 Conditions",
    "section": "",
    "text": "情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。\nR 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。\n\n\n\n8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。\n8.3 节介绍最简单的情况处理工具：像try()和suppressMessages()这样的函数，它们会吞噬情况信息并阻止其达到顶层。\n8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的tryCatch()和用于其他一切的withCallingHandlers()。\n8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。\n8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。\n\n\n\n\n本章使用rlang包中的状态信号与处理函数。\n\nlibrary(rlang)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#introduction",
    "href": "Books/Advanced R(2e)/8 Conditions.html#introduction",
    "title": "8 Conditions",
    "section": "",
    "text": "情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。\nR 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。\n\n\n\n8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。\n8.3 节介绍最简单的情况处理工具：像try()和suppressMessages()这样的函数，它们会吞噬情况信息并阻止其达到顶层。\n8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的tryCatch()和用于其他一切的withCallingHandlers()。\n8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。\n8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。\n\n\n\n\n本章使用rlang包中的状态信号与处理函数。\n\nlibrary(rlang)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#signalling-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#signalling-conditions",
    "title": "8 Conditions",
    "section": "Signalling conditions",
    "text": "Signalling conditions\nR 提供了三种情况信号：errors，warnings，messages。\n\nerror：最严重，表示函数无法继续执行，必须终止。\nwarning：次之，表示函数内部某些是错的，但是不影响函数运行。\nmessage：仅用于显示函数内某些动作的状态。\n\n情况系统的信息通常是瞩目的，例如加粗，红色等。\n\nstop(\"This is what an error looks like\")\n#&gt; Error: This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n#&gt; Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n#&gt; This is what a message looks like\n\n\nErrors\nbase R 通过stop()函数抛出错误信息。\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() stop(\"This is an error!\")\n\nf()\n#&gt; Error in h(): This is an error!\n\nstop()函数有参数.call，控制是否进行调用栈朔源（traceback()也可以）。\n\nh &lt;- function() stop(\"This is an error!\", call. = FALSE)\nf()\n#&gt; Error: This is an error!\n\nrlang 包中的abort()与stop()等价，但其功能更加全面，后面我们会继续介绍它。\n\nh &lt;- function() abort(\"This is an error!\")\nf()\n#&gt; Error in `h()`:\n#&gt; ! This is an error!\n\n错误信息最好可以指出哪里处了问题，引导用户改进。但是编写好的错误信息很困难，因为错误通常发生在用户对函数有一个有缺陷的心理模型时。作为开发人员，很难想象用户会如何错误地思考你的函数，因此很难编写一条能够引导用户走向正确方向的信息。\n\n\nWarnings\n警告信息比错误信息弱，它表示程序某些地方出错，但不影响程序正常运行。函数内可以有多条警告信息。\n\nfw &lt;- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\n与错误信息不同，警告信息默认在程序运行中缓存，结束后显示。\n\nfw()\n#&gt; 1\n#&gt; Warning in fw(): W1\n#&gt; 2\n#&gt; Warning in fw(): W2\n#&gt; 3\n#&gt; Warning in fw(): W3\n\noptions()可以设置警告信息的行为。\n\noptions(warn = 0)：默认设置。\noptions(warn = 1)：警告信息会立即显示。\noptions(warn = 0)：警告信息视作错误信息。\n\nwarning()函数同样有call.参数，建议设置为FALSE。rlang 中也有类似函数rlang::warn()。\nbase R 中的有些警告信息，作者认为改写为报错信息会给更好。例如：\n\nformals(1)\n#&gt; Warning in formals(fun): argument is not a function\n#&gt; NULL\n\nfile.remove(\"this-file-doesn't-exist\")\n#&gt; Warning in file.remove(\"this-file-doesn't-exist\"): cannot remove file\n#&gt; 'this-file-doesn't-exist', reason 'No such file or directory'\n#&gt; [1] FALSE\n\nlag(1:3, k = 1.5)\n#&gt; Warning in lag.default(1:3, k = 1.5): 'k' is not an integer\n#&gt; [1] 1 2 3\n#&gt; attr(,\"tsp\")\n#&gt; [1] -1  1  1\n\nas.numeric(c(\"18\", \"30\", \"50+\", \"345,678\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1] 18 30 NA NA\n\n有两种情况，使用警告信息会更好：\n\n当你升级了某个函数，但是不推荐使用它时，可以打印一个版本警告信息。\n当你确定可以通过警告信息提醒使用者正确使用函数时。\n\n\n\nMessages\n提示信息由message()函数生成，函数没有call.参数，生成的提示信息会实时打印在控制台。恰到好处的提示信息可以告诉使用者，你的程序运行到了哪里，此刻的运行状态是什么。\n\nfm &lt;- function() {\n  cat(\"1\\n\")\n  message(\"M1\")\n  cat(\"2\\n\")\n  message(\"M2\")\n  cat(\"3\\n\")\n  message(\"M3\")\n}\n\nfm()\n#&gt; 1\n#&gt; M1\n#&gt; 2\n#&gt; M2\n#&gt; 3\n#&gt; M3\n\n下面是一些使用提示信息的情况：\n\n当函数的默认参数值需要一些计算时，你需要告诉使用者计算的情况。例如ggplot中的binwidth参数，如果用户没有指定参数，ggplot会根据数据集自动计算一个合适的参数值。\n当函数调用了其他必要且耗时的函数时，你需要告诉使用者，你的程序正在做什么。\n当函数运行耗时特别长时，你需要提供一个进度条。\n为R包添加加载后的提示信息（使用packageStartupMessage()）。\n\n每个函数都应当有一个quiet = TRUE参数，用来禁用提示信息。\ncat()函数与messages()函数类似，但是cat()函数面向使用者，而messages()函数面向开发者。\n\ncat(\"Hi!\\n\")\n#&gt; Hi!\n\nmessage(\"Hi!\")\n#&gt; Hi!",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#ignoring-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#ignoring-conditions",
    "title": "8 Conditions",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nbase R 中忽略三种信息的方法：\n\ntry()：忽略所有错误信息。\nsuppressWarnings()：忽略所有警告信息。\nsuppressMessages()：忽略所有提示信息。\n\n这三种方法的共同缺点是，无法忽略单一某条信息，而保证其他信息通过，它们的作用是全局的。\n\ntry()\n通常函数报错会停止运行，try() 函数可以忽略错误信息，让函数继续执行。\n\nf1 &lt;- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n#&gt; Error in log(x): non-numeric argument to mathematical function\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n#&gt; [1] 10\n\n为了实现根据运行情况（成功或失败）返回不同的值时，不建议将try()的结果直接赋值给变量，而是事先定义变量，然后在try()内部进行赋值。除了try()函数，也可以使用更高级的tryCatch()函数。\n\n# 不推荐\ndefault &lt;- try(read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n#&gt; Warning in file(file, \"rt\"): cannot open file 'possibly-bad-input.csv': No\n#&gt; such file or directory\n# 推荐\ndefault &lt;- NULL\ntry(default &lt;- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n#&gt; Warning in file(file, \"rt\"): cannot open file 'possibly-bad-input.csv': No\n#&gt; such file or directory\n\n\n\nsuppress*\n\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n#&gt; [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n#&gt; [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n#&gt; You can still see me\n#&gt; [1] 3",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#handling-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#handling-conditions",
    "title": "8 Conditions",
    "section": "Handling conditions",
    "text": "Handling conditions\n每种情况都有默认行为：错误信息终止程序运行，警告信息在程序运行结束后打印，提示信息即时打印。情况处理系统允许我们暂时压制或补充这些默认行为。\nbase R 提供了两个函数 tryCatch() 和 withCallingHandlers() 来处理情况。前者在情况触发时进入到退出函数（exiting handlers），适合处理错误情况；后者在情况触发时会接着运行（calling handlers），适合处理警告和提示情况。\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_run_while_handlers_are_active\n)\n\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_run_while_handlers_are_active\n)\n\nCondition objects\n每种情况触发时，都会创建一个不被我们看到的condition对象，使用rlang::catch_cnd()函数可以查看此对象。\n\n# cnd &lt;- stop(\"An error\") # 也可以，但是会显示报错信息\ncnd &lt;- catch_cnd(stop(\"An error\"))\nstr(cnd)\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nconditionMessage(cnd)\n#&gt; [1] \"An error\"\nconditionCall(cnd)\n#&gt; force(expr)\n\ncondition对象包含两个元素：\n\nmessage：长度为1的字符串，用来展示信息。可以使用conditionMessage()函数查看。\ncall：触发情况的函数调用，如果参数call. = FALSE则为NULL。可以使用conditionCall()函数查看。\n\n自定义的condition对象也可以包含其他元素。\n该对象同时具有class属性，表示对象属于S3类。\n\n\nExiting handlers\ntryCatch()函数通常用在错误情况处理中，能够覆盖默认的错误行为。例如下面的函数在错误时返回NA。\n\nf3 &lt;- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n#&gt; [1] NA\n\n如果情况没有被触发或不符合定义的condition对象，则会正常运行。\n\ntryCatch(\n  error = function(cnd) 10,\n  1 + 1\n)\n#&gt; [1] 2\n\ntryCatch(\n  error = function(cnd) 10,\n  {\n    message(\"Hi!\")\n    1 + 1\n  }\n)\n#&gt; Hi!\n#&gt; [1] 2\n\ntryCatch()定义的handler称作 exiting handler，因为在情况触发后，程序不会再运行触发情况的代码。\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n#&gt; [1] \"There\"\n\n注意：定义的handler是一个函数，它的运行环境与外面代码的运行环境不用。\nhandler函数只接受一个参数——condition对象，可以提取对象中的信息，这对后续介绍的自定义condition对象十分有用。\n\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n#&gt; [1] \"--This is an error--\"\n\n\nfinally\ntryCatch()函数还有一个finally参数，接受一个代码块。其功能类似于on.exit()，无论情况是否触发，都会运行这段代码，通常用来清理缓存，删除临时文件或关闭链接等。\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\n\n\nCalling handlers\nwithCallingHandlers()函数通常用来处理警告或提示情况。与tryCatch()不同，代码触发情况后，会执行handler函数，待handler函数运行结束后接着运行。这好像中间插入了一段运行代码。\n下面是tryCatch()和withCallingHandlers()的比较：\n\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"),\n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"),\n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n#&gt; Someone there?\n#&gt; Caught a message!\n#&gt; Why, yes!\n\nhandler函数按顺序执行，不必担心内部情况被捕捉，造成死循环。\n\nwithCallingHandlers(\n  message = function(cnd) message(\"Second message\"),\n  message(\"First message\")\n)\n#&gt; Second message\n#&gt; First message\n\n但是要注意：如果有多个handler函数，某些handler函数的情况可能会被其他handler函数捕获，要考虑handler函数的顺序。\n\nwithCallingHandlers( # (1)\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers( # (2)\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#&gt; b\n#&gt; a\n#&gt; b\n#&gt; c\n\n\nmuffle\nwithCallingHandlers()中的handler函数也会返回值，但是与tryCatch()不同，它的返回值没有被使用，calling handler 函数只发挥了它的副作用。其中一个重要副作用就是屏蔽信息。\n当情况处理函数发生嵌套时，会自动触发父级handler函数。\n\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n#&gt; Hello\n\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\n可以使用rlang::cnd_muffle()来屏蔽信息。\n\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#call-stacks",
    "href": "Books/Advanced R(2e)/8 Conditions.html#call-stacks",
    "title": "8 Conditions",
    "section": "Call stacks",
    "text": "Call stacks\nexiting handler 函数与 calling handler 函数的调用栈不同。\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message(\"!\")\n\ncalling handler 是在函数f()的调用栈中被调用\n\nwithCallingHandlers(\n  f(),\n  message = function(cnd) {\n    lobstr::cst()\n    cnd_muffle(cnd)\n  }\n)\n#&gt;      ▆\n#&gt;   1. ├─base::withCallingHandlers(...)\n#&gt;   2. ├─global f()\n#&gt;   3. │ └─global g()\n#&gt;   4. │   └─global h()\n#&gt;   5. │     └─base::message(\"!\")\n#&gt;   6. │       ├─base::withRestarts(...)\n#&gt;   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#&gt;   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#&gt;   9. │       └─base::signalCondition(cond)\n#&gt;  10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n#&gt;  11.   └─lobstr::cst()\n\nexiting handler 是在函数tryCatch()的调用栈中被调用\n\ntryCatch(\n  f(),\n  message = function(cnd) lobstr::cst()\n)\n#&gt;     ▆\n#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#&gt;  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;  4.       └─value[[3L]](cond)\n#&gt;  5.         └─lobstr::cst()\n\n\ncatch_cnd(stop(\"An error\"))\n#&gt; &lt;simpleError in force(expr): An error&gt;\ncatch_cnd(abort(\"An error\"))\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! An error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#custom-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#custom-conditions",
    "title": "8 Conditions",
    "section": "Custom conditions",
    "text": "Custom conditions\nbase R 内置的condition对象包含的信息有限——message和call。rlang包提供了额外的函数——abort(),warn(),inform(),singal()，帮助自定义condition对象。它们的使用方法和base R 中的一样，例如：rlang::abort()通过参数class添加额外的类和附加信息。\n\nabort(\n  class = \"error_not_found\",\n  message = \"Path `blah.csv` not found\",\n  path = \"blah.csv\"\n)\n#&gt; Error:\n#&gt; ! Path `blah.csv` not found\n\n\nMotivation\n下面以base::log()函数为例，阐述自定义condition对象的优势。\n当参数不符合标准时，log()会返回一个错误。\n\nlog(letters)\n#&gt; Error in log(letters): non-numeric argument to mathematical function\nlog(1:10, base = letters)\n#&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical function\n\n上面的报错信息不是很友好，因为它没有具体指出那个参数错误，原因是什么。我们可以进行下面的修改：\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\n\nmy_log(letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `x` must be a numeric vector; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `base` must be a numeric vector; not character.\n\n现在的报错信息就显得用户友好了，但是对于开发者来说不够友好，所有关键信息都被储存在了报错信息中，我们无法函数式地编写这类报错。\n\n\nSignalling\n为了实现上述功能，我们先自定义一个abort()函数：函数通过glue::glue()将附加信息拼接到错误信息中，然后传递到abort()函数中。注意我们定义了一个新condition类型——error_bad_argument。\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n\n  abort(\"error_bad_argument\",\n    message = msg,\n    arg = arg,\n    must = must,\n    not = not\n  )\n}\n\n不基于rlang包，也可以实现上面的功能：\n\nstop_custom &lt;- function(.subclass, message, call = NULL, ...) {\n  err &lt;- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr &lt;- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\n#&gt; [1] \"error_new\" \"error\"     \"condition\"\nerr$x\n#&gt; [1] 10\n\n现在我们可以重新改写my_log()：\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\n\nmy_log(letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `x` must be numeric; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `base` must be numeric; not character.\n\n\n\nHandling\n自定义的condition类十分利于编程。\n我们可以使用testthat中的函数来检测这个类包含的内容是否符合预期：\n\nlibrary(testthat)\n#&gt; \n#&gt; Attaching package: 'testthat'\n#&gt; The following objects are masked from 'package:rlang':\n#&gt; \n#&gt;     is_false, is_null, is_true\n\nerr &lt;- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n\n自定义的类也可以用在handler函数中：\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n#&gt; [1] \"bad_argument\"\n\n需要注意的是，因为自定义的类属于子类，所以无法完美的进行类判断。handler函数的顺序会直接影响类的判断结果。\n\ntryCatch(\n  error = function(cnd) \"other error\",\n  error_bad_argument = function(cnd) \"bad_argument\",\n  my_log(\"a\")\n)\n#&gt; [1] \"other error\"",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#applications",
    "href": "Books/Advanced R(2e)/8 Conditions.html#applications",
    "title": "8 Conditions",
    "section": "Applications",
    "text": "Applications\n本节介绍一些使用tryCatch()和withCallingHandlers()的常见模式。\n\nFailure value\ntryCatch()的errorhandler函数返回默认值。\n\nfail_with &lt;- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n#&gt; [1] 2.302585\nfail_with(log(\"x\"), NA_real_)\n#&gt; [1] NA\n\n创建base::try()的类似函数try2()。\n\ntry2 &lt;- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg &lt;- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n#&gt; [1] 1\ntry2(stop(\"Hi\"))\n#&gt; Error: Hi\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\n\n\n\nSuccess and failure values\n将上面的模式再进一步改写为：成功返回一个值，失败返回另一个值。\nfoo &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n也可以改写为检测是否成功：\ndoes_error &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n还可以捕获condtion对象，类似于rlang::catch_cnd()：\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      expr\n      NULL\n    }\n  )\n}\n利用这一模式，我们可以创建一个try()变体，同时返回错误对象和结果：\n\nsafety &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n#&gt; List of 2\n#&gt;  $ result: num 11\n#&gt;  $ error : NULL\nstr(safety(stop(\"Error!\")))\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"Error!\"\n#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n上面的safety()函数类似于purrr::safely()，我们将在11章中讨论它。\n\n\nResignal\n前面讲到可以通过options(warn = 2)将警告转为错误。但这种做法是全局修改，我们可以构造下面的函数，单独将警告转为错误。\n\nwarning2error &lt;- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n\nwarning2error({\n  x &lt;- 2^4\n  warn(\"Hello\")\n})\n#&gt; Error:\n#&gt; ! Hello\n\n这个函数也可以用来查找那些经常出现但有不知道来源的信息，更多信息见22章。\n\n\nRecord\n修改handler函数，实现记录每条信息。\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n\n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; c\n\n如果想捕获错误信息，需要将withCallingHandlers()置于tryCatch()中。\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  tryCatch(\n    error = function(cnd) {\n      conds &lt;&lt;- append(conds, list(cnd))\n    },\n    withCallingHandlers(\n      message = add_cond,\n      warning = add_cond,\n      expr\n    )\n  )\n\n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  abort(\"C\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! C\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n这种模式同时也是evaluate包的主要思想，该包用于knitr中。\n\n\nNo default behaviour\n使用rlang::signal()函数可以创建不基于message,warning,error的condition类。\n\nlog &lt;- function(message, level = c(\"info\", \"error\", \"fatal\")) {\n  level &lt;- match.arg(level)\n  signal(message, \"log\", level = level)\n}\n\n因为没有默认的handler函数，log()函数不会打印任何信息。\n\nlog(\"This code was run\")\n\n搭配withCallingHandlers()函数，可以定义一个log的handler函数。\n\nrecord_log &lt;- function(expr, path = stdout()) {\n  withCallingHandlers(\n    log = function(cnd) {\n      cat(\n        \"[\", cnd$level, \"] \", cnd$message, \"\\n\",\n        sep = \"\",\n        file = path, append = TRUE\n      )\n    },\n    expr\n  )\n}\n\nrecord_log(log(\"Hello\"))\n#&gt; [info] Hello\n\n也可以创建一个不显示某个日志级别信息的handler函数。\n\nignore_log_levels &lt;- function(expr, levels) {\n  withCallingHandlers(\n    log = function(cnd) {\n      if (cnd$level %in% levels) {\n        cnd_muffle(cnd)\n      }\n    },\n    expr\n  )\n}\n\nrecord_log(ignore_log_levels(log(\"Hello\"), \"info\"))\n\n如果你手动创建了一个condition对象，并且通过signalCondition()触发，rlang::cnd_muffle()将不会工作。需要搭配withRestarts()。\nwithRestarts(signalCondition(cond), muffle = function() NULL)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html",
    "href": "Books/Advanced R(2e)/Functional programming.html",
    "title": "Introduction",
    "section": "",
    "text": "R 在本质上是一种泛函（functional）语言，呈现出一种以函数为中心的问题解决风格。下面我简要概述泛函语言的技术定义，重点讲解泛函编程风格，这对于日常的数据分析十分有用。\n泛函编程风格倾向于创建能够单独运行，便于自动优化或并行化的函数。它的传统缺点，如性能较差和有时不可预测的内存使用，近年来已经大大减少，可以作为面向对象编程的一种补充。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html#functional-programming-languages",
    "href": "Books/Advanced R(2e)/Functional programming.html#functional-programming-languages",
    "title": "Introduction",
    "section": "Functional programming languages",
    "text": "Functional programming languages\n每种编程语言都有函数，那么是什么使一种编程语言具有泛函呢？原因有很多，但有两个比较重要：\n\nfirst-class functions\n所谓第一类函数即是具有其他数据结构特点的函数。在R中，它可以：被赋值给其他变量，储存在list中，传递到其他函数中，被其他函数创建，甚至被函数返回。\n\n\npure function\n纯函数需要满足两个条件：\n\n输入决定输出：只要输入一样，输出就一样。反例：runif(),read.csv(),Sys.time()。\n没有副作用：比如改变全局变量，写入磁盘，在屏幕上显示。反例：print(),write.csv(),&lt;-。\n\n严格将，R 并不是一种泛函编程语言，因为它并不要求你的函数是纯函数。但是当你在编写泛函风格的代码时，你应当尽可能书写纯函数。通常，极端的纯函数或非纯函数更容易理解和改写。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html#functional-style",
    "href": "Books/Advanced R(2e)/Functional programming.html#functional-style",
    "title": "Introduction",
    "section": "Functional style",
    "text": "Functional style\n通俗的讲，泛函编程风格就是讲大问题分割为小问题，每个小问题编写一个函数去解决。解决小问题的函数是简单明了且能独立运行的，你需要做的是按照不同需求组合这些函数。\n接下来的三个章节分别讨论了三种泛函编程技巧：\n\n第9章（functional）：使用泛函编程改写for循环，如lapply()等函数。\n第10章（function factories）：输入向量，输出函数。\n第11章（function operators）：输入函数，输出函数。\n\n\n\n\n\n\n\n\nTip\n\n\n\n注意：图片中的Vector，它可以是任何数据结构，因为R中的所有数据结构都是基于Vector构建的。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html",
    "href": "Books/Advanced R(2e)/9 Functionals.html",
    "title": "9 Functionals",
    "section": "",
    "text": "泛函是一种以函数作为输入，输出向量的函数。下面是一个简单的泛函函数示例：\n\nrandomise &lt;- function(f) f(runif(1e3))\nrandomise(mean)\n#&gt; [1] 0.5122965\nrandomise(mean)\n#&gt; [1] 0.5053847\nrandomise(sum)\n#&gt; [1] 498.6696\n\nbase R 中常见的apply家族函数就属于泛函，还有purrr包中的map系列函数，以及一些数学泛函——integrate(),optim()。\nbase R 中的for循环优先级：泛函 &gt; for &gt; while &gt; repeat。如果你对for循环很熟悉，转换到泛函时，只需要从for循环中的提取函数，将其作为参数传入符合要求的泛函即可。当你找不到符合要求的泛函时，首先不要硬适配某种泛函，优先使用for循环，当类似的循环逻辑被重复使用时，考虑编写自己的泛函。\n\n\n\n9.2节：介绍purrr::map()。\n9.3节：讲解如何使用多个简单的泛函组合解决一个复杂问题，并且讨论purrr系列函数的使用风格。\n9.4节：介绍18个purrr::map()变体。\n9.5节：介绍另外一种风格的泛函——purrr::reduce()。\n9.6节：\n9.7节：介绍 base R 中的泛函。\n\n\n\n\n本章主要关注purrr包中的泛函，它们有着一致的使用风格，比较容易理解掌握。\n\nlibrary(purrr)",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#introduction",
    "href": "Books/Advanced R(2e)/9 Functionals.html#introduction",
    "title": "9 Functionals",
    "section": "",
    "text": "泛函是一种以函数作为输入，输出向量的函数。下面是一个简单的泛函函数示例：\n\nrandomise &lt;- function(f) f(runif(1e3))\nrandomise(mean)\n#&gt; [1] 0.5122965\nrandomise(mean)\n#&gt; [1] 0.5053847\nrandomise(sum)\n#&gt; [1] 498.6696\n\nbase R 中常见的apply家族函数就属于泛函，还有purrr包中的map系列函数，以及一些数学泛函——integrate(),optim()。\nbase R 中的for循环优先级：泛函 &gt; for &gt; while &gt; repeat。如果你对for循环很熟悉，转换到泛函时，只需要从for循环中的提取函数，将其作为参数传入符合要求的泛函即可。当你找不到符合要求的泛函时，首先不要硬适配某种泛函，优先使用for循环，当类似的循环逻辑被重复使用时，考虑编写自己的泛函。\n\n\n\n9.2节：介绍purrr::map()。\n9.3节：讲解如何使用多个简单的泛函组合解决一个复杂问题，并且讨论purrr系列函数的使用风格。\n9.4节：介绍18个purrr::map()变体。\n9.5节：介绍另外一种风格的泛函——purrr::reduce()。\n9.6节：\n9.7节：介绍 base R 中的泛函。\n\n\n\n\n本章主要关注purrr包中的泛函，它们有着一致的使用风格，比较容易理解掌握。\n\nlibrary(purrr)",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#my-first-functional-map",
    "href": "Books/Advanced R(2e)/9 Functionals.html#my-first-functional-map",
    "title": "9 Functionals",
    "section": "My first functional: map()",
    "text": "My first functional: map()\npurrr::map()函数接受一个‘list’或‘atomic vector’（.x）和函数（.f）作为输入，向量中的每个元素会被应用到函数中，最终返回一个list。即：map(1:3, f)等价于list(f(1), f(2), f(3))。\n\ntriple &lt;- function(x) x * 3\nmap(1:3, triple)\n#&gt; [[1]]\n#&gt; [1] 3\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 6\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 9\n\n\n这里的map不是“地图”的意思，而是“映射”，意味着‘map’将输入中的向量与结果通过函数进行了映射。\n下面是map()函数的核心逻辑：创建一个与输入等长的list，for循环处理向量，并把结果赋给list的元素。\n\nsimple_map &lt;- function(x, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], ...)\n  }\n  out\n}\n\n为了提高性能，map()函数其实是用C语言实现的。base R 中的lapply()函数与purrr::map()函数类似，但是lapply()函数不提供下面涉及到的额外功能。\n\nProducing atomic vectors\nmap()函数结果返回一个list，这赋予了其极大的灵活性，因为任何数据类型都可以储存在list中。但是有时返回的数据类型足够简单，我们无需再使用list储存。purrr 提供了四种特殊的变体函数——map_lgl(),map_int(),map_dbl()和map_chr()——分别返回布尔、整数、浮点数和字符向量。\n\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#&gt; \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#&gt;       am     gear     carb \n#&gt; \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique &lt;- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n#&gt;        mpg        cyl       disp         hp       drat         wt       qsec \n#&gt;  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 \n#&gt;         vs         am       gear       carb \n#&gt;   0.437500   0.406250   3.687500   2.812500\n\n所有map_*()系列函数要求返回的list长度与输入.x长度一致，所以.f必须返回一个值的结果，否则报错。\n\npair &lt;- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 2.\n\n类似的，如果map_*()系列函数要求返回特定类型的值时，.f必须返回该类型的结果，否则报错。\n\nmap_dbl(1:2, as.character)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a string to a double.\n\nmap()函数则没有上面的要求：\n\nmap(1:2, pair)\n#&gt; [[1]]\n#&gt; [1] 1 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2 2\nmap(1:2, as.character)\n#&gt; [[1]]\n#&gt; [1] \"1\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"2\"\n\n在 base R 中，有两个函数类似map_*()系列函数，可以返回原子向量——sapply()和vapply()。作者不建议使用sapply()，因为它会对结果进行整理，导致生成不确定的或向量，或list，或矩阵的结果。相反，vapply()通过参数FUN.VALUE要求用户指定结果的数据类型。例如vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))，其等价于map_dbl(x, mean, na.rm = TRUE)。\n\n\nAnonymous functions and shortcuts\n参数.f除提供函数名外，更多的是使用匿名函数或~ f(.x, ...)形式的公式。~ f(.x, ...)在传递其他参数时十分有用，也是最常用的方法。\n\nmap_dbl(mtcars, function(x) length(unique(x)))\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\nmap_dbl(mtcars, ~ length(unique(.x)))\n#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#&gt;   25    3   27   22   22   29   30    2    2    3    6\n\n~ f(.x, ...)形式的背后是 rlang 支持的lambda表达式。表达式会将map*()系列函数的参数.x解析为f()的第一个参数，参数.y解析为第二个，依次类推.其他map*()系列函数未定义，但函数f()需要的参数会通过...传递。只有一个参数时可以使用.替换.x，但是不建议，.仅作为向下兼容的牺牲写法，会与其他功能的.冲突。\n\nas_mapper(~ length(unique(.x)))\n#&gt; &lt;lambda&gt;\n#&gt; function (..., .x = ..1, .y = ..2, . = ..1) \n#&gt; length(unique(.x))\n#&gt; attr(,\"class\")\n#&gt; [1] \"rlang_lambda_function\" \"function\"\n\nmap_*()系列函数可以用来批量提取数据中的某个元素（通过purrr::pluck()函数）。通过name信息，位置信息，或二者组合来提取数据，这在从JSON数据（或R对象）中提取数据时特别有用。\n\nx &lt;- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#&gt; [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#&gt; [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n#&gt; [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\nmap_chr(x, \"z\")\n#&gt; Error in `map_chr()`:\n#&gt; ℹ In index: 3.\n#&gt; Caused by error:\n#&gt; ! Result must be length 1, not 0.\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#&gt; [1] \"a\" \"b\" NA\n\n下面是一个提取R t.test 结果对象中P值的示例：\n\ntrials &lt;- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))\nlibrary(ggplot2)\n\ndf_trials &lt;- tibble::tibble(p_value = map_dbl(trials, \"p.value\"))\n\ndf_trials %&gt;%\n  ggplot(aes(x = p_value, fill = p_value &lt; 0.05)) +\n  geom_dotplot(binwidth = .01) + # geom_histogram() as alternative\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n\n\n\n\nPassing arguments with ...\n诚如上述，你可以使用...来传递参数给函数。例如na.rm = TRUE，既可以使用~ f(.x, ...)形式直接传递参数，也可以通过map函数进行传递。\n\nx &lt;- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#&gt; [1] 3.0 5.5\nmap_dbl(x, mean, na.rm = TRUE)\n#&gt; [1] 3.0 5.5\n\n\n注意：...传入的参数不会被map函数解析，而是直接传递。map函数的其他变体会对参数进行解析，详见9.4节。\n\n\n\n\n\n\n\nNote\n\n\n\n注意：使用~ f(.x, ...)形式直接传递参数和通过map函数进行传递，这两种方式有些许不同。前者会在每次调用函数f时都评估参数，后者只会在map函数中评估一次。当参数需要延迟评估时要特别注意，例如下面的参数是有runif()随机生成。\n\nplus &lt;- function(x, y) x + y\n\nx &lt;- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#&gt; [1] 0.06556413 0.06556413 0.06556413 0.06556413\nmap_dbl(x, ~ plus(.x, runif(1)))\n#&gt; [1] 0.8742589 0.9740036 0.6046076 0.4938412\n\n\n\n\n\nArgument names\n当使用...传递参数时，推荐使用参数名称，而不是位置。例如，map(x, mean, trim = 0.1)要比map(x, mean, 0.1)更好。\nmap()函数的参数有两个——输入Vector，函数。考虑到尽量不与函数需要的参数名冲突，purrr 包分别使用了.x和.f作为参数名。如果使用了x,f（如最前面的simple_map()）作为参数名，那么就可能导致错误。此时只能使用匿名函数的形式来避免冲突。\n\nbootstrap_summary &lt;- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, bootstrap_summary, f = mean)\n#&gt; Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one\n\n# simple_map(mtcars, f = function(x) bootstrap_summary(x, mean))\n\nbase R 中，也有类似.x和.f的处理，如：\n\naplly 系函数使用大写字母X和FUN作为参数名。\ntransform()函数参数前使用前缀_。\n\n\n\nVarying another argument\n考虑下图中的情况：你需要将.x传递给函数的第二个参数，函数的第一个参数是固定的常量。例如你想计算固定向量在不同trim时的均值，mean(x, trim = trims)。\n\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\n有两种方法可以解决这个问题：\n\n使用匿名函数。\n\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#&gt; [1] 62.29917598  0.05500134  0.08526531  0.12600143\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#&gt; [1] 62.29917598  0.05500134  0.08526531  0.12600143\n\n\n使用mean()函数的参数自动匹配。你需要直到mean()函数的参数名称，\n\n\nmap_dbl(trims, mean, x = x)\n#&gt; [1] 62.29917598  0.05500134  0.08526531  0.12600143",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#purrr-style",
    "href": "Books/Advanced R(2e)/9 Functionals.html#purrr-style",
    "title": "9 Functionals",
    "section": "Purrr style",
    "text": "Purrr style\n在介绍其他map变体函数之前，我们先一窥使用purrr风格的函数的示例——数据分组建模，然后抽取模型系数。\n\n# 切分数据\nby_cyl &lt;- split(mtcars, mtcars$cyl)\n\n# 创建模型\nby_cyl %&gt;%\n  map(~ lm(mpg ~ wt, data = .x)) %&gt;%\n  map(coef) %&gt;%\n  map_dbl(2)\n#&gt;         4         6         8 \n#&gt; -5.647025 -2.780106 -2.192438\n\n下面使用 base R 中的函数来实现：\n\nby_cyl %&gt;%\n  lapply(function(data) lm(mpg ~ wt, data = data)) %&gt;%\n  lapply(coef) %&gt;%\n  vapply(function(x) x[[2]], double(1))\n#&gt;         4         6         8 \n#&gt; -5.647025 -2.780106 -2.192438\n\n去除管道符：\n\nmodels &lt;- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n#&gt;         4         6         8 \n#&gt; -5.647025 -2.780106 -2.192438\n\n使用for循环：\n\nslopes &lt;- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model &lt;- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] &lt;- coef(model)[[2]]\n}\nslopes\n#&gt; [1] -5.647025 -2.780106 -2.192438\n\n有趣的是，从 purr 到 base R 中的 apply 系函数，再到 for 循环，循环函数使用的越少，循环一次做的事情就越多。",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#map-variants",
    "href": "Books/Advanced R(2e)/9 Functionals.html#map-variants",
    "title": "9 Functionals",
    "section": "Map variants",
    "text": "Map variants\nmap系函数主要有23种，从输入与输出两个维度，可以大致划分为下面的表格：\n\n\n\n输入\\输出\nList\nAtomic\nSame type\nNothing\n\n\n\n\nOne argument\nmap()\nmap_lgl(), …\nmodify()\nwalk()\n\n\nTwo arguments\nmap2()\nmap2_lgl(), …\nmodify2()\nwalk2()\n\n\nOne argument + index\nimap()\nimap_lgl(), …\nimodify()\niwalk()\n\n\nN arguments\npmap()\npmap_lgl(), …\n—\npwalk()\n\n\n\n从表格中我们可以看到，除了上面介绍过的map()和map_lgl(), map_int(), map_dbl(), map_chr()，剩余函数可以再划分为5大类：\n\nmap2()：支持迭代两个输入。\nimap()：支持迭代两个输入，其中一个是另外一个的索引。\npmap()：支持迭代多个输入。\nmodify()：输出类型与输入相同。\nwalk()：不返回输出。\n\n\nSame type of output as input: modify()\nmodify()函数最常见的使用场景就是修改数据框。map()虽然也可以修改数据框中的数据，但其结果是一个list，而modify()函数返回一个数据框。\n\ndf &lt;- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#&gt; $x\n#&gt; [1] 2 4 6\n#&gt; \n#&gt; $y\n#&gt; [1] 12 10  8\nmodify(df, ~ .x * 2)\n#&gt;   x  y\n#&gt; 1 2 12\n#&gt; 2 4 10\n#&gt; 3 6  8\n\nmodify()函数的本质可以用下面的函数表示：\n\nsimple_modify &lt;- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] &lt;- f(x[[i]], ...)\n  }\n  x\n}\n\n\n\ntwo inputs: map2() and friends\n正如9.2节中提到，当你需要迭代两个参数时，map()函数无法满足，需要使用map2()函数。map2()函数对参数的迭代示意图如下：\n\n假设现在需要计算加权平均值，需要同时迭代xs,ws。map_dbl(xs, weighted.mean, w = ws)会报错，map2_dbl(xs, ws, weighted.mean)才是正确用法。\n\nxs &lt;- map(1:8, ~ runif(10))\nxs[[1]][[1]] &lt;- NA\nws &lt;- map(1:8, ~ rpois(10, 5) + 1)\n\nmap_dbl(xs, weighted.mean, w = ws)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error in `weighted.mean.default()`:\n#&gt; ! 'x' and 'w' must have the same length\nmap2_dbl(xs, ws, weighted.mean)\n#&gt; [1]        NA 0.4274373 0.4235742 0.4496665 0.4655846 0.4480563 0.4670280\n#&gt; [8] 0.4991842\n\n传递额外参数na.rm = TRUE的方式与map()一样。\n\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#&gt; [1] 0.4596985 0.4274373 0.4235742 0.4496665 0.4655846 0.4480563 0.4670280\n#&gt; [8] 0.4991842\n\n\nmap2()函数的本质可以用下面的函数表示：\n\nsimple_map2 &lt;- function(x, y, f, ...) {\n  out &lt;- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] &lt;- f(x[[i]], y[[i]], ...)\n  }\n  out\n}\n\nmap2()函数与simple_map2()函数略微不同的地方是，当.x与.y长度不一致时，map2()会自动将短的向量重复补齐。\n\n\n\nNo outputs: walk() and friends\nmap()函数可以存储数据并输出，但有时我们并不需要返回结果，此时可以使用walk()函数。下面是循环打印信息的例子，map()函数返回的是一个都是NULL的list，walk()函数则不返回任何对象。\n\nwelcome &lt;- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames &lt;- c(\"Hadley\", \"Jenny\")\n\n# As well as generate the welcomes, it also shows\n# the return value of cat()\nmap(names, welcome)\n#&gt; Welcome Hadley!\n#&gt; Welcome Jenny!\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL\n\nwalk(names, welcome)\n#&gt; Welcome Hadley!\n#&gt; Welcome Jenny!\n\nwalk2()函数通常用来将数据写入到磁盘。\n\ntemp &lt;- tempfile()\ndir.create(temp)\n\ncyls &lt;- split(mtcars, mtcars$cyl)\npaths &lt;- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#&gt; [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\"\n\n\n\nIterating over values and indices: imap()\nbase R 中对向量进行循环时，有三种类型：\n\n迭代元素：for (x in xs)\n迭代元素位置索引：for (i in seq_along(xs))\n迭代元素名称索引：for (nm in names(xs))\n\nmap()函数使用的是第一种，imap()函数使用第二种和第三种。imap(x, f)本质上等价于map2(x, names(x), f)或者map2(x, seq_along(x), f)。\n\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#&gt;                             Sepal.Length \n#&gt; \"The first value of Sepal.Length is 5.1\" \n#&gt;                              Sepal.Width \n#&gt;  \"The first value of Sepal.Width is 3.5\" \n#&gt;                             Petal.Length \n#&gt; \"The first value of Petal.Length is 1.4\" \n#&gt;                              Petal.Width \n#&gt;  \"The first value of Petal.Width is 0.2\" \n#&gt;                                  Species \n#&gt;   \"The first value of Species is setosa\"\n\n\nx &lt;- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#&gt; [1] \"The highest value of 1 is 992\" \"The highest value of 2 is 944\"\n#&gt; [3] \"The highest value of 3 is 907\" \"The highest value of 4 is 951\"\n#&gt; [5] \"The highest value of 5 is 880\" \"The highest value of 6 is 988\"\n\n\n\nAny number of inputs: pmap() and friends\npmap()函数的参数有两个:\n\n.l：参数列表，要求列表中每个元素长度相同，可以看作是一个数据框(data.frame)。\n.f：函数。\n\n这里要对map()函数中的参数.x = list时作个区分，map()中列表作为整体是一个参数，而pmap()中列表中的每个元素是一个参数。\n\nparams &lt;- tibble::tribble(\n  ~n, ~min, ~max,\n  1L, 0, 1,\n  2L, 10, 100,\n  3L, 100, 1000\n)\n\npmap(params, runif)\n#&gt; [[1]]\n#&gt; [1] 0.8321611\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 29.22384 41.99477\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 203.9812 334.4941 312.3663\n\n\nmap2(x, y, f) 可以等价为pmap(list(x, y), f)。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npmap_dbl(list(xs, ws), weighted.mean)\n#&gt; [1]        NA 0.4274373 0.4235742 0.4496665 0.4655846 0.4480563 0.4670280\n#&gt; [8] 0.4991842\n\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#&gt; [1] 0.4596985 0.4274373 0.4235742 0.4496665 0.4655846 0.4480563 0.4670280\n#&gt; [8] 0.4991842\n\n9.2.5小节中的情况也可以用pmap()解决。\n\ntrims &lt;- c(0, 0.1, 0.2, 0.5)\nx &lt;- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#&gt; [1] 0.476989476 0.007400580 0.004859345 0.023438581\n\nbase R 有两个等价的函数：Map()和mapply()，但是它们都有显著的缺陷。\n\nMap()：你无法提供额外的参数到函数中。\nmapply()：与sapply()一样，无法保证结果的一致性。",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#reduce-family",
    "href": "Books/Advanced R(2e)/9 Functionals.html#reduce-family",
    "title": "9 Functionals",
    "section": "Reduce family",
    "text": "Reduce family\nreduce系函数比较小众，不仅只有两种变体，还不常见。但它却为代数或处理大型数据提供了一种强有力的解决方法。\n\nBasics\nreduce()函数只接受两个参数：.x和.f。参数.f与map()不同，它要求初始输入.x中的两个元素，返回一个与输入类型相同的结果，然后将本次.f的结果作为下一次调用的输入。即reduce(1:4, f)等价于f(f(f(1,2),3),4)。\n\nreduce()函数的本质可以用下面的函数表示：\n\nsimple_reduce &lt;- function(x, f) {\n  out &lt;- x[[1]]\n  for (i in seq(2, length(x))) {\n    out &lt;- f(out, x[[i]])\n  }\n  out\n}\n\n举一个简单的例子：存在一个全是数字类型的列表，你想找到列表中每个元素都包含的数字。\n\n# 生成一个列表\nset.seed(123)\nl &lt;- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#&gt; List of 4\n#&gt;  $ : int [1:15] 3 3 10 2 6 5 4 6 9 10 ...\n#&gt;  $ : int [1:15] 3 8 10 7 10 9 3 4 1 7 ...\n#&gt;  $ : int [1:15] 10 7 5 7 5 6 9 2 5 8 ...\n#&gt;  $ : int [1:15] 5 9 10 4 6 8 6 6 7 1 ...\n\n# 使用intersect，找出列表中每个元素都包含的数字\nout &lt;- l[[1]]\nout &lt;- intersect(out, l[[2]])\nout &lt;- intersect(out, l[[3]])\nout &lt;- intersect(out, l[[4]])\nout\n#&gt; [1] 10  5  9\n\n使用reduce()函数，可以优雅地实现：\n\nreduce(l, intersect)\n#&gt; [1] 10  5  9\n\nreduce()函数通用支持传入额外参数到.f函数中：\n\n\n\nAccumulate\naccumulate()函数是reduce()函数的变体，它可以很清除地帮助我们看到reduce()是如何工作地。因为accumulate()函数会返回一个列表，列表中每个元素是.f函数的输出。\n\naccumulate(l, intersect)\n#&gt; [[1]]\n#&gt;  [1]  3  3 10  2  6  5  4  6  9 10  5  3  9  9  9\n#&gt; \n#&gt; [[2]]\n#&gt; [1]  3 10  5  4  9\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 10  5  9\n#&gt; \n#&gt; [[4]]\n#&gt; [1] 10  5  9\n\n另外一个理解 reduce 思想地例子是sum()函数：sum(x)可以等价为reduce(x,+)。accumulate(x,+)就等同于累加：\n\nx &lt;- c(4, 3, 10)\nreduce(x, `+`)\n#&gt; [1] 17\n\naccumulate(x, `+`)\n#&gt; [1]  4  7 17\n\n\n\n.init\n在有.init参数时，reduce()的处理逻辑如下：\n\n使用.init参数有两种作用：\n\n当reduce()的输入.x长度为1且没有提供参数.init，那么reduce()会直接返回.x。此时无法对输入类型进行判断，提供了.init参数后，相当于对输入的数据类型做出了规定。\n\n\nreduce(1, `+`)\n#&gt; [1] 1\nreduce(\"a\", `+`)\n#&gt; [1] \"a\"\nreduce(\"a\", `+`, .init = 0)\n#&gt; Error in .x + .y: non-numeric argument to binary operator\n\n\n当输入reduce()的.x长度为0且没有提供参数.init，那么reduce()会直接报错，反之不会。\n\n\nreduce(integer(), `+`)\n#&gt; Error in `reduce()`:\n#&gt; ! Must supply `.init` when `.x` is empty.\nreduce(integer(), `+`, .init = 0)\n#&gt; [1] 0\n\n使用reduce()函数一定要考虑到.x数据的长度，和.f函数的返回值类型。\n\n\nMultiple inputs\n极少数情况下，你需要向reduce()函数传递两个参数。例如，当你想将多个数据框进行join，但用于连接的变量.by因元素而异。此时你可以使用reduce2()。\nreduce2()的.y参数的长度取决于是否提供.init参数：若.x有4个元素，.f将只被调用3次，.y参数的长度是3，若同时提供.init，.f将被调用4次，.y参数的长度是4。\n\n\n\n\nMap-reduce\n你可能听说过 map-reduce, 这是一个为 Hadoop 等技术提供动力的概念。现在你可以看到这个基本概念是多么简单和强大：map-reduce 是一个结合了 reduce 的 map。对于大数据来说，区别在于数据分布在多台计算机上。每台计算机对其拥有的数据执行 map, 然后将结果发送回协调器，该协调器将各个结果 reduce 为单个结果。\n作为一个简单的例子，想象计算一个非常大的向量的平均值，这个向量如此之大，以至于必须分配给多台计算机。你可以让每台计算机计算总和和长度，然后将这些数据返回给协调器，由协调器通过将总和除以总长度来计算总平均值。",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#predicate-functionals",
    "href": "Books/Advanced R(2e)/9 Functionals.html#predicate-functionals",
    "title": "9 Functionals",
    "section": "Predicate functionals",
    "text": "Predicate functionals\npredicate 函数，也叫判断函数，返回值是单一的逻辑值——TRUE或FALSE，例如is.character(),is.null(),all(),any()。\n\n\n\n\n\n\nNote\n\n\n\nis.na()不符合判断函数的标准，它客户返回一个向量。anyNA()是判断函数，base R 不提供allNA()。\n\n\n\nBasics\npredicate functionals 就是将判断函数应用到.x中的每个元素，并返回一个逻辑向量。purrr包提过了7个有用的函数，可以分成3组：\n\nsome(.x, .p)：如果有任何元素匹配，返回TRUE，类似any(map_lgl(.x, .p))。\nevery(.x, .p)：如果所有元素匹配，返回TRUE，类似all(map_lgl(.x, .p))。\nnone(.x, .p) ：如果所有元素不匹配，返回TRUE，类似all(map_lgl(.x, negate(.p)))。\n虽然any(map_lgl(.x, .p)) 与some()类似，但前者需要将所有元素都判断后再运行any ,后者只要有一个TRUE 就返回。\ndetect(.x, .p)：返回.x中第一个匹配的元素。\ndetect_index(.x, .p)：返回.x中第一个匹配的元素的索引。\n\nkeep(.x, .p)：保留所有匹配的元素。\ndiscard(.x, .p)：丢弃所有匹配的元素。\n\n\ndf &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#&gt; NULL\ndetect_index(df, is.factor)\n#&gt; [1] 0\n\nstr(keep(df, is.factor))\n#&gt; 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\n\n\nMap variants\nmap()和modify()的有接受一个判断函数的变体——判断函数用来过滤.x。\n\ndf &lt;- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#&gt; List of 3\n#&gt;  $ num1: num 10\n#&gt;  $ num2: num 6\n#&gt;  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ num1: num  10 10 10\n#&gt;  $ num2: num  6 6 6\n#&gt;  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#&gt; List of 2\n#&gt;  $ num1: num 10\n#&gt;  $ num2: num 6",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/9 Functionals.html#base-functionals",
    "href": "Books/Advanced R(2e)/9 Functionals.html#base-functionals",
    "title": "9 Functionals",
    "section": "Base functionals",
    "text": "Base functionals\n\nMatrices and arrays\nbase R 中的apply()函数存在一些使用上的陷阱，它更多的是用于矩阵的数值计算上。\n\n与sapply()一样，它无法控制返回值的数据类型，向量？矩阵？列表？\napply()函数不是幂等的，这是因为如果汇总函数是标识运算符，则输出并不总是与输入相同。\n\na2d &lt;- matrix(1:20, nrow = 5)\na1 &lt;- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#&gt; [1] FALSE\n\na2 &lt;- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#&gt; [1] TRUE\n\napply()函数不适合处理数据框。\n\ndf &lt;- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#&gt; returning NA\n#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#&gt; returning NA\n#&gt;  x  y \n#&gt; NA NA\n\n\n\n\nMathematical concerns\n泛函再数学中广泛存在。泛函的计算方式与迭代密切相关。下面是一些 base R 中的计算函数。\n\nintegrate()：计算函数曲线下的面积。\nuniroot()：求函数f(x)=0的根。\noptimise()：求函数的最大或最小值。\n\n\nintegrate(sin, 0, pi)\n#&gt; 2 with absolute error &lt; 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#&gt; List of 5\n#&gt;  $ root      : num 3.14\n#&gt;  $ f.root    : num 1.22e-16\n#&gt;  $ iter      : int 2\n#&gt;  $ init.it   : int NA\n#&gt;  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#&gt; List of 2\n#&gt;  $ minimum  : num 4.71\n#&gt;  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#&gt; List of 2\n#&gt;  $ maximum  : num 1.57\n#&gt;  $ objective: num 1",
    "crumbs": [
      "9 Functionals"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html",
    "href": "Books/Advanced R(2e)/10 Function factories.html",
    "title": "10 Function factories",
    "section": "",
    "text": "function factories就是能创建函数的函数。下面是一个示例：使用power1()函数生成square()和cube()函数。\n\npower1 &lt;- function(exp) {\n  function(x) {\n    x^exp\n  }\n}\n\nsquare &lt;- power1(2)\ncube &lt;- power1(3)\n\nsquare()和cube()函数被称为manufactured functions，与function factories相对，这种叫称呼的唯一意义就是区分函数的来源，本质都是函数，没有区别。\n\nsquare(3)\n#&gt; [1] 9\ncube(3)\n#&gt; [1] 27\n\n我们在之前章节中分别介绍了能够实现function factories的三大基石：\n\n6.2.3节，介绍了R中的函数都是第一类函数（first-class functions），使用&lt;-直接将function()创建的函数赋值给变量。\n7.4.2节，介绍了在创建函数时会绑定创建时的环境，形成闭包。\n7.4.4节，介绍了函数每次运行时都会创建临时运行环境——最终变成manufunction factories的闭包环境。\n\n本章，我们介绍如何使用上述的三个概念，创建function factories，并将其应用到可视化与统计处理中。\n在三种主要的泛函编程工具(functionals, function factories, and function operators)中，function factories是使用最少的。总的来说，它们并不倾向于降低整体代码复杂度，而是将复杂度分割成更容易理解的块。函数工厂也是非常有用的函数运算符的重要组成部分，你将在第 11 章中学习。\n\n\n\n10.2节：function factories如何工作和使用\n10.3节：在可视化中的应用\n10.4节：在统计分析中的应用\n10.5节：与泛函联用\n\n\n\n\n熟悉6.2.3，7.4.2，7.4.4章节中的内容。\n我们使用rlang包检视function factories；使用ggplot2，scale包创建可视化示例。\n\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html#introduction",
    "href": "Books/Advanced R(2e)/10 Function factories.html#introduction",
    "title": "10 Function factories",
    "section": "",
    "text": "function factories就是能创建函数的函数。下面是一个示例：使用power1()函数生成square()和cube()函数。\n\npower1 &lt;- function(exp) {\n  function(x) {\n    x^exp\n  }\n}\n\nsquare &lt;- power1(2)\ncube &lt;- power1(3)\n\nsquare()和cube()函数被称为manufactured functions，与function factories相对，这种叫称呼的唯一意义就是区分函数的来源，本质都是函数，没有区别。\n\nsquare(3)\n#&gt; [1] 9\ncube(3)\n#&gt; [1] 27\n\n我们在之前章节中分别介绍了能够实现function factories的三大基石：\n\n6.2.3节，介绍了R中的函数都是第一类函数（first-class functions），使用&lt;-直接将function()创建的函数赋值给变量。\n7.4.2节，介绍了在创建函数时会绑定创建时的环境，形成闭包。\n7.4.4节，介绍了函数每次运行时都会创建临时运行环境——最终变成manufunction factories的闭包环境。\n\n本章，我们介绍如何使用上述的三个概念，创建function factories，并将其应用到可视化与统计处理中。\n在三种主要的泛函编程工具(functionals, function factories, and function operators)中，function factories是使用最少的。总的来说，它们并不倾向于降低整体代码复杂度，而是将复杂度分割成更容易理解的块。函数工厂也是非常有用的函数运算符的重要组成部分，你将在第 11 章中学习。\n\n\n\n10.2节：function factories如何工作和使用\n10.3节：在可视化中的应用\n10.4节：在统计分析中的应用\n10.5节：与泛函联用\n\n\n\n\n熟悉6.2.3，7.4.2，7.4.4章节中的内容。\n我们使用rlang包检视function factories；使用ggplot2，scale包创建可视化示例。\n\nlibrary(rlang)\nlibrary(ggplot2)\nlibrary(scales)",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html#factory-fundamental",
    "href": "Books/Advanced R(2e)/10 Function factories.html#factory-fundamental",
    "title": "10 Function factories",
    "section": "Factory fundamental",
    "text": "Factory fundamental\n实现function factories的关键原理可以表述为：function factories的执行环境是manufactured functions的创建（闭包）环境。本节将通过互动探索和一些图表帮助你更深刻地理解这一原理。\n\nEnvironments\n首先查看一下square()和cube()函数。\n\nsquare\n#&gt; function (x) \n#&gt; {\n#&gt;     x^exp\n#&gt; }\n#&gt; &lt;environment: 0x000002bf1dd66e08&gt;\n\ncube\n#&gt; function (x) \n#&gt; {\n#&gt;     x^exp\n#&gt; }\n#&gt; &lt;bytecode: 0x000002bf1deac278&gt;\n#&gt; &lt;environment: 0x000002bf1dd86ac8&gt;\n\n从两个函数的结构中，我们可以清晰地知道参数x的值来源，但参数exp的值来源呢？仔细观察会发现，两个函数的主体结构是相同的，它们绑定的创建环境不同。\n下面我们使用rlang::env_print()函数查看各自的创建环境。\n\nenv_print(square)\n#&gt; &lt;environment: 0x000002bf1dd66e08&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • exp: &lt;dbl&gt;\n\nenv_print(cube)\n#&gt; &lt;environment: 0x000002bf1dd86ac8&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • exp: &lt;dbl&gt;\n\n从结果中，我们可以看到两个函数的创建函数的父环境都是全局环境，同时都绑定了变量exp。\n我们使用rlang::fn_env()函数查看环境中变量的值。\n\nfn_env(square)$exp\n#&gt; [1] 2\n\nfn_env(cube)$exp\n#&gt; [1] 3\n\n终于，我们找到了square和cube函数的不同之处：square函数的创建环境绑定的变量exp的值为2，而cube函数的创建环境绑定的变量exp的值为3。\n\n\nDiagram conventions\npower1()，square()，cube()三个函数的关系可以用下面示意图表示：\n\n不考虑过多细节，我们可以抽象出下面两条规律：\n\n任何自由浮动的变量都存在于全局变量（function factories的创建环境）中。\n任何没有显式父级的环境都继承自全局环境（function factories的创建环境）。\n\n\n当执行square(10)时，我们可以预料到：x^exp中的x在函数的执行环境中，exp在函数的创建环境中。\n\n\n\nForcing evaluation\n在实际使用过程中，power1()函数会因为延迟评估造成bug。\n\nx &lt;- 2\nsquare &lt;- power1(x)\nx &lt;- 3\n\n此时运行square(2)，不会返回4，而是8。\n\nsquare(2)\n#&gt; [1] 8\n\n因为power1()中的x只有在square()被调用时才会被评估。这种由于延迟评估造成的bug，在由function factories生成manufactured functions时广泛存在。\n我们可以使用force()函数来强制在创建square()时，power1()的参数x就被评估。\n\npower2 &lt;- function(exp) {\n  force(exp)\n  function(x) {\n    x^exp\n  }\n}\n\nx &lt;- 2\nsquare &lt;- power2(x)\nx &lt;- 3\nsquare(2)\n#&gt; [1] 4\n\n如果输入的参数被调用，那么它就可以被视作“force”了。例如exp &lt;- exp + 1 - 1。\n\npower3 &lt;- function(exp) {\n  exp &lt;- exp + 1 - 1\n  function(x) {\n    x^exp\n  }\n}\nx &lt;- 2\nsquare &lt;- power3(x)\nx &lt;- 3\nsquare(2)\n#&gt; [1] 4\n\n\n\nStateful functions\n6.4.3节中讲到，函数每次执行都会创建执行环境，我们无法将函数的第一次调用与第二次调用进行关联。但是function factories可以允许我们进行关联，保持每次调用时的状态。\n\nmanufactured functions的执行环境是function factories的创建环境——唯一且固定。\nR 中的&lt;&lt;-允许修改创建环境中的变量。\n\n下面是一个记录函数被调用次数的状态函数例子：\n\nnew_counter &lt;- function() {\n  i &lt;- 0\n\n  function() {\n    i &lt;&lt;- i + 1\n    i\n  }\n}\n\ncounter_one &lt;- new_counter()\ncounter_two &lt;- new_counter()\n\ncounter_one()和counter_two()创建时，i的初始值是0。\n\n每被调用一次，i的值都会加1。\n\ncounter_one()\n#&gt; [1] 1\ncounter_one()\n#&gt; [1] 2\ncounter_two()\n#&gt; [1] 1\n\n\n状态函数最好用于调节。一旦函数开始管理多个变量的状态，最好切换到 R6 面向对象, 我们会在第14章中介绍。\n\n\nGarbage collection\n因为manufactured functions的执行环境是唯一且固定的，我们无法在全局环境中删除其创建的变量，当它内部创建了内存消耗过大的变量时，我们要手动定义删除这些变量。\n\nf1 &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  function() m\n}\n\ng1 &lt;- f1(1e6)\nlobstr::obj_size(g1)\n#&gt; 8.00 MB\n\nf2 &lt;- function(n) {\n  x &lt;- runif(n)\n  m &lt;- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 &lt;- f2(1e6)\nlobstr::obj_size(g2)\n#&gt; 504 B",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html#graphical-factories",
    "href": "Books/Advanced R(2e)/10 Function factories.html#graphical-factories",
    "title": "10 Function factories",
    "section": "Graphical factories",
    "text": "Graphical factories\n本节我们给出一些应用function factories到ggplot2的例子。\n\nLabelling\nscales 包提供了许多function factories，例如其中的formatter函数：它根据参数返回一个函数，用来生成不同格式的标签。\n\ny &lt;- c(12345, 123456, 1234567)\ncomma_format()(y)\n#&gt; [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#&gt; [1] \"12 K\"    \"123 K\"   \"1 235 K\"\n\nscales 包的这些function factories，可以说就是为了ggplot2服务的，例如laebls参数需要提供的值就是一个函数，用来对轴标签进行格式化。\n\ndf &lt;- data.frame(x = 1, y = y)\ncore &lt;- ggplot(df, aes(x, y)) +\n  geom_point() +\n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n\ncore\n\n\n\n\n\n\n\ncore + scale_y_continuous(\n  labels = comma_format()\n)\n\n\n\n\n\n\n\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\n\n\n\n\n\n\n\ncore + scale_y_continuous(\n  labels = scientific_format()\n)\n\n\n\n\n\n\n\n\n\n\nHistogram bins\ngeom_histogram()的binwidth参数除接受一个数值外，也可以接受一个函数。函数在分组绘制histogram时十分有用，因为它会按组别计算bin宽度，保持bin的数目一致。下面是一个例子：\n\n# construct some sample data with very different numbers in each cell\nsd &lt;- c(1, 5, 15)\nn &lt;- 100\n\ndf &lt;- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) +\n  geom_histogram(binwidth = 2) +\n  facet_wrap(~sd, scales = \"free_x\") +\n  labs(x = NULL)\n\n\n\n\n\n\n\n\n我们在生成数据时，每个组的数据量是相同的，但区间不同；导致当设置binwidth参数为固定值时，不同组别的bin数目不同的，相反我们应该固定bin的数目，根据bin数据计算binwidth。\n\nbinwidth_bins &lt;- function(n) {\n  force(n)\n\n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) +\n  geom_histogram(binwidth = binwidth_bins(20)) +\n  facet_wrap(~sd, scales = \"free_x\") +\n  labs(x = NULL)\n\n\n\n\n\n\n\n\nbase R 提供了一些计算最优binwidth的函数，例如nclass.Sturges(),nclass.scott(),nclass.FD()，我们可以将其打包成一个function factories。\n\nbase_bins &lt;- function(type) {\n  fun &lt;- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n\n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) +\n  geom_histogram(binwidth = base_bins(\"FD\")) +\n  facet_wrap(~sd, scales = \"free_x\") +\n  labs(x = NULL)\n\n\n\n\n\n\n\n\n\n\nggsave()\ngglot2 中的ggsave()函数，其内部使用了一个function factories——plot_dev()。 其根据文件后缀判断图片类型，选择合适的绘图设备。下面是plot_dev()的简化示例：\n\nplot_dev &lt;- function(ext, dpi = 96) {\n  force(dpi)\n\n  switch(ext,\n    eps = ,\n    ps = function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE,\n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#&gt; function (filename, ...) \n#&gt; grDevices::pdf(file = filename, ...)\n#&gt; &lt;bytecode: 0x000002bf26845b70&gt;\n#&gt; &lt;environment: 0x000002bf264bcd30&gt;\nplot_dev(\"png\")\n#&gt; function (...) \n#&gt; grDevices::png(..., res = dpi, units = \"in\")\n#&gt; &lt;bytecode: 0x000002bf1f72e618&gt;\n#&gt; &lt;environment: 0x000002bf1f30c928&gt;",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html#statistical-factories",
    "href": "Books/Advanced R(2e)/10 Function factories.html#statistical-factories",
    "title": "10 Function factories",
    "section": "Statistical factories",
    "text": "Statistical factories\n本节介绍一些统计分析中运用到的function factories例子。\n\nBox-Cox transformation\nBox-Cox变换是一种常用的数据变换方法，用于处理非正态数据正态化。唯一参数是λ，用来控制转换强度。Box-Cox变换可以用下面的函数实现：\n\nboxcox1 &lt;- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n\n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x^lambda - 1) / lambda\n  }\n}\n\n我们将上面的函数转换为一个function factories，用其探索不同λ对数据的影响。\nboxcox2 &lt;- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x^lambda - 1) / lambda\n  }\n}\n\nstat_boxcox &lt;- function(lambda) {\n  stat_function(aes(color = lambda), fun = boxcox2(lambda), linewidth = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) +\n  lapply(c(0.5, 1, 1.5), stat_boxcox) +\n  scale_colour_viridis_c(limits = c(0, 1.5))\n\nggplot(data.frame(x = c(0.01, 1)), aes(x)) +\n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) +\n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n\n\n\n\n\n\n\n\n\n\n\nBootstrap generators\n在统计分析工作中，我们经常需要多个Bootstrap生成器，这个时候构建一个Bootsrap生成器的function factories就显得很有必要。\n下面是一个对数据框中某列进行随机抽样的例子：\n\nboot_sample &lt;- function(df, var) {\n  n &lt;- nrow(df)\n  force(var)\n\n  function() {\n    col &lt;- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 &lt;- boot_sample(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#&gt; [1] 33.9 18.1 33.9 24.4 13.3 26.0\nhead(boot_mtcars1())\n#&gt; [1] 22.8 15.2 33.9 21.4 17.8 10.4\n\n有时我们需要构建一个根据模型生成随机样本的Bootstrap生成器。\n\nboot_model &lt;- function(df, formula) {\n  model &lt;- lm(formula, data = df)\n  fitted &lt;- unname(fitted(model))\n  resid &lt;- unname(resid(model))\n  rm(model)\n\n  function() {\n    fitted + sample(resid)\n  }\n}\n\nboot_mtcars2 &lt;- boot_model(mtcars, mpg ~ wt + disp)\nhead(boot_mtcars2())\n#&gt; [1] 29.69387 22.45676 22.68264 17.29761 14.38976 18.10000\nhead(boot_mtcars2())\n#&gt; [1] 25.54030 20.17392 25.23816 19.83821 18.45017 18.10000\n\n\n\nMaximum likelihood estimation\n最大似然估计（MLE）用来找到某个分布的参数，使得观测数据在该分布下出现概率最大。下面我们使用泊松分布来演示如何通过function factories优雅的实现最大似然估计。\n泊松分布的公式如下，当已知参数λ后，我们可以计算观察数据\\(X\\)的概率：\n\\[\nP(\\lambda,{\\bf x})=\\prod_{i=1}^{n}\\frac{\\lambda^{x_{i}}e^{-\\lambda}}{x_{i}!}\n\\]\n在统计中，我们通常对数化累乘公式，将其转换为累加：\n\n累加的计算量小\n累乘在计算机中会导致浮点数精确度下降\n\n\\[\n\\log(P(\\lambda,{\\bf x})) = \\sum_{i=1}^{n}\\log\\left(\\frac{\\lambda^{x_i}e^{-\\lambda}}{x_i!}\\right)\n\\]\n\\[\n\\log(P(\\lambda,{\\bf x})) = \\sum_{i=1}^{n}\\left(x_i\\log(\\lambda) - \\lambda - \\log(x_i!)\\right)\n\\]\n\\[\n\\log(P(\\lambda,{\\bf x})) = \\sum_{i=1}^{n}x_i\\log(\\lambda) - \\sum_{i=1}^{n}\\lambda - \\sum_{i=1}^{n}\\log(x_i!)\n\\]\n\\[\n\\log(P(\\lambda,{\\bf x})) = \\log(\\lambda)\\sum_{i=1}^{n}x_i - n\\lambda - \\sum_{i=1}^{n}\\log(x_i!)\n\\]\n构造已知λ后计算观察数据\\(X\\)概率的函数：\n\nmle_poisson &lt;- function(lambda, x) {\n  # x 相对是固定的，提前计算，可以节省计算资源\n  sum_x &lt;- sum(x)\n  n &lt;- length(x)\n  c &lt;- sum(lfactorial(x))\n  # log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  log(lambda) * sum_x - n * lambda - c\n}\n\n使用base R 计算观察数据\\(X\\)的概率：\n\nx1 &lt;- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\nmle_poisson(10, x1)\n#&gt; [1] -183.6405\nmle_poisson(20, x1)\n#&gt; [1] -61.14028\nmle_poisson(30, x1)\n#&gt; [1] -30.98598\n\n虽然我们可以计算已知λ下的观察数据\\(X\\)的概率，但是最大似然估计要求我们找到一个λ，使得该概率最大。我们可以构造一个观察数据\\(X\\)的function factories，并使用optimize()函数来寻找最大概率的λ。\n\nmle_poisson2 &lt;- function(x) {\n  force(x)\n  function(lambda) {\n    mle_poisson(lambda, x)\n  }\n}\n\noptimise(mle_poisson2(x1), interval = c(0, 100), maximum = TRUE)\n#&gt; $maximum\n#&gt; [1] 32.09999\n#&gt; \n#&gt; $objective\n#&gt; [1] -30.26755\n\n借助optimize()函数的...参数，我们可以直接使用下面的代码：\n\noptimise(mle_poisson, interval = c(0, 100), x = x1, maximum = TRUE)\n#&gt; $maximum\n#&gt; [1] 32.09999\n#&gt; \n#&gt; $objective\n#&gt; [1] -30.26755",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/10 Function factories.html#function-factories-functionals",
    "href": "Books/Advanced R(2e)/10 Function factories.html#function-factories-functionals",
    "title": "10 Function factories",
    "section": "Function factories + functionals",
    "text": "Function factories + functionals\n组合使用function factories和functionals，可以通过map系函数传递参数，构造出一个函数集合。如果你的function factories需要多个参数，就使用相应的map系函数。\n\nnames &lt;- list(\n  square = 2,\n  cube = 3,\n  root = 1 / 2,\n  cuberoot = 1 / 3,\n  reciprocal = -1\n)\nfuns &lt;- purrr::map(names, power1)\n\nfuns$root(64)\n#&gt; [1] 8\nfuns$root\n#&gt; function (x) \n#&gt; {\n#&gt;     x^exp\n#&gt; }\n#&gt; &lt;bytecode: 0x000002bf1deac278&gt;\n#&gt; &lt;environment: 0x000002bf24488780&gt;\n\n在上面的例子中，你需要使用funs$来提取函数，下面有三种方法可以直接使用funs内部的函数：\n\n使用with()，临时提取函数\n\n\nwith(funs, root(64))\n#&gt; [1] 8\n\n\n使用attach()，将函数绑定到当前环境\n\n\nattach(funs)\n#&gt; The following objects are masked _by_ .GlobalEnv:\n#&gt; \n#&gt;     cube, square\nroot(100)\n#&gt; [1] 10\ndetach(funs)\n\n\n使用rlang::env_bind()，将函数绑定到当前环境\n\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#&gt; [1] 10\nrlang::env_unbind(globalenv(), names(funs))",
    "crumbs": [
      "10 Function factories"
    ]
  },
  {
    "objectID": "Blog/替换多对字符串.html",
    "href": "Blog/替换多对字符串.html",
    "title": "替换多对字符串",
    "section": "",
    "text": "考虑下面的情景：你提取到每个物种特有的keggID号，为了节省空间，你将keggID号拼接了起来。与此同时，你需要将keggID号对应得代谢物名称追加到数据集中。\n\n# 示例数据\ndat &lt;- tibble::tribble(\n  ~species, ~keggID,\n  \"Homo sapiens\", \"C00001;C00002;C00003\",\n  \"Mus musculus\", \"C00002;C00004;C00005\",\n  \"Rattus norvegicus\", \"C00001;C00002;C00006\"\n)\n\nkeggID_metabolite &lt;- tibble::tribble(\n  ~keggID, ~metabolite,\n  \"C00001\", \"Amino acid\",\n  \"C00002\", \"Carbohydrate\",\n  \"C00003\", \"Lipid\",\n  \"C00004\", \"Carbohydrate\",\n  \"C00005\", \"Lipid\",\n  \"C00006\", \"Carbohydrate\"\n)\n\n我们可以按照常规做法：将dat中的keggID列拆分，然后将代谢物信息追加到数据中，最后再进行字符串拼接。\n\nres1 &lt;- dat |&gt;\n  tidyr::separate_rows(keggID, sep = \";\") |&gt;\n  dplyr::left_join(keggID_metabolite, by = \"keggID\") |&gt;\n  dplyr::group_by(species) |&gt;\n  dplyr::summarise(\n    keggID = paste(keggID, collapse = \";\"),\n    metabolite = paste(metabolite, collapse = \";\")\n  )\nres1\n#&gt; # A tibble: 3 × 3\n#&gt;   species           keggID               metabolite                          \n#&gt;   &lt;chr&gt;             &lt;chr&gt;                &lt;chr&gt;                               \n#&gt; 1 Homo sapiens      C00001;C00002;C00003 Amino acid;Carbohydrate;Lipid       \n#&gt; 2 Mus musculus      C00002;C00004;C00005 Carbohydrate;Carbohydrate;Lipid     \n#&gt; 3 Rattus norvegicus C00001;C00002;C00006 Amino acid;Carbohydrate;Carbohydrate\n\n我们也可以使用泛函map() + reduce2() + stringr::str_replace_all()直接替换字符串。\n\nStrReplace &lt;- function(string, patterns, replacements) {\n  purrr::reduce2(\n    patterns,\n    replacements,\n    .f = stringr::str_replace_all,\n    .init = string\n  )\n}\n\nres2 &lt;- dat |&gt;\n  dplyr::mutate(\n    metabolite = StrReplace(\n      keggID,\n      patterns = keggID_metabolite$keggID,\n      replacements = keggID_metabolite$metabolite\n    )\n  )\nres2\n#&gt; # A tibble: 3 × 3\n#&gt;   species           keggID               metabolite                          \n#&gt;   &lt;chr&gt;             &lt;chr&gt;                &lt;chr&gt;                               \n#&gt; 1 Homo sapiens      C00001;C00002;C00003 Amino acid;Carbohydrate;Lipid       \n#&gt; 2 Mus musculus      C00002;C00004;C00005 Carbohydrate;Carbohydrate;Lipid     \n#&gt; 3 Rattus norvegicus C00001;C00002;C00006 Amino acid;Carbohydrate;Carbohydrate\n\n进行两种方法的耗时对比：\n\nmethod1 &lt;- function(data, keggID_metabolite) {\n  res &lt;- data |&gt;\n    tidyr::separate_rows(keggID, sep = \";\") |&gt;\n    dplyr::left_join(keggID_metabolite, by = \"keggID\") |&gt;\n    dplyr::group_by(species) |&gt;\n    dplyr::summarise(\n      keggID = paste(keggID, collapse = \";\"),\n      metabolite = paste(metabolite, collapse = \";\")\n    )\n  return(res)\n}\n\nmethod2 &lt;- function(data, keggID_metabolite) {\n  res &lt;- data |&gt;\n    dplyr::mutate(\n      metabolite = StrReplace(\n        keggID,\n        patterns = keggID_metabolite$keggID,\n        replacements = keggID_metabolite$metabolite\n      )\n    )\n  return(res)\n}\n\nbench_dat &lt;- function(dat, n) {\n  data &lt;- dplyr::bind_rows(replicate(n, dat, simplify = FALSE)) |&gt;\n    dplyr::mutate(species = dplyr::row_number())\n\n  bench::mark(\n    M1 = method1(data, keggID_metabolite),\n    M2 = method2(data, keggID_metabolite),\n    time_unit = \"ms\"\n  )\n}\n\nperformances &lt;- purrr::map_dfr(10^(1:5), ~ bench_dat(dat, .x))\n#&gt; Warning: Some expressions had a GC in every iteration; so filtering is\n#&gt; disabled.\n#&gt; Warning: Some expressions had a GC in every iteration; so filtering is\n#&gt; disabled.\n\ndf_perf &lt;- tibble::tibble(\n  n = rep(10^(1:5), each = 2),\n  method = attr(performances$expression, \"description\"),\n  `time(s)` = performances$median / 100,\n  `memory(KB)` = as.numeric(bench::as_bench_bytes(performances$mem_alloc)) / 1024 / 1024\n) |&gt;\n  tidyr::pivot_longer(cols = c(`time(s)`, `memory(KB)`), names_to = \"type\", values_to = \"value\")\n\nlibrary(ggplot2)\nggplot(df_perf, aes(n, value, col = method)) +\n  geom_point(size = 2) +\n  geom_line(linetype = 2) +\n  scale_x_log10() +\n  facet_wrap(~type, scales = \"free_y\") +\n  labs(\n    x = \"Length of x\",\n    y = \"\",\n    color = \"Method\"\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n从结果中我们可以看到，随着要替换字符串的向量增加，无论是耗时还是内存占用，方法二都具有明显优势。\n\n\n\n Back to top"
  },
  {
    "objectID": "Books/Advanced R(2e)/11 Function operators.html",
    "href": "Books/Advanced R(2e)/11 Function operators.html",
    "title": "11 Function operators",
    "section": "",
    "text": "function operators 本质也是一个function factories，只是规定输入是一个函数。下面的简单示例——chatty()函数，接受一个函数f，返回一个能打印f的输入的函数。\n\nchatty &lt;- function(f) {\n  force(f)\n\n  function(x, ...) {\n    message(\"Processing \", x)\n    f(x, ...)\n  }\n}\nf &lt;- function(x) x^2\ns &lt;- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#&gt; Processing 3\n#&gt; Processing 2\n#&gt; Processing 1\n#&gt; [1] 9 4 1\n\nfunction operators 与 python 中的装饰器相同，遵循开放封闭原则，即对扩展开放，对修改封闭。它允许我们在不修改原有函数代码的情况下增加额外的功能，例如：为函数添加日志、权限检查、参数检查等多种功能，这使得代码更加模块化，易于维护和扩展。\n\n\n\n11.2节介绍一些极其有用的 function operators 函数。\n11.2节介绍如何根据实际问题，创建自己的 function operators 函数。\n\n\n\n\nfunction operators 本质是function factories，请先了解 function factory 函数。\n本章会用到purrr包中的泛函和其提供的function operators函数，及 memoise 包中的memoise()函数。\n\nlibrary(purrr)\nlibrary(memoise)",
    "crumbs": [
      "11 Function operators"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/11 Function operators.html#introduction",
    "href": "Books/Advanced R(2e)/11 Function operators.html#introduction",
    "title": "11 Function operators",
    "section": "",
    "text": "function operators 本质也是一个function factories，只是规定输入是一个函数。下面的简单示例——chatty()函数，接受一个函数f，返回一个能打印f的输入的函数。\n\nchatty &lt;- function(f) {\n  force(f)\n\n  function(x, ...) {\n    message(\"Processing \", x)\n    f(x, ...)\n  }\n}\nf &lt;- function(x) x^2\ns &lt;- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#&gt; Processing 3\n#&gt; Processing 2\n#&gt; Processing 1\n#&gt; [1] 9 4 1\n\nfunction operators 与 python 中的装饰器相同，遵循开放封闭原则，即对扩展开放，对修改封闭。它允许我们在不修改原有函数代码的情况下增加额外的功能，例如：为函数添加日志、权限检查、参数检查等多种功能，这使得代码更加模块化，易于维护和扩展。\n\n\n\n11.2节介绍一些极其有用的 function operators 函数。\n11.2节介绍如何根据实际问题，创建自己的 function operators 函数。\n\n\n\n\nfunction operators 本质是function factories，请先了解 function factory 函数。\n本章会用到purrr包中的泛函和其提供的function operators函数，及 memoise 包中的memoise()函数。\n\nlibrary(purrr)\nlibrary(memoise)",
    "crumbs": [
      "11 Function operators"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/11 Function operators.html#existing-function-operators",
    "href": "Books/Advanced R(2e)/11 Function operators.html#existing-function-operators",
    "title": "11 Function operators",
    "section": "Existing function operators",
    "text": "Existing function operators\n\nCapturing errors with purrr::safely()\n在使用map()等函数替代for-loop时，我们通常会困扰于：如果函数执行过程中发生错误，那么map()函数会直接停止，不会返回已运行成功的部分结果，而for-loop则会保留部分结果。\n\nx &lt;- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  \"oops\",\n  c(0.890, 0.785, 0.495)\n)\n\nout &lt;- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] &lt;- sum(x[[i]])\n}\n#&gt; Error in sum(x[[i]]): invalid 'type' (character) of argument\n\nout\n#&gt; [1] 1.394 1.272    NA    NA\n\nmap_dbl(x, sum)\n#&gt; Error in `map_dbl()`:\n#&gt; ℹ In index: 3.\n#&gt; Caused by error:\n#&gt; ! invalid 'type' (character) of argument\n\n上面的例子中，虽然最后会失败，但out会保留前面成功的结果，但map_dbl()则不会。如果我们使用safely()修改sum()，就会始终返回一个同时包含正确结果和错误信息的list。仔细观察结果，会进一步发现：for-loop在第三个循环失败后不再允许，map则会继续执行，它返回了第四个结果。\n\nout &lt;- map(x, safely(sum))\nstr(out)\n#&gt; List of 4\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 1.39\n#&gt;   ..$ error : NULL\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 1.27\n#&gt;   ..$ error : NULL\n#&gt;  $ :List of 2\n#&gt;   ..$ result: NULL\n#&gt;   ..$ error :List of 2\n#&gt;   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n#&gt;  $ :List of 2\n#&gt;   ..$ result: num 2.17\n#&gt;   ..$ error : NULL\n\n那么，safely()函数做了什么？打印safe_sum()，我们会发现它调用了capture_error()函数，捕获错误信息并返回。\n\nsafe_sum &lt;- safely(sum)\nsafe_sum\n#&gt; function (...) \n#&gt; capture_error(.f(...), otherwise, quiet)\n#&gt; &lt;bytecode: 0x5b42834be310&gt;\n#&gt; &lt;environment: 0x5b4283953338&gt;\n\nstr(safe_sum(x[[1]]))\n#&gt; List of 2\n#&gt;  $ result: num 1.39\n#&gt;  $ error : NULL\nstr(safe_sum(x[[3]]))\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n由于safely()后的函数始终返回一个list——包含两个元素：result，error，我们可以使用purrr::transpose()函数，将map()的输出结果转置，得到一个包含两个元素的list，第一个元素是正常结果，第二个元素是错误信息。\n\nout &lt;- transpose(map(x, safely(sum)))\nstr(out)\n#&gt; List of 2\n#&gt;  $ result:List of 4\n#&gt;   ..$ : num 1.39\n#&gt;   ..$ : num 1.27\n#&gt;   ..$ : NULL\n#&gt;   ..$ : num 2.17\n#&gt;  $ error :List of 4\n#&gt;   ..$ : NULL\n#&gt;   ..$ : NULL\n#&gt;   ..$ :List of 2\n#&gt;   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#&gt;   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#&gt;   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n#&gt;   ..$ : NULL\n\n现在我们可以轻易地找到结果和错误原因。\n\nok &lt;- map_lgl(out$error, is.null)\nok\n#&gt; [1]  TRUE  TRUE FALSE  TRUE\n\nx[!ok]\n#&gt; [[1]]\n#&gt; [1] \"oops\"\n\nout$result[ok]\n#&gt; [[1]]\n#&gt; [1] 1.394\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 1.272\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 2.17\n\nsafely()函数的使用场景有很多，我们可以总结出下面的使用规律：\nf &lt;- fcuntion (x, ...) {\n  # do something\n}\n\nout &lt;- transpose(map(x, safely(f)))\nok &lt;- map_lgl(out$error, is.null)\n\n# which data failed to converge?\nx[!ok]\n\n# which models were successful?\nout$result[ok]\n\n\nOther function operators in purrr\n\npossibly()：当函数报错时，返回默认值，无法判断是否发生了错误。\nquietly()：返回函数中除报错的其他信息。\n\n\nf &lt;- function() {\n  print(\"Hi!\")\n  message(\"Hello\")\n  warning(\"How are ya?\")\n  \"Gidday\"\n}\nf()\n#&gt; [1] \"Hi!\"\n#&gt; Hello\n#&gt; Warning in f(): How are ya?\n#&gt; [1] \"Gidday\"\n\nf_quiet &lt;- quietly(f)\nstr(f_quiet())\n#&gt; List of 4\n#&gt;  $ result  : chr \"Gidday\"\n#&gt;  $ output  : chr \"[1] \\\"Hi!\\\"\"\n#&gt;  $ warnings: chr \"How are ya?\"\n#&gt;  $ messages: chr \"Hello\\n\"\n\n\nas_browse()：当函数报错时，进入断点调试模式。\n\n\n\nCaching computations with memoise::memoise()\nmemoises 使函数可以缓存之前的输入和输出。这种缓存能力势必会增加内存的消耗，但却会提高计算的速度。\n\nslow_function &lt;- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#&gt; [1] 6.618483\n#&gt;    user  system elapsed \n#&gt;   0.000   0.000   1.001\n\nsystem.time(print(slow_function(1)))\n#&gt; [1] 0.8771143\n#&gt;    user  system elapsed \n#&gt;   0.001   0.001   1.003\n\n上面的例子中，每次运行结果都会不同，但是当被memoises后，第一次的结果就会被缓存，当输入相同时，就会直接返回缓存的结果。\n\nfast_function &lt;- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#&gt; [1] 2.950287\n#&gt;    user  system elapsed \n#&gt;   0.000   0.000   1.001\n\nsystem.time(print(fast_function(1)))\n#&gt; [1] 2.950287\n#&gt;    user  system elapsed \n#&gt;   0.009   0.000   0.009\n\n另外一个例子是计算斐波那契数列（f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)）。\n\nfib &lt;- function(n) {\n  if (n &lt; 2) {\n    return(n)\n  }\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#&gt;    user  system elapsed \n#&gt;   0.022   0.000   0.020\nsystem.time(fib(24))\n#&gt;    user  system elapsed \n#&gt;   0.027   0.004   0.029\n\n将fib()memoises化后， 当计算完fib2(23)后，fib2(24)的计算速度会非常快。\n\nfib2 &lt;- memoise::memoise(function(n) {\n  if (n &lt; 2) {\n    return(n)\n  }\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#&gt;    user  system elapsed \n#&gt;   0.005   0.000   0.004\nsystem.time(fib2(24))\n#&gt;    user  system elapsed \n#&gt;   0.000   0.001   0.000\n\n在动态规划中（dynamic programming），memoises更加常见。\n但在memoises化函数之前，要检查函数是否是pure的。",
    "crumbs": [
      "11 Function operators"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/11 Function operators.html#case-study-creating-your-own-function-operators",
    "href": "Books/Advanced R(2e)/11 Function operators.html#case-study-creating-your-own-function-operators",
    "title": "11 Function operators",
    "section": "Case study: Creating your own function operators",
    "text": "Case study: Creating your own function operators\n下面我们以一个下载数据的例子，介绍如何编写自己的function operator。\n假设你有很多书籍的网址，你想要下载这些书籍。使用前面章节中的walk2()和file.download()，可以简单地写为：\nurls &lt;- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\",\n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath &lt;- paste0(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\n上面的方法在urls不是很长时，确实足够。但当urls变得很长时，你就需要考虑：\n\n每本书下载后要添加一个延时，避免阻塞服务器。\n显示下载的进度。\n\n使用for-loop可以轻松解决上面两点，但for-loop将“下载”、“延时”，“显示进度”三个不同目的的东西都放在了一起，会让代码难于阅读。\nfor (i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], path[[i]], quiet = TRUE)\n}\n我们使用function operators来将这三个目的分开。首先创建“延时”函数delay_by()：接受两个参数——函数，延时时长\n\ndelay_by &lt;- function(f, amount) {\n  force(f)\n  force(amount)\n\n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#&gt;    user  system elapsed \n#&gt;       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#&gt;    user  system elapsed \n#&gt;     0.0     0.0     0.1\n\n将delay_by()应用到download.file()中：\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\n接下来创建“显示进度”函数dot_every()：接受两个参数——函数，显示点的间隔\n\ndot_every &lt;- function(f, n) {\n  force(f)\n  force(n)\n\n  i &lt;- 0\n  function(...) {\n    i &lt;&lt;- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#&gt; ..........\n\n将dot_every()应用到download.file()中：\nwalk2(\n  urls, path,\n  dot_every(delay_by(download.file, 0.1), 10),\n  quiet = TRUE\n)\n我们也可以使用管道符%&gt;%将函数串起来写：\nwalk2(\n  urls, path,\n  download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10),\n  quiet = TRUE\n)",
    "crumbs": [
      "11 Function operators"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Object-oriented Programming.html",
    "href": "Books/Advanced R(2e)/Object-oriented Programming.html",
    "title": "Introduction",
    "section": "",
    "text": "与其他语言相比，R 中的面向对象编程（object-oriented programming(OOP)）更有挑战性。\n在R语言中，泛函编程要比面向对象编程更重要，因为在解决复杂问题时，我们通常会使用多个函数而非多个对象进行解决。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Object-oriented Programming.html#outline",
    "href": "Books/Advanced R(2e)/Object-oriented Programming.html#outline",
    "title": "Introduction",
    "section": "Outline",
    "text": "Outline\n\n12章：介绍所有OOP系统依赖的底层概念——base types。\n13章：介绍S3系统。\n14章：介绍R6系统。\n15章：介绍S4系统。\n16章：对比三种OOP系统。\n\n本书侧重于OOP的“机制”，而非其“高效使用”。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Object-oriented Programming.html#oop-systems",
    "href": "Books/Advanced R(2e)/Object-oriented Programming.html#oop-systems",
    "title": "Introduction",
    "section": "OOP systems",
    "text": "OOP systems\n使用OOP系统的主要原因是——polymorphism或encapsulation。\n\npolymorphism：函数接受不同类型的输入，根据输入类型执行不同的操作，返回对应的结果。\nencapsulation：封装函数，隐藏数据，只提供接口，接口的调用者不需要知道数据如何实现。\n\npolymorphism在R中的直接感受就是——summary()函数可以根据输入类型的不同，返回不同结果。\n\ndiamonds &lt;- ggplot2::diamonds\n\nsummary(diamonds$carat)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;  0.2000  0.4000  0.7000  0.7979  1.0400  5.0100\n\nsummary(diamonds$cut)\n#&gt;      Fair      Good Very Good   Premium     Ideal \n#&gt;      1610      4906     12082     13791     21551\n\nOOP系统通过对象的class属性为对象分配其可用的方法method。class属性同时也定义了域field。class之间是层级结构，具有继承inherit关系，当对象所属的class没有定义method时，会向上查找父类中的method，这个过程叫做method dispatch。\n在R中主要有两种类型的OOP系统：\n\nencapsulated OOP：对象包含了数据（field）和方法（method），调用方法类似object.method(arg1, arg2)。\nfunctional OOP：方法属于泛型函数，使用方法与常规函数无异：generic(object, arg2, arg3)。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Object-oriented Programming.html#oop-in-r",
    "href": "Books/Advanced R(2e)/Object-oriented Programming.html#oop-in-r",
    "title": "Introduction",
    "section": "OOP in R",
    "text": "OOP in R\nbase R 提供了三种OOP系统：S3，S4，RC。\n\nS3系统会使函数返回丰富的结果，具有用户友好的显示和程序员友好的内部功能。S3系统贯穿于整个base R，因此如果你想扩展base R中的函数以处理新的输入类型，掌握S3系统非常重要。\nS4系统由method包支持，是一个严格的系统，会迫使你仔细思考程序设计。它特别适合构建随时间推移不断演变并且接受其他程序员贡献的的大型系统。它也是Bioconductor项目的主要框架。\nRC系统是一种特殊类型的S4系统，它们也可以被原地修改，但不使用R的“复制后修改”语义，实现了封装（encapsulated OOP）。\n\n其他R包提供的OOP系统：\n\nR6包系统提供了一种标准化的方式来规避R中的的“复制后修改”语义。这意味着在使用R6系统时，对象的属性不会被复制，而是直接引用原始数据；将对象传递给其他函数或程序，不需要担心它们被意外地修改。\nR.oo包提供了修改S3对象的机制。\nproto包提供了一种基于prototype思想的OOP系统，是ggplot2包使用的OOP。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Object-oriented Programming.html#sloop",
    "href": "Books/Advanced R(2e)/Object-oriented Programming.html#sloop",
    "title": "Introduction",
    "section": "sloop",
    "text": "sloop\n后续我们会经常使用到sloop(sail the seas of OOP)包，这个包提供了一些工具来查看R对象。例如sloop::otype()用来查看对象的OOP类型。\n\nlibrary(sloop)\n\notype(1:10)\n#&gt; [1] \"base\"\n\notype(mtcars)\n#&gt; [1] \"S3\"\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\notype(mle_obj)\n#&gt; [1] \"S4\"",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#object-styles",
    "href": "Books/Advanced R(2e)/13 S3.html#object-styles",
    "title": "13 S3",
    "section": "Object styles",
    "text": "Object styles\n这里用length()函数介绍一下不同类的方法风格。当length()函数作用于向量时，返回向量的长度。当作用在其他如dataframe类时，返回的是list的长度。\n\nRecord style object：list中的元素等长。例如POSIXlt类：\n\n\nx &lt;- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))\nx\n#&gt; [1] \"2020-01-01 00:00:01 CST\" \"2020-01-01 00:00:02 CST\"\n#&gt; [3] \"2020-01-01 00:00:03 CST\"\n\nlength(x)\n#&gt; [1] 3\nlength(unclass(x))\n#&gt; [1] 11\n\nx[[1]] # the first date time\n#&gt; [1] \"2020-01-01 00:00:01 CST\"\nunclass(x)[[1]] # the first component, the number of seconds\n#&gt; [1] 1 2 3\n\n\nData frame\n\n\nx &lt;- data.frame(x = 1:100, y = 1:100)\nlength(x)\n#&gt; [1] 2\nnrow(x)\n#&gt; [1] 100\n\n\nScalar object: 使用一个list表示一个单一的对象。例如：lm对象\n\n\nmod &lt;- lm(mpg ~ wt, data = mtcars)\nlength(mod)\n#&gt; [1] 12\n\n更多有关Object style2的内容可参考vctrs包。",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#inheritance",
    "href": "Books/Advanced R(2e)/13 S3.html#inheritance",
    "title": "13 S3",
    "section": "Inheritance",
    "text": "Inheritance\nS3类的方法“继承”有由下面三种方式实现：\n\nclass属性可以是一个向量。\n\n\nclass(ordered(\"x\"))\n#&gt; [1] \"ordered\" \"factor\"\nclass(Sys.time())\n#&gt; [1] \"POSIXct\" \"POSIXt\"\n\n\n如果第一个类（class向量）没有方法定义，R 会自动向下寻找。\n\n\ns3_dispatch(print(ordered(\"x\")))\n#&gt;    print.ordered\n#&gt; =&gt; print.factor\n#&gt;  * print.default\ns3_dispatch(print(Sys.time()))\n#&gt; =&gt; print.POSIXct\n#&gt;    print.POSIXt\n#&gt;  * print.default\n\n\n使用NextMethod()可以访委托方法给已存在的方法。\n\n\n# 注意`-&gt;`\ns3_dispatch(ordered(\"x\")[1])\n#&gt;    [.ordered\n#&gt; =&gt; [.factor\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\ns3_dispatch(Sys.time()[1])\n#&gt; =&gt; [.POSIXct\n#&gt;    [.POSIXt\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\nS3面向对象没有对子类和父类之间的关系施加限制，在创建一个子类时，推荐：\n\n子类的base type与父类保持一致\n子类的属性包含（继承）父类的属性\n\n\nNextMethod()\nNextMethod ()是继承中最难理解的部分，所以我们从一个最常用的[的具体示例开始。我们首先创建一个简单的类：一个在打印时隐藏其输出的秘密类：\n\nnew_secret &lt;- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret &lt;- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\nx &lt;- new_secret(c(15, 1, 456))\nx\n#&gt; [1] \"xx\"  \"x\"   \"xxx\"\n\n上面代码运行成功，但secret类没有定义[方法。\n\ns3_dispatch(x[1])\n#&gt;    [.secret\n#&gt;    [.default\n#&gt; =&gt; [ (internal)\nx[1]\n#&gt; [1] 15\n\n下面直接定义的[.secret方法会陷入无限循环：\n`[.secret` &lt;- function(x, i) {\n  new_secret(x[i])\n}\n我们需要额外的步骤，先去掉x的类属性，取完值后再重新定义类：\n\n`[.secret` &lt;- function(x, i) {\n  x &lt;- unclass(x)\n  new_secret(x[i])\n}\nx[1]\n#&gt; [1] \"xx\"\n\n上面的方法虽然有效，但会额外的创建x对象，造成资源浪费。更好的方法是使用NextMethod()方法。\n\n`[.secret` &lt;- function(x, i) {\n  new_secret(NextMethod())\n}\nx[1]\n#&gt; [1] \"xx\"\n\n\ns3_dispatch(x[1])\n#&gt; =&gt; [.secret\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\n=&gt;表示调用了[.secret, 但NextMethod()将方法委托于底层的内部[方法，如-&gt;所示。\nNextMethod()在寻找委托方法的类时，会根据全局变量.Class来判断，内部的类型改变无效，例如：下面的结果返回的是a2。\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\ngeneric2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n#&gt; [1] \"a2\"\n\n\n\nAllowing subclassing\n当你创建一个类时，你需要决定是否允许可以存在一个子类，因为允许子类会要求你再创建构造函数和方法时作出一些额外的工作。\n例如，允许子类后，父类的构造函数要添加额外的参数——...,class。\n\nnew_secret &lt;- function(x, ..., class = character()) {\n  stopifnot(is.double(x))\n\n  structure(\n    x,\n    ...,\n    class = c(class, \"secret\")\n  )\n}\n\n然后，子类的构造函数可以直接调用父类的构造函数，并添加额外的参数。\n\nnew_supersecret &lt;- function(x) {\n  new_secret(x, class = \"supersecret\")\n}\n\nprint.supersecret &lt;- function(x, ...) {\n  print(rep(\"xxxxx\", length(x)))\n  invisible(x)\n}\n\nx2 &lt;- new_supersecret(c(15, 1, 456))\nx2\n#&gt; [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n\n如果允许添加子类，方法同样需要额外的工作，否则方法始终返回父类。\n\n`[.secret` &lt;- function(x, ...) {\n  new_secret(NextMethod())\n}\nx2[1:3]\n#&gt; [1] \"xx\"  \"x\"   \"xxx\"\n\n\n`[.secret` &lt;- function(x, ...) {\n  new_secret(NextMethod(), class = class(x))\n}\nx2[1:3]\n#&gt; [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n\n我们也可以使用vctrs::vec_restore()泛型函数，为secret类添加不同类时的返回结果。\n\n# `to` 参数用来传递类的其他属性。\nvec_restore.secret &lt;- function(x, to, ...) new_secret(x)\nvec_restore.supersecret &lt;- function(x, to, ...) new_supersecret(x)\n\n`[.secret` &lt;- function(x, ...) {\n  vctrs::vec_restore(NextMethod(), x)\n}\nx2[1:3]\n#&gt; [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#dispatch-details",
    "href": "Books/Advanced R(2e)/13 S3.html#dispatch-details",
    "title": "13 S3",
    "section": "Dispatch details",
    "text": "Dispatch details\n\nS3 and base types\nS3面向对象系统中的泛型函数在作用于 base type 时，不会根据calss()返回的类进行方法派发。\n\nclass(matrix(1:5))\n#&gt; [1] \"matrix\" \"array\"\ns3_dispatch(print(matrix(1:5)))\n#&gt;    print.matrix\n#&gt;    print.integer\n#&gt;    print.numeric\n#&gt; =&gt; print.default\n\nx1 &lt;- 1:5\nclass(x1)\n#&gt; [1] \"integer\"\ns3_dispatch(mean(x1))\n#&gt;    mean.integer\n#&gt;    mean.numeric\n#&gt; =&gt; mean.default\n\nx2 &lt;- structure(x1, class = \"integer\")\nclass(x2)\n#&gt; [1] \"integer\"\ns3_dispatch(mean(x2))\n#&gt;    mean.integer\n#&gt; =&gt; mean.default\n\nbase type 的方法派发根据是其implicit class。implicit class 有三种组成：\n\n当对象有维度时，“array”, “matrix”。\ntypeof()的结果。\n当对象是”integer”或”double”时，“numeric”。\n\nimplicit class 只能由sloop::s3_class()获取。\n\ns3_class(matrix(1:5))\n#&gt; [1] \"matrix\"  \"integer\" \"numeric\"\n\n\n\nInternal generics\nbase R 中的一些函数，如[,sum(),cbind()等被称为internal generics。因为它们不使用UseMethod()，而是C语言中的DispatchGroup()或DispatchOrEval()。使用s3_dispatch()时，会显示为(internal)。\n\ns3_dispatch(Sys.time()[1])\n#&gt; =&gt; [.POSIXct\n#&gt;    [.POSIXt\n#&gt;    [.default\n#&gt; -&gt; [ (internal)\n\n\n\nGroup generics\nGroup generics 与 internal generics 类似，只存在于 base R 中，你自己无法构建。\nbase R 中存在4大类 Group generics：\n\nMath：abs(), sign(), sqrt(), floor(), cos(), sin(), log(), and more (see ?Math for the complete list).\nOps：+, -, *, /, ^, %%, %/%, &, |, !, ==, !=, &lt;, &lt;=, &gt;=, and &gt;.\nSummary：all(), any(), sum(), prod(), min(), max(), and range().\nComplex：Arg(), Conj(), Im(), Mod(), Re().\n\n当你为你的类定义了某个Group generic，这个Group generic内的所有方法都会被覆盖。当某个方法不存在时，会从组内寻找。\n\ns3_dispatch(sum(Sys.time()))\n#&gt;    sum.POSIXct\n#&gt;    sum.POSIXt\n#&gt;    sum.default\n#&gt; =&gt; Summary.POSIXct\n#&gt;    Summary.POSIXt\n#&gt;    Summary.default\n#&gt; -&gt; sum (internal)\n\n很多 Group generics 中都使用了NextMethod()。例如期，我们用abs()来计算一个difftime对象。\n\ny &lt;- as.difftime(10, units = \"mins\")\ns3_dispatch(abs(y))\n#&gt;    abs.difftime\n#&gt;    abs.default\n#&gt; =&gt; Math.difftime\n#&gt;    Math.default\n#&gt; -&gt; abs (internal)\n\nMath.difftime()大致如下：\nMath.difftime &lt;- function(x, ...) {\n  new_difftime(NextMethod(), units = attr(x, \"units\"))\n}\n\n\nDouble dispatch\nOps Group generics 使用了 double dispatch。这保证了a + b和b + a的计算结果一致。例如：\n\ndate &lt;- as.Date(\"2017-01-01\")\ninteger &lt;- 1L\n\ndate + integer\n#&gt; [1] \"2017-01-02\"\ninteger + date\n#&gt; [1] \"2017-01-02\"\n\n因为要同时为两种类进行方法派发，所以就会出现下面三种情况：\n\n如果方法相同，无所谓使用哪个方法。\n如果方法不同，R 最终回归到内部方法，并附带一个警告。\n如果有一个方法是“internal”，则R使用另外一种方法。",
    "crumbs": [
      "13 S3"
    ]
  },
  {
    "objectID": "Books/Js4R/11 Bidirectional Communication.html",
    "href": "Books/Js4R/11 Bidirectional Communication.html",
    "title": "11 Bidirectional Communication",
    "section": "",
    "text": "shiny 是R语言的web开发框架。它不仅可以像JavaScript那样运行在浏览器中，也可以与R后端进行交互。接下来一些章节的主要目的就是揭示通信的机制。本章首先介绍JavaScript如何嵌入到shiny程序中。"
  },
  {
    "objectID": "Books/Js4R/11 Bidirectional Communication.html#websocket-an-shiny",
    "href": "Books/Js4R/11 Bidirectional Communication.html#websocket-an-shiny",
    "title": "11 Bidirectional Communication",
    "section": "WebSocket an Shiny",
    "text": "WebSocket an Shiny\nshiny程序由两部分组成：前端UI和后端Server。二者通过WebSocket——持续传递信息的链接——进行沟通。在Server端，由“httpuv”包和“WebSocket”包管理链接；在前端，由JS进行管理。\n\n基于此，我们可以创建一个简单的shiny程序：\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  textInput(\"nameInput\", \"Name:\"),\n  textOutput(\"nameOutput\")\n)\n\nserver &lt;- function(input, output) {\n  output$nameOutput &lt;- renderText({\n    paste(\"Hello\", input$nameInput)\n  })\n}\n\nshinyApp(ui, server)\n上述shiny程序的UI与Server之间的逻辑关系图如下："
  },
  {
    "objectID": "Books/Js4R/11 Bidirectional Communication.html#sessions",
    "href": "Books/Js4R/11 Bidirectional Communication.html#sessions",
    "title": "11 Bidirectional Communication",
    "section": "Sessions",
    "text": "Sessions\n注意：shiny会将不同前端与Server之间的通信封装成一个session，每个session（用户）之间相互独立，互不影响。\n另外关于WebSocket，它通常应用在群发消息。"
  },
  {
    "objectID": "Books/Js4R/11 Bidirectional Communication.html#alertsan-example",
    "href": "Books/Js4R/11 Bidirectional Communication.html#alertsan-example",
    "title": "11 Bidirectional Communication",
    "section": "Alerts，an example",
    "text": "Alerts，an example\njBox是一种展示弹窗的插件，可以很方便地实现alert效果。\n我们将使用jBox库构建一个shiny程序——在单击actionButton时显示通知，并在关闭时 “告知” 服务器——以此解释WebSocket的双向通信。尽管本书介绍了如何包含JavaScript库依赖关系，但在本节 (且仅在本节) 中忽略。\n\nExplore\n下面我们创建了一个jBox的基础应用Html网页，当网页被打开时，会展示一个通知框（本网页也是如此）。\n&lt;!DOCTYPE html&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n&lt;head&gt;\n&lt;script\n  src=\"https://code.jquery.com/jquery-3.5.1.min.js\"&gt;\n  &lt;/script&gt;\n&lt;script\n  src=\"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/\n    dist/jBox.all.min.js\"&gt;\n&lt;/script&gt;\n&lt;link\n  href=\"https://cdn.jsdelivr.net/gh/StephanWagner/jBox@v1.2.0/\n    dist/jBox.all.min.css\"\n  rel=\"stylesheet\"&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- Script to show a notification --&gt;\n  &lt;script&gt;\n    new jBox('Notice', {\n      content: 'Hurray! A notice!'\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n下面，我们使用shiny程序来复现上面的alert。由于jQuery已经包含在shiny中，因此，我们不需要再引入jQuery。\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(\n      src = paste0(\n        \"https://cdn.jsdelivr.net/gh/StephanWagner/\",\n        \"jBox@v1.2.0/dist/jBox.all.min.js\"\n      )\n    ),\n    tags$link(\n      rel = \"stylesheet\",\n      href = paste0(\n        \"https://cdn.jsdelivr.net/gh/StephanWagner/\",\n        \"jBox@v1.2.0/dist/jBox.all.min.css\"\n      )\n    )\n  ),\n  tags$script(\"\n    new jBox('Notice', {\n      content: 'Hurray! A notice!'\n    });\")\n)\n\nserver &lt;- function(input, output) {}\n\nshinyApp(ui, server)\n\n\n\nFrom R to JavaScript"
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html",
    "href": "Books/Advanced R(2e)/14 R6.html",
    "title": "14 R6",
    "section": "",
    "text": "本章介绍R6 OOP系统，它有两大特点：\n\nR6使用了封装的OOP范式，意味着方法（method）属于对象（object）而不是泛型函数（generic），调用方法的范式为object$method()。\nR6对象是可改变的，意味着它们可以原地修改并具有引用语义。当你将一个R6对象赋值给另一个变量时，实际上是将指向该R6对象的引用来赋值给新变量。这样，任何对该对象所做的更改都会反映在所有引用它的变量中。\n\n虽然R6 OOP系统与其他语言中的OOP范式相同，使用起来更容易上手，但它缺点就是不符合R的使用习惯，我们将在第16章中讨论它们。\n\n\n\n14.2节：介绍使用R6::R6Class()创建R6类，使用构造器$new()创建新的R6对象。\n14.3节：讨论R6的访问机制：私有域和主动域。\n14.4节：探讨R6的引用语义的影响。学习如何使用终结器自动清理初始化器中执行的任何操作，以及如何在另一个R6对象中将一个R6对象作为字段使用。\n14.5节：对比R6系统和RC系统。\n\n\n\n\n\n# install.packages(\"R6\")\nlibrary(R6)",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html#introduction",
    "href": "Books/Advanced R(2e)/14 R6.html#introduction",
    "title": "14 R6",
    "section": "",
    "text": "本章介绍R6 OOP系统，它有两大特点：\n\nR6使用了封装的OOP范式，意味着方法（method）属于对象（object）而不是泛型函数（generic），调用方法的范式为object$method()。\nR6对象是可改变的，意味着它们可以原地修改并具有引用语义。当你将一个R6对象赋值给另一个变量时，实际上是将指向该R6对象的引用来赋值给新变量。这样，任何对该对象所做的更改都会反映在所有引用它的变量中。\n\n虽然R6 OOP系统与其他语言中的OOP范式相同，使用起来更容易上手，但它缺点就是不符合R的使用习惯，我们将在第16章中讨论它们。\n\n\n\n14.2节：介绍使用R6::R6Class()创建R6类，使用构造器$new()创建新的R6对象。\n14.3节：讨论R6的访问机制：私有域和主动域。\n14.4节：探讨R6的引用语义的影响。学习如何使用终结器自动清理初始化器中执行的任何操作，以及如何在另一个R6对象中将一个R6对象作为字段使用。\n14.5节：对比R6系统和RC系统。\n\n\n\n\n\n# install.packages(\"R6\")\nlibrary(R6)",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html#classes-and-methods",
    "href": "Books/Advanced R(2e)/14 R6.html#classes-and-methods",
    "title": "14 R6",
    "section": "Classes and methods",
    "text": "Classes and methods\nR6::R6Class()函数可以同时构建类（class）和方法（method），同时也是R6包中唯一需要使用的函数。\nR6Class()函数有两个极其重要的参数：\n\nclassname：类名，它不是必须的，但它改进了错误消息，并使得R6对象可以与S3类的泛型函数结合使用。R6 class名称通常使用UpperCamelCase命名法。\npublic：一个列表，包含类的属性（field）和方法，可以通过self$的方法获取。属性和方法通常使用snake_case命名法。\n\n\nAccumulator &lt;- R6Class(\n  classname = \"Accumulator\",\n  public = list(\n    sum = 0,\n    add = function(x = 1) {\n      self$sum &lt;- self$sum + x\n      invisible(self)\n    }\n  )\n)\n\n在使用R6Class()创建对象时，需要始终将创建的结果赋值给与类名相同的变量。\n\nAccumulator\n#&gt; &lt;Accumulator&gt; object generator\n#&gt;   Public:\n#&gt;     sum: 0\n#&gt;     add: function (x = 1) \n#&gt;     clone: function (deep = FALSE) \n#&gt;   Parent env: &lt;environment: R_GlobalEnv&gt;\n#&gt;   Locked objects: TRUE\n#&gt;   Locked class: FALSE\n#&gt;   Portable: TRUE\n\n可以使用object$new()的方法创建新对象。\n\nx &lt;- Accumulator$new()\n\n同样地，使用$获取对的属性和方法。\n\nx$add(4)\nx$sum\n#&gt; [1] 4\n\n后续我们以()区分$获取的时属性还是方法——$add()表示方法，$sum表示属性。\n\nMethod chaining\n当$add()方法返回的是self而不是$sum时，我们就可以使用方法链（method chaining），类似管道符。通常我们使用return()来返回，但鉴于self的隐私性，这里使用invisible()。\n\nx$add(10)$add(10)$sum\n#&gt; [1] 24\n\nx$\n  add(10)$\n  add(10)$\n  sum\n#&gt; [1] 44\n\n\n\nImportant methods\n对大多数R6对象，有两个重要的方法需要定义——$initialize()和$print()。它们非必须，但会提升对象的使用性。\n$initialize()方法会覆盖默认的$new()方法。例如下面的“Person”类，我在$initialize()方法中判断了$name属性只能是单一的字符串，$age属性只能是单一的数字。如果你有更多对输入的检查，将它们放在$validate()方法中更合适。\n\nPerson &lt;- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    stopifnot(is.character(name), length(name) == 1)\n    stopifnot(is.numeric(age), length(age) == 1)\n\n    self$name &lt;- name\n    self$age &lt;- age\n  }\n))\n\nhadley &lt;- Person$new(\"Hadley\", age = \"thirty-eight\")\n#&gt; Error in initialize(...): is.numeric(age) is not TRUE\n\nhadley &lt;- Person$new(\"Hadley\", age = 38)\n\n$print()方法会覆盖默认的print()方法，允许你自定义对象的打印输出。和其他R6对象的方法一样，最终使用invisible()来返回。\n\nPerson &lt;- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    self$name &lt;- name\n    self$age &lt;- age\n  },\n  print = function(...) {\n    cat(\"Person: \\n\")\n    cat(\"  Name: \", self$name, \"\\n\", sep = \"\")\n    cat(\"  Age:  \", self$age, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nhadley2 &lt;- Person$new(\"Hadley\")\nhadley2\n#&gt; Person: \n#&gt;   Name: Hadley\n#&gt;   Age:  NA\n\n\n\nAdding methods after creation\n可以使用$set()修改R6对象的属性和方法。\n\nAccumulator &lt;- R6Class(\"Accumulator\")\nAccumulator$set(\"public\", \"sum\", 0)\nAccumulator$set(\"public\", \"add\", function(x = 1) {\n  self$sum &lt;- self$sum + x\n  invisible(self)\n})\n\n需要注意：对象添加新的属性和方法后，只有用它创建新的对象时才会添加，已经创建好的对象不会添加新的属性和方法。\n\n\nInheritance\n参数inherit允许创建继承关系。\n\nAccumulatorChatty &lt;- R6Class(\n  \"AccumulatorChatty\",\n  inherit = Accumulator,\n  public = list(\n    add = function(x = 1) {\n      cat(\"Adding \", x, \"\\n\", sep = \"\")\n      super$add(x = x)\n    }\n  )\n)\n\nx2 &lt;- AccumulatorChatty$new()\nx2$add(10)$add(1)$sum\n#&gt; Adding 10\n#&gt; Adding 1\n#&gt; [1] 11\n\n拥有继承关系的子类可以使用父类的方法，但时如何名称相同发生覆盖，则需要使用suppe$来方法父类方法，这与上一章中的NextMethod()函数类似。\n\n\nIntrospection\n每一个R6对象中都含有一个S3类。这意味着我们可以对R6对象使用一些S3类常用的函数，上述提到的$print()方法，本质上是print.R6()函数。\nclass()可以确定是否属于R6类。\n\nclass(hadley2)\n#&gt; [1] \"Person\" \"R6\"\n\nnames()可以查看R6类的所有属性和方法名。下面的.__enclos_env__是R6内部的实现细节（R6 = S3 + env）。\n\nnames(hadley2)\n#&gt; [1] \".__enclos_env__\" \"age\"             \"name\"            \"clone\"          \n#&gt; [5] \"print\"           \"initialize\"\n\n\n\nExercises\n\nCreate a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.\n\n\n\nsolution\nBank &lt;- R6Class(\"Bank\", list(\n  name = \"\",\n  balance = 0,\n  initialize = function(name, balance = 0) {\n    stopifnot(is.character(name), length(name) == 1)\n    stopifnot(is.numeric(balance), length(balance) == 1)\n\n    self$name &lt;- name\n    self$balance &lt;- balance\n  },\n  print = function(...) {\n    cat(\"Bank: \\n\")\n    cat(\"  Name: \", self$name, \"\\n\", sep = \"\")\n    cat(\"  Balance:  \", self$balance, \"\\n\", sep = \"\")\n    invisible(self)\n  },\n  deposit = function(x) {\n    self$balance &lt;- self$balance + x\n    invisible(self)\n  },\n  withdraw = function(x) {\n    self$balance &lt;- self$balance - x\n    invisible(self)\n  }\n))\n\na &lt;- Bank$new(name = \"a\", balance = 1000)\na$deposit(500)$withdraw(2000)\na\n#&gt; Bank: \n#&gt;   Name: a\n#&gt;   Balance:  -500\n\nBank2 &lt;- R6Class(\"Bank2\", inherit = Bank, public = list(\n  withdraw = function(x) {\n    if (self$balance - x &lt; 0) {\n      stop(\"Insufficient funds\", call. = FALSE)\n    }\n  }\n))\n\nb &lt;- Bank2$new(name = \"b\", balance = 1000)\nb$deposit(500)$withdraw(2000)\n#&gt; Error: Insufficient funds\nb\n#&gt; Bank: \n#&gt;   Name: b\n#&gt;   Balance:  1500\n\nBank3 &lt;- R6Class(\"Bank3\", inherit = Bank, public = list(\n  withdraw = function(x) {\n    if (self$balance - x &lt; 0) {\n      message(\"charge of $5 applied\")\n      self$balance &lt;- self$balance - x - 5\n    }\n  }\n))\n\nc &lt;- Bank3$new(name = \"c\", balance = 1000)\nc$deposit(500)$withdraw(2000)\n#&gt; charge of $5 applied\nc\n#&gt; Bank: \n#&gt;   Name: c\n#&gt;   Balance:  -505\n\n\n\nCreate an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with $draw(n), and return all cards to the deck and reshuffle with $reshuffle(). Use the following code to make a vector of cards.\n\n\nsuit &lt;- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue &lt;- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards &lt;- paste0(rep(value, 4), suit)\n\n\n\nsolution\nShuffledDeck &lt;- R6Class(\n  classname = \"ShuffledDeck\",\n  public = list(\n    deck = NULL,\n    initialize = function(deck = cards) {\n      self$deck &lt;- sample(deck)\n    },\n    reshuffle = function() {\n      self$deck &lt;- sample(cards)\n      invisible(self)\n    },\n    n = function() {\n      length(self$deck)\n    },\n    draw = function(n = 1) {\n      if (n &gt; self$n()) {\n        stop(\"Only \", self$n(), \" cards remaining.\", call. = FALSE)\n      }\n\n      output &lt;- self$deck[seq_len(n)]\n      self$deck &lt;- self$deck[-seq_len(n)]\n      output\n    }\n  )\n)\n\nmy_deck &lt;- ShuffledDeck$new()\nmy_deck$draw(52)\n#&gt;  [1] \"A♠\"  \"A♦\"  \"3♠\"  \"J♣\"  \"10♥\" \"10♦\" \"J♠\"  \"3♥\"  \"8♦\"  \"K♠\"  \"9♣\"  \"4♠\" \n#&gt; [13] \"8♥\"  \"9♠\"  \"8♠\"  \"7♠\"  \"A♣\"  \"2♠\"  \"6♠\"  \"Q♥\"  \"4♣\"  \"Q♠\"  \"5♥\"  \"J♥\" \n#&gt; [25] \"6♦\"  \"Q♣\"  \"A♥\"  \"2♥\"  \"3♣\"  \"7♥\"  \"J♦\"  \"9♦\"  \"5♠\"  \"9♥\"  \"4♥\"  \"K♣\" \n#&gt; [37] \"10♠\" \"2♦\"  \"K♦\"  \"6♥\"  \"2♣\"  \"5♦\"  \"K♥\"  \"4♦\"  \"10♣\" \"7♣\"  \"3♦\"  \"5♣\" \n#&gt; [49] \"6♣\"  \"7♦\"  \"Q♦\"  \"8♣\"\nmy_deck$draw(10)\n#&gt; Error: Only 0 cards remaining.\nmy_deck$reshuffle()$draw(5)\n#&gt; [1] \"J♦\" \"K♠\" \"7♦\" \"9♦\" \"Q♦\"\nmy_deck$reshuffle()$draw(5)\n#&gt; [1] \"3♠\" \"K♥\" \"3♥\" \"5♣\" \"6♥\"",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html#controlling-access",
    "href": "Books/Advanced R(2e)/14 R6.html#controlling-access",
    "title": "14 R6",
    "section": "Controlling access",
    "text": "Controlling access\nR6Class()函数有两个与public参数类似的参数：\n\nprivate：创建的R6对象的私有属性和方法，只允许对象内部访问。\nactive：创建的R6对象的动态属性，通过 accessor 函数访问。\n\n\nPrivacy\nprivate参数创建的私有属性和方法有两个特点：\n\n创建方式与public参数一样，都是一个带有name的list。\n在对象内部调用时，需要使用private$前缀。\n\n下面是一个私有属性示例：\n\nPerson &lt;- R6Class(\"Person\",\n  public = list(\n    initialize = function(name, age = NA) {\n      private$name &lt;- name\n      private$age &lt;- age\n    },\n    print = function(...) {\n      cat(\"Person: \\n\")\n      cat(\"  Name: \", private$name, \"\\n\", sep = \"\")\n      cat(\"  Age:  \", private$age, \"\\n\", sep = \"\")\n    }\n  ),\n  private = list(\n    age = NA,\n    name = NULL\n  )\n)\n\nhadley3 &lt;- Person$new(\"Hadley\")\nhadley3\n#&gt; Person: \n#&gt;   Name: Hadley\n#&gt;   Age:  NA\nhadley3$name\n#&gt; NULL\n\n相交于其他语言，私有方法在R语言中通常不是很重要。\n\n\nActive fields\n动态属性看起来像是公共属性，但实际是由一个active binding函数定义。active binding函数只有一个参数value，如果参数missing(), 则检索该值；否则，将对其进行修改。\n下例定义了动态属性random，每次访问时，会返回一个随机数。\n\nRando &lt;- R6::R6Class(\"Rando\", active = list(\n  random = function(value) {\n    if (missing(value)) {\n      runif(1)\n    } else {\n      stop(\"Can't set `$random`\", call. = FALSE)\n    }\n  }\n))\nx &lt;- Rando$new()\nx$random(3)\n#&gt; Error: attempt to apply non-function\nx$random\n#&gt; [1] 0.03992385\nx$random &lt;- 31\n#&gt; Error: Can't set `$random`\n\n动态属性可以使静态属性看起来像公共属性。例如下例中，我们创建了只读的属性age和能确保字符串长度为1的属性name。\n\nPerson &lt;- R6Class(\"Person\",\n  private = list(\n    .age = NA,\n    .name = NULL\n  ),\n  active = list(\n    age = function(value) {\n      if (missing(value)) {\n        private$.age\n      } else {\n        stop(\"`$age` is read only\", call. = FALSE)\n      }\n    },\n    name = function(value) {\n      if (missing(value)) {\n        private$.name\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.name &lt;- value\n        self\n      }\n    }\n  ),\n  public = list(\n    initialize = function(name, age = NA) {\n      private$.name &lt;- name\n      private$.age &lt;- age\n    }\n  )\n)\n\nhadley4 &lt;- Person$new(\"Hadley\", age = 38)\nhadley4$name\n#&gt; [1] \"Hadley\"\nhadley4$name &lt;- \"Hadley2\"\nhadley4$name &lt;- 10\n#&gt; Error in (function (value) : is.character(value) is not TRUE\nhadley4$age &lt;- 20\n#&gt; Error: `$age` is read only\n\n子类无法访问到父类的私有属性，但是可以访问到父类的私有方法：\n\nA &lt;- R6Class(\n  classname = \"A\",\n  private = list(\n    field = \"foo\",\n    method = function() {\n      \"bar\"\n    }\n  )\n)\n\nB &lt;- R6Class(\n  classname = \"B\",\n  inherit = A,\n  public = list(\n    test = function() {\n      cat(\"Field:  \", super$field, \"\\n\", sep = \"\")\n      cat(\"Method: \", super$method(), \"\\n\", sep = \"\")\n    }\n  )\n)\n\nB$new()$test()\n#&gt; Field:  \n#&gt; Method: bar",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html#reference-semantics",
    "href": "Books/Advanced R(2e)/14 R6.html#reference-semantics",
    "title": "14 R6",
    "section": "Reference semantics",
    "text": "Reference semantics\nR6 OOP系统与其他系统的最大不同就是它的引用语义。引用语义意味着对象被修改时不会被复制。\n\ny1 &lt;- Accumulator$new()\ny2 &lt;- y1\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#&gt; y1 y2 \n#&gt; 10 10\n\n如果你想要复制对象，你需要使用$clone()方法，添加参数deep = TRUE可以克隆嵌套的对象。\n\ny1 &lt;- Accumulator$new()\ny2 &lt;- y1$clone()\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#&gt; y1 y2 \n#&gt; 10  0\n\n引用语义的使用同样会带来其他结果：\n\n需要更多的上下文才能理解R6对象。\n考虑何时删除 R6对象是有意义的，你可以编写$finalize()来补充$initialize()，。\n如果某个属性是R6对象，则必须在$initialize()中创建它，而不是在R6Class()中。\n\n\nReasoning\n通常，参考语义会导致代码更难推理。考虑下面的例子：\nx &lt;- list(a = 1)\ny &lt;- list(b = 2)\n\nz &lt;- f(x, y)\n因为函数f内部无法修改外部的x,y，所以我们知道函数f只修改了z。\n但是想象x,y是一个R6对象：\nx &lt;- List$new(a = 1)\ny &lt;- List$new(b = 2)\n\nz &lt;- f(x, y)\n函数f内部可以调用x和y内部的属性或方法，并对它们进行修改。我们无法仅从z &lt;- f(x, y)判断函数f是否修改了x,y，我们需要查看函数f内部的代码。\n\n\nFinalizer\n因为R6对象具有引用语义，所以删除一次就会完全删除对象（不发生修改即拷贝）。这意味着我们可以在R6对象被删除时，使用$finalize()执行某些清理工作（类似on.exit()），来补充$initialize()。如下例中，我们实例化一个创建临时文件对象，然后删除该实例，就会删除临时文件。\n\nTemporaryFile &lt;- R6Class(\n  \"TemporaryFile\",\n  public = list(\n    path = NULL,\n    initialize = function() {\n      self$path &lt;- tempfile()\n    }\n  ),\n  private = list(\n    finalize = function() {\n      message(\"Cleaning up \", self$path)\n      unlink(self$path)\n    }\n  )\n)\n\ntf &lt;- TemporaryFile$new()\nrm(tf)\ngc() # 使用gc()才会触发，书中好像是rm(tf)就会触发。\n#&gt;           used (Mb) gc trigger (Mb) max used (Mb)\n#&gt; Ncells  854387 45.7    1706974 91.2  1120485 59.9\n#&gt; Vcells 1702525 13.0    8388608 64.0  2908954 22.2\n\n\n\nR6 fields\n当使用R6类作为另外一个R6类的属性时，必须在$initialize方法中初始化属性。因为在外部定义的属性，表示该属性在定义R6类时已经创建，后续的所有实例都会继承这个属性。例如下面案例：我们想每次创建临时数据库时都创建一个临时文件，如果在外部定义属性file，实例db_a和db_b都会继承这个属性，这样db_a和db_b的属性file都指向同一个文件。\n\nTemporaryDatabase &lt;- R6Class(\n  \"TemporaryDatabase\",\n  public = list(\n    con = NULL,\n    file = TemporaryFile$new(),\n    initialize = function() {\n      self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n    }\n  ),\n  private = list(\n    finalize = function() {\n      DBI::dbDisconnect(self$con)\n    }\n  )\n)\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] TRUE\n\n相反，使用$initialize()方法，在创建实例时，始终会重新创建属性file。\n\nTemporaryDatabase &lt;- R6Class(\n  \"TemporaryDatabase\",\n  public = list(\n    con = NULL,\n    file = NULL,\n    initialize = function() {\n      self$file &lt;- TemporaryFile$new()\n      self$con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n    }\n  ),\n  private = list(\n    finalize = function() {\n      DBI::dbDisconnect(self$con)\n    }\n  )\n)\n\ndb_a &lt;- TemporaryDatabase$new()\ndb_b &lt;- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#&gt; [1] FALSE",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/14 R6.html#why-r6",
    "href": "Books/Advanced R(2e)/14 R6.html#why-r6",
    "title": "14 R6",
    "section": "Why R6?",
    "text": "Why R6?\nR6 OOP系统相较于 RC OOP系统的一些优势：\n\nR6 更简单。R6 基于S3，RC 基于S4。\nR6 有全面的文档。https://r6.r-lib.org/\nR6 提供了一种更简单的跨包子类化机制，这种机制无需思考就能正常工作。\nR6 对属性方法的管理更加明确。\nR6 更快。\nRC 与 base R 绑定，意味着你需要修改不同R版本的bug。",
    "crumbs": [
      "14 R6"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html",
    "href": "Books/Advanced R(2e)/15 S4.html",
    "title": "15 S4",
    "section": "",
    "text": "S4 是一种更规范的基于泛型函数的面向对象系统。其底层思想与S3类似，但是有更严格的函数去创建类、泛型函数、方法——setClass()，setGeneric()，setMethod()。此外，S4 OOP 提供更多的继承和方法派发。\nS4 与S3 相比，还多了一个新的内容——slot（槽），使用特殊操作符@提取。\n\n\n\n15.2节：简要概述 S4 的主要组成部分：类、泛型函数和方法\n15.3节：深入 S4 “类”的细节，包括原型、构造函数、辅助函数和验证函数。\n15.4节：介绍如何创建新的 S4 “泛型函数”，以及如何为这些泛型函数提供方法；介绍访问器函数——旨在允许用户安全地检查和修改对象槽。\n15.5节：深入 S4 中“方法多分派”的全部细节。\n15.6节：讨论 S4 和 S3 之间的相互作用，及如何一起使用它们。\n\n\n\n\n与前几章类似，我们只关注S4 OOP如何工作，如何高效的使用它不在次范围内。在实践中，你需要额外注意：\n\n没有一本书可以回答你所有关于S4的问题。\nR的内置文档有时会与社区最佳实践发生冲突。\n\n在实践中，你需要仔细阅读文档，不断提问，多次实验。\n\n\n\n所有S4 OOP相关的函数都由“methods”包提供。虽然该包总是会在终端交互时加载，但当使用Rscritp时则不会，所以当我们使用S4 OOP时，最好加载它。\n\nlibrary(methods)",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#introduction",
    "href": "Books/Advanced R(2e)/15 S4.html#introduction",
    "title": "15 S4",
    "section": "",
    "text": "S4 是一种更规范的基于泛型函数的面向对象系统。其底层思想与S3类似，但是有更严格的函数去创建类、泛型函数、方法——setClass()，setGeneric()，setMethod()。此外，S4 OOP 提供更多的继承和方法派发。\nS4 与S3 相比，还多了一个新的内容——slot（槽），使用特殊操作符@提取。\n\n\n\n15.2节：简要概述 S4 的主要组成部分：类、泛型函数和方法\n15.3节：深入 S4 “类”的细节，包括原型、构造函数、辅助函数和验证函数。\n15.4节：介绍如何创建新的 S4 “泛型函数”，以及如何为这些泛型函数提供方法；介绍访问器函数——旨在允许用户安全地检查和修改对象槽。\n15.5节：深入 S4 中“方法多分派”的全部细节。\n15.6节：讨论 S4 和 S3 之间的相互作用，及如何一起使用它们。\n\n\n\n\n与前几章类似，我们只关注S4 OOP如何工作，如何高效的使用它不在次范围内。在实践中，你需要额外注意：\n\n没有一本书可以回答你所有关于S4的问题。\nR的内置文档有时会与社区最佳实践发生冲突。\n\n在实践中，你需要仔细阅读文档，不断提问，多次实验。\n\n\n\n所有S4 OOP相关的函数都由“methods”包提供。虽然该包总是会在终端交互时加载，但当使用Rscritp时则不会，所以当我们使用S4 OOP时，最好加载它。\n\nlibrary(methods)",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#basics",
    "href": "Books/Advanced R(2e)/15 S4.html#basics",
    "title": "15 S4",
    "section": "Basics",
    "text": "Basics\n\nsetClass()\nsetClass()可以定义一个类——类名和槽。在数据槽中可以规定数据类型和名字。\n\nsetClass(\n  \"Person\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  )\n)\n\n类定义完毕后，可以使用new()函数实例化一个对象。\n\njohn &lt;- new(\"Person\", name = \"John Smith\", age = NA_real_)\n\n使用is()函数检查对象的类名；使用@或slot()函数获取对象中的槽值。\n\nis(john)\n#&gt; [1] \"Person\"\njohn@name\n#&gt; [1] \"John Smith\"\nslot(john, \"age\")\n#&gt; [1] NA\n\n\n\nsetGeneric()\nsetGeneric()可以定义一个泛型函数。我们可以创建一个提取年龄信息的泛型函数。\n\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\n#&gt; [1] \"age\"\nsetGeneric(\"age&lt;-\", function(x, value) standardGeneric(\"age&lt;-\"))\n#&gt; [1] \"age&lt;-\"\n\n\n\nsetMethod()\nsetMethod()可以定义一个方法。我们根据上面的泛型方法，定义属于Person类的age方法。\n\nsetMethod(\"age\", \"Person\", function(x) x@age)\nsetMethod(\"age&lt;-\", \"Person\", function(x, value) {\n  x@age &lt;- value\n  x\n})\n\nage(john) &lt;- 18\nage(john)\n#&gt; [1] 18\n\n假设Person类属于某个R包，你可以使用class?Person来获取该类的帮助文档。在方法调用前添加?，如?age(john)，可以获取方法的帮助文档。\n最后，你可以使用“sloop”包中的函数检查类和泛型函数。\n\nsloop::otype(john)\n#&gt; [1] \"S4\"\nsloop::ftype(age)\n#&gt; [1] \"S4\"      \"generic\"",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#classes",
    "href": "Books/Advanced R(2e)/15 S4.html#classes",
    "title": "15 S4",
    "section": "Classes",
    "text": "Classes\n定义S4类时，通常要设定setClass()中的三个参数：\n\nclass name：类名，通常类名使用UpperCamelCase。\nslots：一个有name属性的字符串向量，描述了槽的名字和数据类型。ANY可以表示任意类型数据。\nprototype：一个有name属性的列表，记录了每个槽中的默认值。\n\n\nsetClass(\n  \"Person\",\n  slots = c(\n    name = \"character\",\n    age = \"numeric\"\n  ),\n  prototype = c(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nme &lt;- new(\"Person\", name = \"James\")\nstr(me)\n#&gt; Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#&gt;   ..@ name: chr \"James\"\n#&gt;   ..@ age : num(0) \n#&gt;   ..$ names: chr [1:2] \"name\" \"age\"\n\n\nInheritance\nsetClass()中的contains参数可以指定一个类，表示当前类继承自该类。例如，我们可以创建一个Employee类，继承自Person类，添加额外槽boss。\n\nsetClass(\n  \"Employee\",\n  contains = \"Person\",\n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nstr(new(\"Employee\"))\n#&gt; Formal class 'Employee' [package \".GlobalEnv\"] with 3 slots\n#&gt;   ..@ boss:Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#&gt;   .. .. ..@ name: chr(0) \n#&gt;   .. .. ..@ age : num(0) \n#&gt;   .. .. ..$ names: chr [1:2] \"name\" \"age\"\n#&gt;   ..@ name: chr(0) \n#&gt;   ..@ age : num(0)\n\nSetClass()还有9个其他参数，但这些参数要么已被弃用，要么不推荐使用。\n\n\nIntrospection\nis()可以查看对象所属的类及其继承类。\n\nis(new(\"Person\"))\n#&gt; [1] \"Person\"\nis(new(\"Employee\"))\n#&gt; [1] \"Employee\" \"Person\"\n\n此外，还可以用作判断函数。\n\nis(john, \"Person\")\n#&gt; [1] TRUE\n\n\n\nRedefinition\n因为类与对象的定义都是环境中的一个变量，所以在实例化一个类的对象后，依然可以重新定义这个类，此时要注意已经实例化的对象可能无效。\n\nsetClass(\"A\", slots = c(x = \"numeric\"))\na &lt;- new(\"A\", x = 10)\n\nsetClass(\"A\", slots = c(a_different_slot = \"numeric\"))\na\n#&gt; An object of class \"A\"\n#&gt; Slot \"a_different_slot\":\n#&gt; Error in slot(object, what): no slot of name \"a_different_slot\" for this object of class \"A\"\n\n\n\nHelper\nnew()函数是一种非常原始的实例化函数，很适合开发者；但对于使用者来说，new()函数不太友好，我们需要一个面向用户的辅助函数，更好的实例化对象。辅助函数应始终：\n\n使用与类相同的名称，例如myclass()。\n精心设计的用户界面，包含精心选择的默认值和有用的转换。\n为最终用户创建精心设计的错误消息。\n最后调用ethods::new()。\n\n我们可以创建为“Person”类创建一个简单的辅助函数：\n\nPerson &lt;- function(name, age = NA) {\n  age &lt;- as.double(age)\n\n  new(\"Person\", name = name, age = age)\n}\n\nPerson(\"Hadley\")\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] NA\n\n\n\nValidator\nS4类的构造函数会根据slots中的类型进行验证。\n\nPerson(mtcars)\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: invalid object for slot \"name\" in class \"Person\": got class \"data.frame\", should be or extend class \"character\"\n\n但有时我们需要做出更多的判断，例如假设你想让“Person”类可以接受多个“人”的名字和年龄，那么名字和年龄的长度应该一致。\n\nPerson(\"Hadley\", age = c(30, 37))\n#&gt; An object of class \"Person\"\n#&gt; Slot \"name\":\n#&gt; [1] \"Hadley\"\n#&gt; \n#&gt; Slot \"age\":\n#&gt; [1] 30 37\n\n此时我们需要使用setValidity()方法来定义额外的验证逻辑。setValidity()方法接收两个参数——类名和验证函数，最终返回一个字符串信息（未通过）或TRUE（通过）。\n\nsetValidity(\"Person\", function(object) {\n  if (length(object@name) != length(object@age)) {\n    \"@name and @age must be same length\"\n  } else {\n    TRUE\n  }\n})\n#&gt; Class \"Person\" [in \".GlobalEnv\"]\n#&gt; \n#&gt; Slots:\n#&gt;                           \n#&gt; Name:       name       age\n#&gt; Class: character   numeric\n#&gt; \n#&gt; Known Subclasses: \"Employee\"\n\n现在，Person()构造函数会返回错误信息。\n\nPerson(\"Hadley\", age = c(30, 37))\n#&gt; Error in validObject(.Object): invalid class \"Person\" object: @name and @age must be same length\n\n但是要注意，此时验证函数依然只能通过函数new()来触发，在修改对象槽值时，验证函数不会被触发。只能使用validObject()函数来检查对象。\n\nalex &lt;- Person(\"Alex\", age = 30)\nalex@age &lt;- 1:10\n\nvalidObject(alex)\n#&gt; Error in validObject(alex): invalid class \"Person\" object: @name and @age must be same length",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#generics-and-methods",
    "href": "Books/Advanced R(2e)/15 S4.html#generics-and-methods",
    "title": "15 S4",
    "section": "Generics and methods",
    "text": "Generics and methods\n创建新的S4类的泛型函数的方式为：在setGeneric()函数中调用standardGeneric()函数。\nsetGeneric(\"myGeneric\", function(x) standardGeneric(\"myGeneric\"))\n通常规定，新的泛型函数名采用lowerCamelCase命名方式。\n同时，不要在泛型函数中使用{}，因为这会触发一种特殊情况，只要必要时才会这样做。\n# Don't do this!\nsetGeneric(\"myGeneric\", function(x) {\n  standardGeneric(\"myGeneric\")\n})\n\nSignature\n与setClass()函数类似，setGeneric()函数同样拥有很多参数，但只需了解signature参数即可，该参数控制了方法派发。该参数的值来源只能是函数参数，若未指定，则会使用除...外所有的函数参数。在派发过程中，使用的是参数的类信息，如果你有类似verbose = TRUE或quiet = FALSE等无需参与方法派发的参数，最好为signature参数提供具体值。\nsetGeneric(\"myGeneric\",\n  function(x, ..., verbose = TRUE) standardGeneric(\"myGeneric\"),\n  signature = \"x\"\n)\n\n\nMethods\n使用setMethod()函数可以创建S4类的方法，该函数有三个参数：泛型函数、singnature、函数定义，其余参数无需了解。此处的“signature”用来规定函数中的参数x的类（可以是多个）。与S3不同，S4的方法派发根据signature会有多种形式。我们将在下一节中详细介绍方法派发。\nsetMethod(\"myGeneric\", \"Person\", function(x) {\n  # method implementation\n})\n要列出属于某个泛型函数或与类关联的所有方法，可以使用methods(\"generic\")或methods(class = \"class\")；要查找特定方法的实现，可以使用selectMethod(\"generic\", \"class\")。\n\n\nShow method\nS4类有一些通用的泛型函数，如show，用于控制对象打印的信息。可以查看文档或使用args(getGeneric(\"show\"))查看参数。\n\nargs(getGeneric(\"show\"))\n#&gt; function (object) \n#&gt; NULL\n\n可以看到“show”方法接受唯一的参数——对象本身。\n\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n    \"  Name: \", object@name, \"\\n\",\n    \"  Age:  \", object@age, \"\\n\",\n    sep = \"\"\n  )\n})\njohn\n#&gt; Person\n#&gt;   Name: John Smith\n#&gt;   Age:  18\n\n\n\nAccessors\n始终应该为slot中的值提供访问器函数，方便访问与修改。\n如果只有一个槽，访问器函数可以是：\nperson_name &lt;- function(x) {x@name}\n也可以通过泛型函数定义，使得多个类可以同时使用：\n\nsetGeneric(\"name\", function(x) standardGeneric(\"name\"))\n#&gt; [1] \"name\"\nsetMethod(\"name\", \"Person\", function(x) x@name)\n\nname(john)\n#&gt; [1] \"John Smith\"\n\n如果需要修改槽的值，还需要定义一个能修改值的访问器函数，函数在返回对象前执行validObject()检查。\n\nsetGeneric(\"name&lt;-\", function(x, value) standardGeneric(\"name&lt;-\"))\n#&gt; [1] \"name&lt;-\"\nsetMethod(\"name&lt;-\", \"Person\", function(x, value) {\n  x@name &lt;- value\n  validObject(x)\n  x\n})\n\nname(john) &lt;- \"Jon Smythe\"\nname(john)\n#&gt; [1] \"Jon Smythe\"\n\nname(john) &lt;- letters\n#&gt; Error in validObject(x): invalid class \"Person\" object: @name and @age must be same length\n\n\n\n\n\n\n\nWarning\n\n\n\n直接使用class@slot &lt;- value的方式也可以修改槽的值，但会忽略validObject()检查。\n\njohn@name &lt;- letters\nname(john)\n#&gt;  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\"\n#&gt; [19] \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#method-dispatch",
    "href": "Books/Advanced R(2e)/15 S4.html#method-dispatch",
    "title": "15 S4",
    "section": "Method dispatch",
    "text": "Method dispatch\nS4 OOP中的方法派发极其复杂，因为：\n\n多种继承：例如一个类可以继承多个类。\n多种派发方法：例如一个泛型函数可以根据多个参数来派发方法。\n\nS4类的特点使得其很强大，但也使其很难理解。在实践中，除非必要，我们要尽可能避免使用多种继承和多种派发方法。\n我们将使用一个基于表情符号的虚拟类图，从单一的继承与派发到多个继承与派发，逐步介绍S4类中的方法派发。\n\n😜继承自😉，😉继承自😶；😎继承自🕶和🙂。\n\nSingle dispatch\n让我们以基于某个继承单一的类为例，介绍方法派发的过程。\n\n上面的模式图由两部分构成：\n\n顶部，f(...)中的参数类型，定义了派发的逻辑图。图中的参数只有一个且单一继承了其他类，深度是2。\n底部，展示了所有可能被定义的方法间的关系。我们假定如果方法被定义，则背景色为灰色。\n\n方法派发的实际过程就是从实际参数中最具体的类开始，然后跟随箭头，直到找到一个存在的方法。例如你想找到😜的方法，跟随箭头最终找到的是它的父类😶的方法。如果没有找到方法，R会抛出错误，表示方法派发失败。这意味着，你必须为最终的类定义一个方法。\nS4类中有两个“伪类”（pseudo-classes）用来定义方法。被称为“伪类”是因为它们不是真实存在，但你可以为它们定义方法。\n第一个伪类是ANY，它表示任何类，同时某个类与ANY的距离比其与其他类的距离都要大，用来准确地派发方法。\n\n第二个伪类是MISSING。如果你为该类定义了某个方法，那么这个方法可以匹配任何没有参数的泛函。它在“single dispatch”模式下没有用，主要用于类似+,-等“double dispatch”模式下。\n\n\nMultiple dispatch\n当类的继承有多个时，方法派发会变得复杂起来。\n\n派发的原理与单一继承类似——从初始类开始，沿着箭头向右寻找，直到找到一个方法；区别在于，可能找到多个方法，此时会选择最近的一个方法（例如，箭头数最少）。需要注意的是，真实的方法派发逻辑不是我们图中“箭头”组成的“图”。\n假如出现距离相同，如下：🕶和🙂都有定义的方法而且😶没有方法，此时，R 会按照字母顺序选择方法。图中红色双线框表示没有方法，虚线框表示方法模糊。\n\n当这种情况发生时，应当为该类提供一个准确的方法。\n\n如果最终找到的是ANY类的方法，因为ANY类与其他类的距离相比真实类间的距离更远，所以永远不会产生歧义。\n\n使用多重继承时，很难防止歧义，需要谨慎使用，尽可能减少方法数量，并根据图进行规划。例如下图中，只有两种符合数量尽可能少（左上，右上？），而且只有一种没有问题（右上？）。\n\n\n\nMultiple dispatch\n一旦你理解了多重继承，多重派发就会很直观，只是每个方法都需要两个类去调用。\n\n下面是一个方法歧义的示意图。\n\n实际上，多重派发要比多重继承更容易处理，因为它的终端类组合数量更少。\n\n\nMultiple dispatch and multiple inheritance\n当然，我们也可以将多重派发与多重继承组合起来使用。\n\n一个更复杂的案例分发到两个类，这两个类都具有多重继承：\n\n随着方法图变得越来越复杂，在给定输入组合的情况下，预测哪个方法将被调用变得越来越困难，同时也越来越难以确保你没有引入歧义。如果你不得不绘制图表来确定实际将被调用的方法，这强烈表明你应该回过头来简化你的设计。",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/15 S4.html#s4-and-s3",
    "href": "Books/Advanced R(2e)/15 S4.html#s4-and-s3",
    "title": "15 S4",
    "section": "S4 and S3",
    "text": "S4 and S3\nS4类可以与已存在的S3类进行交互。\n\nClasses\nsetClass()函数的参数slots,contains可以使用S4类或S3类，甚至implicit类。\n在使用S3类前，必须使用setOldClass()函数来重定义S3类。定义声明只需一次即可，例如下面是被base R重定义的S3类：\nsetOldClass(\"data.frame\")\nsetOldClass(c(\"ordered\", \"factor\"))\nsetOldClass(c(\"glm\", \"lm\"))\n你也可以使用setClass()函数来重定义S3类，提供更具体地描述。\nsetClass(\"factor\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character()\n  )\n)\nsetOldClass(\"factor\", S4Class = \"factor\")\n注意：对S3类的重定义行为通常由S3类的拥有者提供。例如，如果你想在某个S3类的基础上定义S4类，你需要让S3类的拥有者提供重定义行为。\n如果S4类继承于某个S3类或base type，那么该S4类的实例化对象中会自动添加.Data槽，用来存放原始数据。\n\nRangedNumeric &lt;- setClass(\n  \"RangedNumeric\",\n  contains = \"numeric\",\n  slots = c(min = \"numeric\", max = \"numeric\"),\n  prototype = structure(numeric(), min = NA_real_, max = NA_real_)\n)\nrn &lt;- RangedNumeric(1:10, min = 1, max = 10)\nrn@min\n#&gt; [1] 1\nrn@.Data\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n你也可以为S4类定义S3类型的方法，反之亦然（使用setOldClass()）。阅读?Methods_for_S3了解更多信息。\n\n\nGenerics\n使用setGeneric()还可以将S3类的泛型函数转换为S4类的泛型函数。\n\nsetGeneric(\"mean\")\n#&gt; [1] \"mean\"\n\n这种情况下，mean()函数会变为ANY类的默认方法。\n\nselectMethod(\"mean\", \"ANY\")\n#&gt; Method Definition (Class \"derivedDefaultMethod\"):\n#&gt; \n#&gt; function (x, ...) \n#&gt; UseMethod(\"mean\")\n#&gt; &lt;bytecode: 0x0000021f566a1840&gt;\n#&gt; &lt;environment: namespace:base&gt;\n#&gt; \n#&gt; Signatures:\n#&gt;         x    \n#&gt; target  \"ANY\"\n#&gt; defined \"ANY\"\n\n注意：如何setMethod()的首个参数不是已经存在的泛型函数，它会自动调用setGeneric()。应该避免将常规函数转换为S4类的泛型函数。",
    "crumbs": [
      "15 S4"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/16 Trade-offs.html",
    "href": "Books/Advanced R(2e)/16 Trade-offs.html",
    "title": "16 Trade-offs",
    "section": "",
    "text": "前面我们对R中的三种OOP系统进行了系统介绍，了解了它们的基本使用方法，现在我们将三种系统进行对比，进一步了解它们各自的优劣势。这对我们在处理问题选择何种系统时会有所帮助。\n总的来说，作者推荐S3系统，因为它足够简单，并且广泛应用在base R和CRAN中；虽然它不是完善的，但是有一些处理方法可以避免。并不推荐总是使用R6系统。\n\n\n\n16.2节：S3与S4系统进行对比。简而言之，S4更加正式，往往需要更多的前期规划。这使得它更适合由团队而非个人开发的大型项目。\n16.3节：S3与R6系统进行对比。这一部分相当长，因为这两个系统在根本上是不同的，你需要考虑一些权衡。",
    "crumbs": [
      "16 Trade-offs"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/16 Trade-offs.html#introduction",
    "href": "Books/Advanced R(2e)/16 Trade-offs.html#introduction",
    "title": "16 Trade-offs",
    "section": "",
    "text": "前面我们对R中的三种OOP系统进行了系统介绍，了解了它们的基本使用方法，现在我们将三种系统进行对比，进一步了解它们各自的优劣势。这对我们在处理问题选择何种系统时会有所帮助。\n总的来说，作者推荐S3系统，因为它足够简单，并且广泛应用在base R和CRAN中；虽然它不是完善的，但是有一些处理方法可以避免。并不推荐总是使用R6系统。\n\n\n\n16.2节：S3与S4系统进行对比。简而言之，S4更加正式，往往需要更多的前期规划。这使得它更适合由团队而非个人开发的大型项目。\n16.3节：S3与R6系统进行对比。这一部分相当长，因为这两个系统在根本上是不同的，你需要考虑一些权衡。",
    "crumbs": [
      "16 Trade-offs"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/16 Trade-offs.html#s4-versus-s3",
    "href": "Books/Advanced R(2e)/16 Trade-offs.html#s4-versus-s3",
    "title": "16 Trade-offs",
    "section": "S4 versus S3",
    "text": "S4 versus S3\n一旦你熟悉使用S3系统，S4系统也就水到渠成，因为底层思想是一致的，只是S4系统更加正式严格，这使得S4系统更适合大型项目。因为S4系统提供了许多工具，如构造函数，验证函数等，我们无需为此过多耗神，而是将更多精力花在“绘制蓝图”上。\nBioconductor是一个使用S4系统取得良好效果的重要项目，其中很多包使用的数据结果，如SummarizedExperiment、IRanges、DNAStringSet，都是使用S4系统开发的。\n通过仔细地使用“methods”，在面对有关联地复杂系统时，我们可以最小程度地减少代码复用（继承）。例如“Matrix”包，它旨在高效地存储和计算多种不同类型的稀疏和密集矩阵。截至1.7.2版本，它定义了108个类、23个泛型函数和1780个方法。下面是它类图的一个小子集。\n\n矩阵计算这个领域非常适合使用S4, 因为稀疏矩阵的特定组合通常有计算捷径。S4 使得提供一个适用于所有输入的通用方法变得容易，然后在输入允许更高效实现的情况下提供更专业的方法。这需要仔细规划，以避免方法调度的模糊性，但这种规划会带来更高的性能。\n使用S4的最大挑战是日益增加的复杂性和缺乏单一文档来源的结合。S4是一个复杂的系统，在实践中有效使用可能具有挑战性。如果S4文档没有分散在R文档、书籍和网站中，这就不会是一个大问题。S4需要一本书的长度，但这本书 (目前) 还不存在。(S3 的文档并不更好，但缺乏这本书的痛苦较小，因为S3要简单得多。)",
    "crumbs": [
      "16 Trade-offs"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/16 Trade-offs.html#r6-versus-s3",
    "href": "Books/Advanced R(2e)/16 Trade-offs.html#r6-versus-s3",
    "title": "16 Trade-offs",
    "section": "R6 versus S3",
    "text": "R6 versus S3\nR6是一个与S3和S4截然不同的面向对象系统，因为它建立在封装对象之上，而不是泛型函数。此外，R6对象具有引用语义，这意味着它们可以在原位修改。这两个重大差异带来了许多不明显的后果，我们将在这里探讨。\n\n泛型函数是一个常规函数，因此它存在于全局命名空间中。R6方法属于对象，因此它存在于局部命名空间中。这影响了我们思考命名的方式。\nR6的引用语义允许方法同时返回值和修改对象。这解决了一个被称为 “线程状态” 的棘手问题。\nR6使用$调用方法，$是一个“infix”运算符。如果你正确地设置了你的方法，你可以使用方法调用链作为管道的替代方案。\n\n这些是泛函性OOP和封装OOP之间的一般权衡，因此它们也可以作为R与Python中系统设计的讨论。\n\nNamespacing\nS3和R6之间一个不明显的区别是方法所在的空间：\n\n泛型函数是全局的：所有包共享相同的命名空间。\n封装方法是本地的：方法绑定到单个对象。\n\n全局命名空间的优势在于，多个包可以使用相同的“动词”来处理不同类型的对象。泛型函数提供了统一的API, 这使得对新对象执行典型操作变得更容易，因为存在强大的命名约定。这在数据分析中效果很好，因为你经常想对不同类型的对象做相同的事情。特别是，这是R的建模系统如此有用的一个原因：无论模型在哪里实现，你总是可以使用相同的工具集 (summary ()、predict () 等) 来处理它。\n全局命名空间的缺点是它迫使你对命名进行更深入的思考。你需要避免在不同的包中使用多个名称相同的泛型，因为这需要用户频繁地输入::。这可能很困难，因为函数名称通常是英语动词，而动词通常具有多重含义。以 plot()为例：\nplot(data)       # plot some data\nplot(bank_heist) # plot a crime\nplot(land)       # create a new plot of land\nplot(movie)      # extract plot of a movie\n通常，你应该避免使用与原始泛型函数名同义的方法，而是应该为这些方法定义一个新的泛型。\nR6 方法不会出现这个问题，因为它们的作用域是对象。以下代码没有问题，因为这并不意味着两个不同R6对象的plot方法具有相同的含义：\ndata$plot()\nbank_heist$plot()\nland$plot()\nmovie$plot()\n这些考虑也适用于泛型函数的参数。S3泛型必须具有相同的核心参数，这意味着它们通常具有非特定的名称，如x或.data。S3泛型通常需要...向方法传递额外的参数，但这有一个缺点，即拼写错误的参数名称不会产生错误。相比之下，R6 方法可以有更广泛的变化，并使用更具体和更具启发性的参数名称。\n本地命名空间的一个次要优势是创建R6方法非常“廉价”。大多数封装的面向对象语言都鼓励你创建许多小方法，每个方法都有一个引人注目的名称。创建一个新的 S3 方法成本更高，因为你可能还需要创建一个泛型，并考虑上述命名问题。这意味着创建许多小方法的建议不适用于 S3。将代码分解成易于理解的小块仍然是一个好主意，但它们通常应该只是普通函数，而不是方法。\n\n\nThreading state\n使用S3编程的一个挑战是，当你想要同时返回值和修改对象时，会违反我们指导原则，即函数被调用时或返回值或执行副作用，但在少数情况下同时执行又是必要的。\n例如，假设你想创建一个“栈”对象，它有两个主要方法：\n\npush()：在栈顶添加一个新对象。\npop()：返回栈定处的值，然后从栈中删除它。\n\n栈对象的构造函数和push()方法的实现很简单。栈包含一个项目列表；将一个对象推送到栈只是简单地添加到这个列表中。\n\nnew_stack &lt;- function(items = list()) {\n  structure(list(items = items), class = \"stack\")\n}\n\npush &lt;- function(x, y) {\n  x$items &lt;- c(x$items, list(y))\n  x\n}\n\n实现pop()方法更具挑战性，因为它必须同时返回一个值 (栈顶部的对象) 和一个副作用 (从顶部移除该对象)。由于无法在S3中修改输入对象，我们需要返回两样东西：值和更新后的对象。\n\npop &lt;- function(x) {\n  n &lt;- length(x$items)\n\n  item &lt;- x$items[[n]]\n  x$items &lt;- x$items[-n]\n\n  list(item = item, x = x)\n}\n\n这会导致使用方式相当尴尬：\n\ns &lt;- new_stack()\ns &lt;- push(s, 10)\ns &lt;- push(s, 20)\n\nout &lt;- pop(s)\nout$item\n#&gt; [1] 20\ns &lt;- out$x\n\n这个问题被称为线程化状态（threading state）或累加器编程（accumulator programming），因为无论调用pop()多深，你都必须将修改后的栈对象一直线程化到它所在的位置。\n其他FP语言应对这一挑战的一种方式是提供多重赋值（multiple assign）或解构绑定运算符，允许你在一个步骤中赋值多个值。“zeallot”包为R提供了%&lt;-%的多重赋值功能。这使代码更加优雅，但并没有解决关键问题：\n\nlibrary(zeallot)\n\nc(value, s) %&lt;-% pop(s)\nvalue\n#&gt; [1] 10\n\n堆栈的R6实现更简单，因为$pop()可以就地修改对象，并且只返回最上面的值：\n\nStack &lt;- R6::R6Class(\"Stack\", list(\n  items = list(),\n  push = function(x) {\n    self$items &lt;- c(self$items, x)\n    invisible(self)\n  },\n  pop = function() {\n    item &lt;- self$items[[self$length()]]\n    self$items &lt;- self$items[-self$length()]\n    item\n  },\n  length = function() {\n    length(self$items)\n  }\n))\n\n这种方式的代码更加自然：\n\ns &lt;- Stack$new()\ns$push(10)\ns$push(20)\ns$pop()\n#&gt; [1] 20\n\n作者在“ggplot2”包种的scales中遇到了一个真实的线程状态案例。scales很复杂，因为它们需要跨每个分面和每个层组合数据。作者最初使用S3类，但这需要在许多函数之间传递scales数据。切换到R6后，代码变得简单了许多。然而，它也带来了一些问题，因为作者在修改图表时忘记调用$clone()。这使得独立的图表可以共享相同的比例数据，从而产生了一个难以追踪的微妙bug。",
    "crumbs": [
      "16 Trade-offs"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/16 Trade-offs.html#method-chaining",
    "href": "Books/Advanced R(2e)/16 Trade-offs.html#method-chaining",
    "title": "16 Trade-offs",
    "section": "Method chaining",
    "text": "Method chaining\n管道符%&gt;%很有用，因为它提供了一个“infix”运算符，使得从左到右组合函数变得容易。有趣的是，管道对R6对象来说并不那么重要，因为它们已经使用了一个“infix”运算符：$。这允许用户在单个表达式中链接多个方法调用，这种技术被称为方法链（method chaining）。\n\ns &lt;- Stack$new()\ns$\n  push(10)$\n  push(20)$\n  pop()\n#&gt; [1] 20\n\n这种技术通常用于其他编程语言，如Python和JavaScript, 并且是通过一个约定实现的：任何主要因其副作用 (通常是修改对象) 而调用的R6方法都应该返回invisible(self)。\n方法链的主要优点是可以获得有用的自动补全；主要缺点是只有类的创建者才能添加新的方法 (而且没有办法使用多分派)。",
    "crumbs": [
      "16 Trade-offs"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Metaprogramming Introduction.html",
    "href": "Books/Advanced R(2e)/Metaprogramming Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "R 语言中最令人感兴趣的特性之一是元编程（metaprogramming）。这种思想认为：代码即数据，可以被其他代码审查和修改，这深深地影响了R。从低水平上看，它实现了我们只需library(purrr)而无需添加\"\"就可以加载R包；使plot(x, sin(x))能自动用x和sin(x)作为图的坐标轴名称。从高水平看，它允许我们使用y ~ x1 + x2来描述一个模型；将subset(df, x == y)转换为df[df$x == df$y, , drop = FALSE]；使用dplyr::filter(db, is.na(x))（当db是数据库链接时）生成SQL语句WHERE x IS NULL。\n与元编程关系密切的是非标准性评估（Non-standard Evaluation，NSE）。这个术语通常用来描述R函数的行为，但会导致两个方面的歧义。首先，NSE实际上是函数参数的一个属性，因此谈论NSE函数有点草率。其次，通过什么是非标准来定义某个东西会让人混淆，因此本书会使用更精确的词汇表。\n本书会着重于由“rlang”包提供的整洁评估（tidy evaluation）。这将使你能够专注于重要的想法，而不会被R历史中产生的怪癖要求所分散注意力。在用rlang介绍完每个重要的想法后，本书会回过头来讨论这些想法在base R 中是如何实现的。这种方法可能看起来有些落后，但它就像学习如何使用自动变速器而不是换挡杆开车一样：它让你在学习细节之前先关注大局。本书侧重于整洁评估的理论方面，因此你可以从头到尾完全理解它是如何运作的。\n我们会在下面五个章节中介绍元编程与整洁评估：\n\n17章：介绍整个元编程框架，简要了解了所有主要组成部分，以及它们如何组合在一起使用。\n18章：介绍如何将R代码用“tree”结构进行描述。你将学习如何可视化这些树，R的语法规则如何将线性字符序列转换为这些树，以及如何使用递归函数来处理代码树。\n19章：介绍来自rlang的工具，你可以用它们来捕获未经评估的函数参数。你还将学习准引用，它提供了一套取消引用输入的技术，使得从代码片段中轻松生成新树成为可能。\n20章：继续评估捕获的代码。在这里，你将学习一个重要的数据结构，即quosure, 它通过捕获要评估的代码和评估它的环境来确保正确的评估。本章将向你展示如何将所有片段组合在一起，以理解NSE在base R中的工作原理，以及如何编写类似subset()的函数。\n21章：介绍如何结合第一类环境（first-class environments）、词法作用域和元编程，将R代码翻译成其他语言，即HTML和LaTeX。\n\n\n\n\n Back to top",
    "crumbs": [
      "Introduction"
    ]
  }
]