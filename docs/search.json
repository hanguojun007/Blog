[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "欢迎来到 RSSPtho，这里有\n\n读书笔记\n工作经验\n流程搭建\nshiny软件\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "一名拥有2年工作经验的生物信息工程师。我对R语言充满热情，致力于使用R语言解决生命科学中的数据。\n\n\n\n中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)\n\n\n\n硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)\n\n\n\n\n\n\nR\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "about.html#工作经历",
    "href": "about.html#工作经历",
    "title": "About me",
    "section": "",
    "text": "中科新生命 - 生物信息工程师 (2024.02 - 至今)\n上海云序生物科技有限公司 - 生物信息工程师 (2023.07 - 2024.01)"
  },
  {
    "objectID": "about.html#教育经历",
    "href": "about.html#教育经历",
    "title": "About me",
    "section": "",
    "text": "硕士 - 生物信息学\n\n中科院分子细胞科学卓越创新中心 & 中国科学院大学 (2020 - 2023)\n\n本科 - 生物科学\n\n山东大学 (2014 - 2020)"
  },
  {
    "objectID": "about.html#技能",
    "href": "about.html#技能",
    "title": "About me",
    "section": "",
    "text": "R\nnextflow\npython\ndocker\ngit"
  },
  {
    "objectID": "Books/ggplot2/index.html",
    "href": "Books/ggplot2/index.html",
    "title": "index",
    "section": "",
    "text": "test\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html",
    "title": "1 Software for modeling",
    "section": "",
    "text": "模型是能一种能描述系统之间的关系的数学工具，它能够还原或简化关系。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#建模软件的基础",
    "title": "1 Software for modeling",
    "section": "建模软件的基础",
    "text": "建模软件的基础\n\n用户友好，轻松产生实践。\n科学的方法论，发现隐藏的错误。"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型",
    "title": "1 Software for modeling",
    "section": "模型类型",
    "text": "模型类型\n\n描述模型\n\n\n推理模型\n假设检验法\n\n\n预测模型\n动力学模型\n经验驱动模型"
  },
  {
    "objectID": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "href": "Books/Tidy Modeling with R/1 Software for modeling.html#模型类型间的联系",
    "title": "1 Software for modeling",
    "section": "模型类型间的联系",
    "text": "模型类型间的联系"
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html",
    "href": "Books/R4DS2/27 A field guide to base R.html",
    "title": "27 A field guide to base R",
    "section": "",
    "text": "本章介绍一些base R中的重要函数：\n\n提取多个元素——[\n提取单个元素——[&$\napply家族\nfor循环\nPlot\n\n\nlibrary(tidyverse)",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取向量",
    "title": "27 A field guide to base R",
    "section": "提取向量",
    "text": "提取向量\n五种常见情景：\n\n正整数表示元素位置提取，重复提取生成重复元素的向量。\n\n\nx &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#&gt; [1] \"three\" \"two\"   \"five\"\n\nx[c(1, 1, 5, 5, 5, 2)]\n#&gt; [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\n\n\n负整数表示删除对应位置的元素。\n\n\nx[c(-1, -3, -5)]\n#&gt; [1] \"two\"  \"four\"\n\n\n逻辑向量提取值为TRUE的元素；关于NA的处理与dplyr::filter()不同，前者保留，后者不保留。\n\n\nx &lt;- c(10, 3, NA, 5, 8, 1, NA)\n\n# All non-missing values of x\nx[!is.na(x)]\n#&gt; [1] 10  3  5  8  1\n\n# All even (or missing!) values of x\nx[x %% 2 == 0]\n#&gt; [1] 10 NA  8 NA\n\n\n字符串向量提取有name属性的向量元素。\n\n\nx &lt;- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#&gt; xyz def \n#&gt;   5   2\n\n\nnothing–x[]返回完整的对象，在后面对data.frame提取时有用。",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "href": "Books/R4DS2/27 A field guide to base R.html#提取数据框",
    "title": "27 A field guide to base R",
    "section": "提取数据框",
    "text": "提取数据框\n使用df[rows, cols]提取数据框中对应的行或列；其中rows和cols与上面的使用方法一致。\n\ndf &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"e\", \"f\"),\n  z = runif(3)\n)\n\n# Select first row and second column\ndf[1, 2]\n#&gt; # A tibble: 1 × 1\n#&gt;   y    \n#&gt;   &lt;chr&gt;\n#&gt; 1 a\n\n# Select all rows and columns x and y\ndf[, c(\"x\", \"y\")]\n#&gt; # A tibble: 3 × 2\n#&gt;       x y    \n#&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt; 1     1 a    \n#&gt; 2     2 e    \n#&gt; 3     3 f\n\n# Select rows where `x` is greater than 1 and all columns\ndf[df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y         z\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     2 e     0.834\n#&gt; 2     3 f     0.601\n\ndata.frame格式与tibble格式的数据框在使用[上的唯一区别是：当df[,cols]中的cols只有一个元素时，data.frame格式返回向量，而tibble格式仍返回tibble。\n\ndf1 &lt;- data.frame(x = 1:3)\ndf1[, \"x\"]\n#&gt; [1] 1 2 3\n\ndf2 &lt;- tibble(x = 1:3)\ndf2[, \"x\"]\n#&gt; # A tibble: 3 × 1\n#&gt;       x\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n\ndata.frame格式使用drop参数，可以避免降维。\n\ndf1[, \"x\", drop = FALSE]\n#&gt;   x\n#&gt; 1 1\n#&gt; 2 2\n#&gt; 3 3",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyr-中的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr 中的等价操作",
    "text": "dplyr 中的等价操作\n在dplyr包中有几个verb等价于[的特例：\n\nfilter()：等价于按行使用逻辑向量提取，但对于NA的处理不同，filter()不保留NA，而[保留。\n\n\ndf &lt;- tibble(\n  x = c(2, 3, 1, 1, NA),\n  y = letters[1:5],\n  z = runif(5)\n)\ndf |&gt; filter(x &gt; 1)\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n# same as\ndf[!is.na(df$x) & df$x &gt; 1, ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\ndf[which(df$x &gt; 1), ]\n#&gt; # A tibble: 2 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     2 a     0.157  \n#&gt; 2     3 b     0.00740\n\n\narrange()：等价于按行使用正整数向量提取，向量通常由order()生成。\n\n\ndf |&gt; arrange(x, y)\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n# same as\ndf[order(df$x, df$y), ]\n#&gt; # A tibble: 5 × 3\n#&gt;       x y           z\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1     1 c     0.466  \n#&gt; 2     1 d     0.498  \n#&gt; 3     2 a     0.157  \n#&gt; 4     3 b     0.00740\n#&gt; 5    NA e     0.290\n\n\nselect() & relocate()：等价于按列使用字符向量提取。\n\n\ndf |&gt; select(x, z)\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290\n\n# same as\ndf[, c(\"x\", \"z\")]\n#&gt; # A tibble: 5 × 2\n#&gt;       x       z\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1     2 0.157  \n#&gt; 2     3 0.00740\n#&gt; 3     1 0.466  \n#&gt; 4     1 0.498  \n#&gt; 5    NA 0.290",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "href": "Books/R4DS2/27 A field guide to base R.html#data-frames",
    "title": "27 A field guide to base R",
    "section": "Data Frames",
    "text": "Data Frames\n[[和$用来提取数据框中的某列；[[可以通过位置或name属性提取，而$只能通过name属性提取。\n\ntb &lt;- tibble(\n  x = 1:4,\n  y = c(10, 4, 1, 21)\n)\n\n# by position\ntb[[1]]\n#&gt; [1] 1 2 3 4\n\n# by name\ntb[[\"x\"]]\n#&gt; [1] 1 2 3 4\ntb$x\n#&gt; [1] 1 2 3 4\n\ndplyr包提取了pull()函数，它等价于[[和$。\n\ntb |&gt; pull(x)\n#&gt; [1] 1 2 3 4",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "href": "Books/R4DS2/27 A field guide to base R.html#tibbles",
    "title": "27 A field guide to base R",
    "section": "Tibbles",
    "text": "Tibbles\ndata.frame与tibble在使用$时有着显著的不同；前者遵循部分匹配原则，后者使用精确匹配原则。\n\ndf &lt;- data.frame(x1 = 1)\ndf$x\n#&gt; [1] 1\ndf$z\n#&gt; NULL\n\n\ntb &lt;- tibble(x1 = 1)\n\ntb$x1\n#&gt; [1] 1\ntb$z\n#&gt; NULL",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "href": "Books/R4DS2/27 A field guide to base R.html#dplyrmutate的等价操作",
    "title": "27 A field guide to base R",
    "section": "dplyr::mutate的等价操作",
    "text": "dplyr::mutate的等价操作\n下面是使用with(),within()和transform()进行等价操作的例子。\n\n\ndata(diamonds, package = \"ggplot2\")\n\n# Most straightforward\ndiamonds$ppc &lt;- diamonds$price / diamonds$carat\n\n# Avoid repeating diamonds\ndiamonds$ppc &lt;- with(diamonds, price / carat)\n\n# The inspiration for dplyr's mutate\ndiamonds &lt;- transform(diamonds, ppc = price / carat)\ndiamonds &lt;- diamonds |&gt; transform(ppc = price / carat)\n\n# Similar to transform(), but uses assignment rather argument matching\n# (can also use = here, since = is equivalent to &lt;- outside of a function call)\ndiamonds &lt;- within(diamonds, {\n  ppc &lt;- price / carat\n})\ndiamonds &lt;- diamonds |&gt; within({\n  ppc &lt;- price / carat\n})\n\n# Protect against partial matching\ndiamonds$ppc &lt;- diamonds[[\"price\"]] / diamonds[[\"carat\"]]\ndiamonds$ppc &lt;- diamonds[, \"price\"] / diamonds[, \"carat\"]\n\n# FORBIDDEN\nattach(diamonds)\ndiamonds$ppc &lt;- price / carat",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/R4DS2/27 A field guide to base R.html#lists",
    "href": "Books/R4DS2/27 A field guide to base R.html#lists",
    "title": "27 A field guide to base R",
    "section": "lists",
    "text": "lists\n[，[[和$都可以提取list中的元素，但[保留原list层级，而[[和$不保留。\n\nl &lt;- list(\n  a = 1:3,\n  b = \"a string\",\n  c = pi,\n  d = list(-1, -5)\n)\n\nstr(l[1:2])\n#&gt; List of 2\n#&gt;  $ a: int [1:3] 1 2 3\n#&gt;  $ b: chr \"a string\"\n\nstr(l[1])\n#&gt; List of 1\n#&gt;  $ a: int [1:3] 1 2 3\nstr(l[[1]])\n#&gt;  int [1:3] 1 2 3\n\nstr(l[4])\n#&gt; List of 1\n#&gt;  $ d:List of 2\n#&gt;   ..$ : num -1\n#&gt;   ..$ : num -5\nstr(l[[4]])\n#&gt; List of 2\n#&gt;  $ : num -1\n#&gt;  $ : num -5\n\n两者的差异如下图所示：",
    "crumbs": [
      "27 A field guide to base R"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/index.html",
    "href": "Books/Advanced R(2e)/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Advanced R的学习笔记。\n原文见：Advanced R\n本书主要包含两方面：\n\nR 语言底层逻辑\n高级编程技巧\n\n下面是全文概览：\n\n第1章：简介。\n第2-8章：R语言基础概念。\n第9-11章：函数编程。\n第12~16章：面向对象编程。\n第17~21章：元编程。\n第22-25章：高级编程技巧。\n\n本书适合在不同阶段，根本不同需求阅读不同章节。\n本书中的练习题解决方案：Advanced R Solutions\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html",
    "href": "Books/Advanced R(2e)/3 Vectors.html",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#introduction",
    "href": "Books/Advanced R(2e)/3 Vectors.html#introduction",
    "title": "3 Vectors",
    "section": "",
    "text": "R 中的Vectors可以分为两种：要求所有元素相同的atomic、元素可以是任意类型的list，还有一个类似零长度向量的NULL。下面是三者关系的示意图。\n\n\n\n\n\ngraph TD\n    A[Atomic] --&gt; B(Vector)\n    C[List] --&gt; B(Vector)\n    D(NULL)\n\n\n\n\n\n\n这里提到的vector就是我们常说的向量。在R中，所有的对象都是向量，对向量添加不同属性就构成了不同类型的数据。维度（dimension）和类（clas）是两个比较重要的属性，前者将一维向量升格为二维矩阵甚至多维数组，后者赋予了对象S3面向对象系统。\n\n\n\n3.2节：R中最简单的 atomic 向量：integer、double、character、logical。\n3.3节：向量的三个重要属性：name、dimension、class。\n3.4节：具有特殊属性的 atomic 向量：factor、date、date-time、duration。\n3.5节：list。\n3.6节：data.frame 和 tibble。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#atomic-vectors",
    "href": "Books/Advanced R(2e)/3 Vectors.html#atomic-vectors",
    "title": "3 Vectors",
    "section": "Atomic vectors",
    "text": "Atomic vectors\nR 中有四类常见的atomic向量：integer、double、character、logical。下面是这四类向量之间的关系图。还有两类不常见的：complex和raw，前者表示复数，后者表示二级制数据。\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \" \"\n        D\n        E\n        F\n        G\n    end\n\n\n\n\n\n\n\nScalars\n上述四种atomic向量都有各自的语法：\n\nlogical：只能使用TRUE/T和FALSE/F。\ndouble：有三种形式：十进制、科学技术法和十六进制；还有三个特殊的符号：NaN、Inf和-Inf。\ninteger：形式同double，但是必须添加L后缀。\ncharacter：使用双引号或单引号包裹，\\进行转义。\n\n\n\nMaking longer vectors with c()\n使用c()函数可以创建长向量，使用typeof()查看对象的类型。\n\nlgl_var &lt;- c(TRUE, FALSE)\nint_var &lt;- c(1L, 6L, 10L)\ndbl_var &lt;- c(1, 2.5, 4.5)\nchr_var &lt;- c(\"these are\", \"some strings\")\n\ntypeof(lgl_var)\n#&gt; [1] \"logical\"\ntypeof(int_var)\n#&gt; [1] \"integer\"\ntypeof(dbl_var)\n#&gt; [1] \"double\"\ntypeof(chr_var)\n#&gt; [1] \"character\"\n\n\n\nMissing values\nNA是not applicable的缩写，表示缺失值。缺失值有一定的‘传染性’：许多包含NA的计算会返回NA。\n\nNA &gt; 5\n#&gt; [1] NA\n10 * NA\n#&gt; [1] NA\n!NA\n#&gt; [1] NA\n\n但有一些特例：\n\nNA^0\n#&gt; [1] 1\nNA | TRUE\n#&gt; [1] TRUE\nNA & FALSE\n#&gt; [1] FALSE\n\n使用is.na()判断是否是NA，而不是==。\n\nx &lt;- c(NA, 5, NA, 10)\nx == NA\n#&gt; [1] NA NA NA NA\nis.na(x)\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\n理论上讲：存在四种NA类型，分别对应上述的四种atomic向量：NA(logical)、NA_integer_(integer)、NA_real_(double)、NA_character(character)。但平常使用无需强调，R会自动强制转换。NA默认表示logical是因为下面的强制转换顺序。\n\n\nCoercion\n如上所述，当atomic向量中的元素类型不一致时，R会自动强制转换类型。转换的顺序次序为：character → double → integer → logical。例如，c(\"a\", 1)的结果是c(\"a\", \"1\")。\n\nc(\"a\", 1)\n#&gt; [1] \"a\" \"1\"\n\n强制转换的背后是as.*()函数，例如as.logical()、as.integer()、as.double()、as.character()。转换失败会生成警告信息和缺失值。\n\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1]  1  1 NA\n\n\n\nTesting\nR 中由类似判断是否是缺失值is.na()的其他函数，但是要小心使用。is.logical()、is.integer()、is.double()、is.character()这四个函数的用法与is.na()相同；is.vector()、is.atomic()、is.numeric()的用法则大不相同。\n\nis.vector()：根据mode参数，判断是否属于atomic向量、list、或expression，同时不能有除name外的其他属性。\nis.atomic()：判断是否属于atomic向量，NULL返回FALSE。\nis.numeric()：属于double、integer或任何可视为数值的向量。\n\n具体细节可以查看R文档。\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#attributes",
    "href": "Books/Advanced R(2e)/3 Vectors.html#attributes",
    "title": "3 Vectors",
    "section": "Attributes",
    "text": "Attributes\n\nGetting and setting\n属性可以看作是由键值对构成，附属于对象的元信息。可以使用attr(),attributes(),structure()来提取或设置对象的属性。\n\n# 单独设置\na &lt;- 1:3\nattr(a, \"x\") &lt;- \"abcdef\"\nattr(a, \"x\")\n#&gt; [1] \"abcdef\"\n\nattr(a, \"y\") &lt;- 4:6\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n# 批量设置\na &lt;- structure(\n  1:3,\n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#&gt; List of 2\n#&gt;  $ x: chr \"abcdef\"\n#&gt;  $ y: int [1:3] 4 5 6\n\n\n属性极易丢失，但有两个例外，通常会保留：name,dim；保留属性需要使用S3面向对象系统。\n\nattributes(a[1])\n#&gt; NULL\nattributes(sum(a))\n#&gt; NULL\n\n\n\nNames\n有三种为向量设定name属性的方法。去除name属性有两种方法.\n\n# When creating it:\nx &lt;- c(a = 1, b = 2, c = 3)\nx\n#&gt; a b c \n#&gt; 1 2 3\nx &lt;- unname(x)\nx\n#&gt; [1] 1 2 3\n\n# By assigning a character vector to names()\nx &lt;- 1:3\nnames(x) &lt;- c(\"a\", \"b\", \"c\")\nx\n#&gt; a b c \n#&gt; 1 2 3\nnames(x) &lt;- NULL\nx\n#&gt; [1] 1 2 3\n\n# Inline, with setNames():\nx &lt;- setNames(1:3, c(\"a\", \"b\", \"c\"))\nx\n#&gt; a b c \n#&gt; 1 2 3\n\n在创建name属性时，应当保持name唯一且不为缺失值。需要注意这不是R的强制要求。\n\n\nDimensions\natomic向量添加dim属性，就可以生成二维matrix或多维array。在R中可以使用matrix(),array()或dim()来生成。\n\n# Two scalar arguments specify row and column sizes\nx &lt;- matrix(1:6, nrow = 2, ncol = 3)\nx\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n\n\n# One vector argument to describe all dimensions\ny &lt;- array(1:12, c(2, 3, 2))\ny\n#&gt; , , 1\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\n#&gt; \n#&gt; , , 2\n#&gt; \n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    7    9   11\n#&gt; [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz &lt;- 1:6\ndim(z) &lt;- c(3, 2)\nz\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\natomic向量的许多函数都对matrix和array进行了推广。\n\n\n\nVector\nMatrix\nArray\n\n\n\n\nnames()\nrownames(),colnames()\ndimnames()\n\n\nlength()\nnrow(),ncol()\ndim()\n\n\nc()\nrbind(),cbind()\nabind::abind()\n\n\n-\nt()\naperm()\n\n\nis.null(dim(x))\nis.matrix()\nis.array()\n\n\n\n不能简单地将没有维度的atomic向量视作只有1行或1列的矩阵、1维的数组，因为函数对它们的处理结果是不一样的。\n\nstr(1:3) # 1d vector\n#&gt;  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#&gt;  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#&gt;  int [1, 1:3] 1 2 3\nstr(array(1:3, 3)) # \"array\" vector\n#&gt;  int [1:3(1d)] 1 2 3\n\n\n\nExercises\n\ncomment属性比较特殊，不会被print打印出来，只能使用attr()或attributes()来提取。",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#s3-atomic-vectors",
    "href": "Books/Advanced R(2e)/3 Vectors.html#s3-atomic-vectors",
    "title": "3 Vectors",
    "section": "S3 atomic vectors",
    "text": "S3 atomic vectors\nclass是另外一个重要的属性，它赋予了对象S3面向对象的能力。每个S3对象由base type构建（base type内容见12章）。本节主要讨论下面四种S3 atomic vectors：\n\nfactor：分类数据。\nDate：日期数据。\nPOSIXct：日期时间数据。\ndifftime：持续时间数据。\n\n\n\n\n\n\ngraph BT\n    B[Atomic] --&gt; A(Vector)\n    D[Logical] --&gt; B(Atomic)\n    C[Numeric] --&gt; B(Atomic)\n    E[Integer] --&gt; C(Numeric)\n    F[Double] --&gt; C(Numeric)\n    G[Character] --&gt; B(Atomic)\n    subgraph \"base atomic\"\n        D\n        E\n        F\n        G\n    end\n    H[factor] --&gt; E\n    I[POSIXct] --&gt; F\n    J[Date] --&gt; F\n    subgraph \"S3 atomic\"\n        H\n        I\n        J\n    end\n\n\n\n\n\n\n\nFactors\nfactor 是在integer类型向量基础上，添加class = fcator和levels两个属性构成。\n\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#&gt; [1] a b b a\n#&gt; Levels: a b\n\ntypeof(x)\n#&gt; [1] \"integer\"\nattributes(x)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n\nfactor 有一个变体——ordered factor，它的属性levels具有了顺次意义，例如：low,medium,high等。\n\ngrade &lt;- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#&gt; [1] b b a c\n#&gt; Levels: c &lt; b &lt; a\n\nbase R 中的函数如read.csv(),data.frame()会自动将字符串转换为factor，这种行为很没有道理，因为有时数据中不可能包含全部的level。可以通过stringsAsFactors = FALSE来禁用这种行为。\n\n\nDates\nDate 是在double类型向量基础上，添加class = Date属性构成。去除属性后，可以看到原来的double向量。\n\ntoday &lt;- Sys.Date()\n\ntypeof(today)\n#&gt; [1] \"double\"\nattributes(today)\n#&gt; $class\n#&gt; [1] \"Date\"\n\n# 底层double向量，思考一下这个数字的含义？\nunclass(today)\n#&gt; [1] 20183\n\n\n\nDate-times\nbase R 提供了两种储存 date-time 的数据格式：POSIXct和POSIXlt。这里我们只关注POSIXct，因为它构建于double类型向上，且在数据框中广泛应用。POSIXct有两个属性：class = POSIXct和tzone。\n\nnow_ct &lt;- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#&gt; [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#&gt; [1] \"double\"\nattributes(now_ct)\n#&gt; $class\n#&gt; [1] \"POSIXct\" \"POSIXt\" \n#&gt; \n#&gt; $tzone\n#&gt; [1] \"UTC\"\n\ntzone属性值控制date-time的显示形式，不改变其本质的double数值。\n\nnew_ct &lt;- structure(now_ct, tzone = \"Asia/Tokyo\")\nnew_ct\n#&gt; [1] \"2018-08-02 07:00:00 JST\"\nunclass(now_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"UTC\"\nunclass(new_ct)\n#&gt; [1] 1533160800\n#&gt; attr(,\"tzone\")\n#&gt; [1] \"Asia/Tokyo\"\n\n\n\nDurations\ndurations 表示date或date-time之间的持续时间，它是在double类型向量基础上，添加class = difftime属性构成，同时有属性units，表示持续时间的单位。\n\none_week_1 &lt;- as.difftime(1, units = \"weeks\")\none_week_1\n#&gt; Time difference of 1 weeks\n\ntypeof(one_week_1)\n#&gt; [1] \"double\"\n#&gt; [1] \"double\"\nattributes(one_week_1)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"weeks\"\n\none_week_2 &lt;- as.difftime(7, units = \"days\")\none_week_2\n#&gt; Time difference of 7 days\n\ntypeof(one_week_2)\n#&gt; [1] \"double\"\nattributes(one_week_2)\n#&gt; $class\n#&gt; [1] \"difftime\"\n#&gt; \n#&gt; $units\n#&gt; [1] \"days\"\n\n\n\nExercises\n\n仔细观察下面三个因子的不同。\n\n\n# 数据和level同时反转\nf1 &lt;- factor(letters)\nf1\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\nlevels(f1) &lt;- rev(levels(f1))\nf1\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f1)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n#&gt; [25] 25 26\n\n# 仅数据反转\nf2 &lt;- rev(factor(letters))\nf2\n#&gt;  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a\n#&gt; Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z\nas.integer(f2)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1\n\n# 仅level反转\nf3 &lt;- factor(letters, levels = rev(letters))\nf3\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a\nas.integer(f3)\n#&gt;  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3\n#&gt; [25]  2  1",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#lists",
    "href": "Books/Advanced R(2e)/3 Vectors.html#lists",
    "title": "3 Vectors",
    "section": "Lists",
    "text": "Lists\n虽然看起来list中的元素是不同，诚如前章所述，list中的元素有其自己的内存地址，也就是说，list中的元素本质是相同的，只是其索引的内容类型不同。\n\nCreating\n使用函数list()创建list。\n\nl1 &lt;- list(\n  1:3,\n  \"a\",\n  c(TRUE, FALSE, TRUE),\n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#&gt; [1] \"list\"\n\nstr(l1)\n#&gt; List of 4\n#&gt;  $ : int [1:3] 1 2 3\n#&gt;  $ : chr \"a\"\n#&gt;  $ : logi [1:3] TRUE FALSE TRUE\n#&gt;  $ : num [1:2] 2.3 5.9\n\n如上所述，list的元素只是索引，所以list的实际内存大小可能与你的期望相差甚远。\n\nlobstr::obj_size(mtcars)\n#&gt; 7.21 kB\n\nl2 &lt;- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#&gt; 7.29 kB\n\nlist 中的元素可以是其他的list。\n\nl3 &lt;- list(list(list(1)))\nstr(l3)\n#&gt; List of 1\n#&gt;  $ :List of 1\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 1\n\n\n前面讲到函数c()要求元素类型一致，否则执行强制转换；当list和其他atomic向量使用c()合并时，atomic向量会被强制添加到list中。\n\nl4 &lt;- list(list(1, 2), c(3, 4))\nl5 &lt;- c(list(1, 2), c(3, 4))\nstr(l4)\n#&gt; List of 2\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 1\n#&gt;   ..$ : num 2\n#&gt;  $ : num [1:2] 3 4\nstr(l5)\n#&gt; List of 4\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n\n\n\n\nTesting and coercion\n\n使用typeof()查看是否为list。\n使用as.list()强制转换为list。\n使用unlist()强制转换为atomic向量。\n\n\n# 注意as.list的不同\nl6 &lt;- list(1:3)\nl6\n#&gt; [[1]]\n#&gt; [1] 1 2 3\n\ntypeof(l6)\n#&gt; [1] \"list\"\n\nas.list(1:3)\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 2\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 3\n\n\n\nMatrices and arrays\natomic向量添加dim属性后创建出matrix，list添加dim属性后可以创建此出list-matrix、list-array。这些数据结构可以使得处理特殊数据时更加灵活。\n\nl &lt;- list(1:3, \"a\", TRUE, 1.0)\ndim(l) &lt;- c(2, 2)\nl\n#&gt;      [,1]      [,2]\n#&gt; [1,] integer,3 TRUE\n#&gt; [2,] \"a\"       1\n\nl[[1, 1]]\n#&gt; [1] 1 2 3\n\n\n\nExercises\n\n使用[函数提取元素时，当超出范围，atomic向量返回NA，list返回NULL。\n\n\n# Subsetting atomic vectors\n(1:2)[3]\n#&gt; [1] NA\n(1:2)[NA]\n#&gt; [1] NA NA\n\n# Subsetting lists\nas.list(1:2)[3]\n#&gt; [[1]]\n#&gt; NULL\nas.list(1:2)[NA]\n#&gt; [[1]]\n#&gt; NULL\n#&gt; \n#&gt; [[2]]\n#&gt; NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#data-frames-and-tibbles",
    "href": "Books/Advanced R(2e)/3 Vectors.html#data-frames-and-tibbles",
    "title": "3 Vectors",
    "section": "Data frames and tibbles",
    "text": "Data frames and tibbles\n最重要的两个以list为基础构建的S3 对象是：data.frame和tibble。\n\n\n\n\n\ngraph BT\n    B[List] --&gt; A(Vector)\n    D[data.frame] --&gt; B(List)\n    C[tibble] --&gt; B(List)\n\n\n\n\n\n\ndataframe有三个属性names、class = data.frame、row.names。names是list本身的属性，表示为有name的list，在dataframe中表示列名；row.names表示行名。同时dataframe要求list中的每个元素长度都相等。作用于list的函数如names()，作用于dataframe时返回的是列名，等价于colnames()、length()返回的是列数，等价于ncol()。\n\ndf1 &lt;- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#&gt; [1] \"list\"\n\nattributes(df1)\n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n\nnames(df1)\n#&gt; [1] \"x\" \"y\"\nlength(df1)\n#&gt; [1] 2\n\ntibble由R包tibble提供，是对dataframe的一种补充，二者由唯一的不同是属性class，tibble有其自己独特的类tbl_df,tbl。类的不同赋予了tibble格式在某些行为上与dataframe有着巨大的差别。下面会详细介绍二者的不同。\n\nlibrary(tibble)\n\ndf2 &lt;- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#&gt; [1] \"list\"\n\nattributes(df2)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\"\n\n\nCreating\n在使用data.frame()和tibble()函数创建dataframe或tibble时，主要有下面四点不同：\n\n列为字符串时，是否自动转换为因子：在R 4.0.0之前的版本，data.frame()函数默认stringsAsFactors = TRUE，而tibble()函数始终不会将字符串转换为因子。\n\n\ndf1 &lt;- data.frame(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\nstr(df1)\n#&gt; 'data.frame':    3 obs. of  2 variables:\n#&gt;  $ x: int  1 2 3\n#&gt;  $ y: chr  \"a\" \"b\" \"c\"\n\ndf2 &lt;- tibble(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n#&gt; tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n#&gt;  $ y: chr [1:3] \"a\" \"b\" \"c\"\n\n\n列名不规范时，是否自动转换为合法列名：data.frame()在参数check.names = FALSE时不会转换列名，tibble()函数始终不会转换列名，而是使用“`”包裹列名。\n\n\nnames(data.frame(`1` = 1))\n#&gt; [1] \"X1\"\n\nnames(tibble(`1` = 1))\n#&gt; [1] \"1\"\n\n\n在构建数据框时，如果列之间的长度不同：data.frame()函数会将较短的列自动循环，tibble()函数只会循环长度为1的列，否则报错。\n\n\ndata.frame(x = 1:4, y = 1:2)\n#&gt;   x y\n#&gt; 1 1 1\n#&gt; 2 2 2\n#&gt; 3 3 1\n#&gt; 4 4 2\ndata.frame(x = 1:4, y = 1:3)\n#&gt; Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n#&gt; # A tibble: 4 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     1\n#&gt; 2     2     1\n#&gt; 3     3     1\n#&gt; 4     4     1\ntibble(x = 1:4, y = 1:2)\n#&gt; Error in `tibble()`:\n#&gt; ! Tibble columns must have compatible sizes.\n#&gt; • Size 4: Existing data.\n#&gt; • Size 2: Column `y`.\n#&gt; ℹ Only values of size one are recycled.\n\n\n在构建数据框时，tibble()函数可以使用前面定义好的列的数据。\n\n\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x     y\n#&gt;   &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     2\n#&gt; 2     2     4\n#&gt; 3     3     6\n\n\n\nRow names\ndataframe可以使用data.frame(row.names = ...)或rownames(df) &lt;- ...来赋予数据框行名，但是tibble不支持设置行名（实际是可以设置的，只是不建议这样做）。\n\ndf3 &lt;- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n#&gt;       age  hair\n#&gt; Bob    35 blond\n#&gt; Susan  27 brown\n#&gt; Sam    18 black\n\nrownames(df3)\n#&gt; [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n#&gt;     age  hair\n#&gt; Bob  35 blond\n\n对于tibble为什么不赞成为数据框设置行名，可以参考原文。dataframe转换为tibble时可以使用rownames_to_column()或as_tibble(rownames = \"rownames\")来保留行名信息。\n\n\nPrinting\n在终端以dataframe或tibble格式分别打印数据，会发现：dataframe将所有行列都打印了出来，而tibble只打印前几行及前几列，同时显示未打印列及行的信息，并且显示每列数据的类型，压缩内容过长的单元格，显示特殊数据比如NA。\n\ndplyr::starwars\n#&gt; # A tibble: 87 × 14\n#&gt;   name           height  mass hair_color  skin_color  eye_color birth_year\n#&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;          &lt;dbl&gt;\n#&gt; 1 Luke Skywalker    172    77 blond       fair        blue            19  \n#&gt; 2 C-3PO             167    75 &lt;NA&gt;        gold        yellow         112  \n#&gt; 3 R2-D2              96    32 &lt;NA&gt;        white, blue red             33  \n#&gt; 4 Darth Vader       202   136 none        white       yellow          41.9\n#&gt; 5 Leia Organa       150    49 brown       light       brown           19  \n#&gt; 6 Owen Lars         178   120 brown, grey light       blue            52  \n#&gt; # ℹ 81 more rows\n#&gt; # ℹ 7 more variables: sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt;, …\n\n\n\nSubsetting\n在第4章会学到更多有关提取子集的内容，这里介绍两个dataframe在提取子集时的两个缺点：\n\ndf[, vars]提取的列为1时，会自动降维成向量，除非添加参数df[, vars, drop = FALSE]。\ndf$x根据列名提取某列时，如果没有该列，会尝试返回一个字符串开头是x字符的列。\n\n\ndf1 &lt;- data.frame(xyz = \"a\")\ndf2 &lt;- tibble(xyz = \"a\")\n\nstr(df1$x)\n#&gt;  chr \"a\"\nstr(df2$x)\n#&gt;  NULL\n\n\n\nTesting and coercing\nis.data.frame()可以用来检查是否是dataframe或tibble，is_tibble()只能检查是否是tibble（注意两个函数在形式上的区别.,_）。\n\nis.data.frame(df1)\n#&gt; [1] TRUE\nis.data.frame(df2)\n#&gt; [1] TRUE\n\nis_tibble(df1)\n#&gt; [1] FALSE\nis_tibble(df2)\n#&gt; [1] TRUE\n\n\n\nList columns\n前面我们说过，数据框本质是一个list，所以数据框中的列可以包含任意类型的元素，包括list。tibble本身支持list column，dataframe需要额外的I()函数辅助。\n\n# tibble\ntibble(\n  x = 1:3,\n  y = list(1:2, 1:3, 1:4)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;       x y        \n#&gt;   &lt;int&gt; &lt;list&gt;   \n#&gt; 1     1 &lt;int [2]&gt;\n#&gt; 2     2 &lt;int [3]&gt;\n#&gt; 3     3 &lt;int [4]&gt;\n\n# dataframe\ndf &lt;- data.frame(x = 1:3)\ndf$y &lt;- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3,\n  y = I(list(1:2, 1:3, 1:4))\n)\n#&gt;   x          y\n#&gt; 1 1       1, 2\n#&gt; 2 2    1, 2, 3\n#&gt; 3 3 1, 2, 3, 4\n\n\n\nMatrix and data frame columns\n同上面的list一样，你可以在数据框中添加行数相等的矩阵和数据框。\n\n\ndfm &lt;- data.frame(\n  x = 1:3 * 10\n)\ndfm$y &lt;- matrix(1:9, nrow = 3)\ndfm$z &lt;- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n#&gt; 'data.frame':    3 obs. of  3 variables:\n#&gt;  $ x: num  10 20 30\n#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#&gt;  $ z:'data.frame':   3 obs. of  2 variables:\n#&gt;   ..$ a: int  3 2 1\n#&gt;   ..$ b: chr  \"a\" \"b\" \"c\"\n\n\n\n\nExercises\n…",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/3 Vectors.html#null",
    "href": "Books/Advanced R(2e)/3 Vectors.html#null",
    "title": "3 Vectors",
    "section": "NULL",
    "text": "NULL\nNULL 的长度为0，类型为NULL，且无法拥有任何属性。\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\n\nlength(NULL)\n#&gt; [1] 0\n\nx &lt;- NULL\nattr(x, \"y\") &lt;- 1\n#&gt; Error in attr(x, \"y\") &lt;- 1: attempt to set an attribute on NULL",
    "crumbs": [
      "3 Vectors"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html",
    "href": "Books/Advanced R(2e)/13 S3.html",
    "title": "13 S3",
    "section": "",
    "text": "R base 和stats包只使用了S3面向对象。S3面向对象不像其他语言中那么严格，R编程人员有很大的自由，这是危险的；为了能更好的使用S3对象，本章会介绍使用S3面向对象时约定的惯例。\n\nlibrary(sloop)"
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#introduction",
    "href": "Books/Advanced R(2e)/13 S3.html#introduction",
    "title": "13 S3",
    "section": "",
    "text": "R base 和stats包只使用了S3面向对象。S3面向对象不像其他语言中那么严格，R编程人员有很大的自由，这是危险的；为了能更好的使用S3对象，本章会介绍使用S3面向对象时约定的惯例。\n\nlibrary(sloop)"
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#basics",
    "href": "Books/Advanced R(2e)/13 S3.html#basics",
    "title": "13 S3",
    "section": "Basics",
    "text": "Basics\n\nS3 对象\n一个S3对象是一个至少有1个class属性的base type。例如factor，它的base type是integer，除此之外还有class属性和levels属性。\n\nf &lt;- factor(c(\"a\", \"b\", \"c\"))\n\ntypeof(f)\n#&gt; [1] \"integer\"\nattributes(f)\n#&gt; $levels\n#&gt; [1] \"a\" \"b\" \"c\"\n#&gt; \n#&gt; $class\n#&gt; [1] \"factor\"\n\n使用unclass()可以去除S3对象的class属性，暴露出其底层的base type，同时失去对象的特有行为。\n\nunclass(f)\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\n\n\n泛型函数\n同一个泛型函数对不同S3对象根据对象的class属性，具有不同的实现结果。\n\nprint(f)\n#&gt; [1] a b c\n#&gt; Levels: a b c\n\n# stripping class reverts to integer behaviour\nprint(unclass(f))\n#&gt; [1] 1 2 3\n#&gt; attr(,\"levels\")\n#&gt; [1] \"a\" \"b\" \"c\"\n\n识别泛型函数的一种简单方法是使用sloop::ftype()，如果结果中有”generic”字样，就是泛型函数。上面的print()也是泛型3函数。\n\nftype(print)\n#&gt; [1] \"S3\"      \"generic\"\nftype(str)\n#&gt; [1] \"S3\"      \"generic\"\nftype(unclass)\n#&gt; [1] \"primitive\"\n\n诚如前面所讲，泛型函数作为S3系统实现面向对象的工具，它具有封装的特性，会隐藏对象中的细节。例如常用的str()泛型函数，虽然用来查看对象的结构，但你所看到的是对象想让你看到的，没有展示对象内部详细的细节。POSIXlt类用来表示时间，使用str()只能看到年月日，但其底层是一个list。\n\ntime &lt;- strptime(c(\"2017-01-01\", \"2020-05-04 03:21\"), \"%Y-%m-%d\")\nstr(time)\n#&gt;  POSIXlt[1:2], format: \"2017-01-01\" \"2020-05-04\"\n\nstr(unclass(time))\n#&gt; List of 11\n#&gt;  $ sec   : num [1:2] 0 0\n#&gt;  $ min   : int [1:2] 0 0\n#&gt;  $ hour  : int [1:2] 0 0\n#&gt;  $ mday  : int [1:2] 1 4\n#&gt;  $ mon   : int [1:2] 0 4\n#&gt;  $ year  : int [1:2] 117 120\n#&gt;  $ wday  : int [1:2] 0 1\n#&gt;  $ yday  : int [1:2] 0 124\n#&gt;  $ isdst : int [1:2] 0 0\n#&gt;  $ zone  : chr [1:2] \"UTC\" \"UTC\"\n#&gt;  $ gmtoff: int [1:2] NA NA\n#&gt;  - attr(*, \"tzone\")= chr [1:3] \"\" \"UTC\" \"UTC\"\n#&gt;  - attr(*, \"balanced\")= logi TRUE\n\n泛型函数就像一个中间人：它定义接口 (即参数) ，然后为不同类找到正确的实现。特定类的实现称为方法（method），泛型通过执行方法分派（method dispatch）来找到该方法。\n可以使用sloop::s3_dispatch()函数查看方法分派的过程。如下面所示，找到了当前print的多个实现print.factor和print.default，最终选择了print.factor。\n\ns3_dispatch(print(f))\n#&gt; =&gt; print.factor\n#&gt;  * print.default\n\n从结果中可以看到，泛型函数的命名规则是generic.class()。通常你无需使用generic.class()形式的函数，只需使用generic()，它会根据输入对象的class属性自动识别。因为某些函数的定义早于S3系统，所以类型&lt;&gt;.&lt;&gt;的函数不都是泛函，可以使用sloop::ftype()进行识别。\n\nftype(t.test)\n#&gt; [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#&gt; [1] \"S3\"     \"method\"\n\nS3 系统的泛函通常无法看到源码，但是可以使用sloop::s3_get_method()查看。\n\nweighted.mean.Date\n#&gt; Error: object 'weighted.mean.Date' not found\n\ns3_get_method(weighted.mean.Date)\n#&gt; function (x, w, ...) \n#&gt; .Date(weighted.mean(unclass(x), w, ...))\n#&gt; &lt;bytecode: 0x565520473fd8&gt;\n#&gt; &lt;environment: namespace:stats&gt;"
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#classes",
    "href": "Books/Advanced R(2e)/13 S3.html#classes",
    "title": "13 S3",
    "section": "Classes",
    "text": "Classes\nS3 面向对象类的正式定义和实例化，只能使用structure()或calss&lt;-()函数通过设置class属性的方法。\n\n# Create and assign class in one step\nx &lt;- structure(list(), class = \"my_class\")\n\n# Create, then set class\nx &lt;- list()\nclass(x) &lt;- \"my_class\"\n\n使用class()查看一个对象的类型，使用inherits(x, \"classname\")来判断一个对象是否属于某类。\n\nclass(x)\n#&gt; [1] \"my_class\"\ninherits(x, \"my_class\")\n#&gt; [1] TRUE\ninherits(x, \"your_class\")\n#&gt; [1] FALSE\n\nclassname 可以是任意字符串，但是推荐使用字姆和_，杜绝使用.。在package中使用class时，推荐加上包名。\nS3 面向对象没有类正确性检查，意味着可以随意更改一个对象的类：\n\n# Create a linear model\nmod &lt;- lm(log(mpg) ~ log(disp), data = mtcars)\nclass(mod)\n#&gt; [1] \"lm\"\nprint(mod)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = log(mpg) ~ log(disp), data = mtcars)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)    log(disp)  \n#&gt;      5.3810      -0.4586\n\n# Turn it into a date (?!)\nclass(mod) &lt;- \"Date\"\n\n# Unsurprisingly this doesn't work very well\nprint(mod)\n#&gt; Error in as.POSIXlt(.Internal(Date2POSIXlt(x, tz)), tz = tz): 'list' object cannot be coerced to type 'double'\n\n为了避免上述问题发生，推荐创建三个函数：\n\n低级构造函数(Constructor)，new_myclass()：高效地创建结构正确的类。\n验证函数(validator)，validate_myclass()：验证类的合法性。\n帮助函数(helper)，myclass()：用户友好的创建类。\n\n\nConstructors\nS3 面向对象创建类的随意性，无法保证类的结构统一，构造函数可以很好地避免。构造函数应当遵循下面三条原则：\n\n函数命名为new_myclass()样式。\n一个参数服务于构成类的base type；每个属性一个参数。\n检查base type和每个参数的类型是否符合要求。\n\n下面是一个具有units属性，class属性为difftime的类构造函数：\n\nnew_difftime &lt;- function(x = double(), units = \"secs\") {\n  stopifnot(is.double(x))\n  units &lt;- match.arg(units, c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))\n\n  structure(x,\n    class = \"difftime\",\n    units = units\n  )\n}\n\nnew_difftime(c(1, 10, 3600), \"secs\")\n#&gt; Time differences in secs\n#&gt; [1]    1   10 3600\n\nnew_difftime(52, \"weeks\")\n#&gt; Time difference of 52 weeks\n\n\n\nValidators\n越复杂的类越需要细致地检查。如下例factor类，虽然有对输入类型检查，但仍然创建了错误的类。\n\nnew_factor &lt;- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nnew_factor(1:5, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\nnew_factor(0:1, \"a\")\n#&gt; Error in as.character.factor(x): malformed factor\n\n想比于构造函数中对base type和参数类型的检查，对类输入的其他检查应该分离为单独的函数。这样当你知道输入是正确时，可以以更低的成本创建类，并且检查方法可以用在其他地方。\n\nvalidate_factor &lt;- function(x) {\n  values &lt;- unclass(x)\n  levels &lt;- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values &gt; 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) &lt; max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nvalidate_factor(new_factor(1:5, \"a\"))\n#&gt; Error: There must be at least as many `levels` as possible values in `x`\nvalidate_factor(new_factor(0:1, \"a\"))\n#&gt; Error: All `x` values must be non-missing and greater than zero\n\n\n\nHelpers\n提供一个方便使用者创建类的函数，遵循以下原则：\n\n函数名和类名相同，myclass()。\n如果存在constructor和validator，函数要使用它们。\n为终端用户创建精心设计的错误消息。。\n有一个精心设计的用户界面，精心选择的默认值和有用的转换\n\n下面是三个常见的示例：\n\n输入参数类型强制转换\n例如上面的new_difftime()对输入十分严格，当输入是integer时报错。\n\nnew_difftime(1:10)\n#&gt; Error in new_difftime(1:10): is.double(x) is not TRUE\n\n可以在helper函数中添加类型强制转换：\n\ndifftime &lt;- function(x = double(), units = \"secs\") {\n  x &lt;- as.double(x)\n  new_difftime(x, units = units)\n}\n\ndifftime(1:10)\n#&gt; Time differences in secs\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n提供有用的默认值\n在生成factor时，提供默认的levels。\n\nfactor &lt;- function(x = character(), levels = unique(x)) {\n  ind &lt;- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"))\n#&gt; [1] a a b\n#&gt; Levels: a b\n\n\n\n使用简单成分组成用户界面\n下面是一个构建POSIXct类的函数，函数的输入都是简单的整数。\n\nPOSIXct &lt;- function(year = integer(),\n                    month = integer(),\n                    day = integer(),\n                    hour = 0L,\n                    minute = 0L,\n                    sec = 0,\n                    tzone = \"\") {\n  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)\n}\n\nPOSIXct(2020, 1, 1, tzone = \"America/New_York\")\n#&gt; [1] \"2020-01-01 EST\""
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#generics-and-methods",
    "href": "Books/Advanced R(2e)/13 S3.html#generics-and-methods",
    "title": "13 S3",
    "section": "Generics and methods",
    "text": "Generics and methods\n如上所述，S3系统的泛函会执行方法分派，该过程由UseMethod()函数实现。该函数有两个参数：\n\ngeneric：字符串类型的泛函名称。\nobject：要分派的对象。\n\n\nx &lt;- structure(1:10, class = \"test\")\nt(x)\n#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n#&gt; [1,]    1    2    3    4    5    6    7    8    9    10\n#&gt; attr(,\"class\")\n#&gt; [1] \"test\"\nt\n#&gt; function (x) \n#&gt; UseMethod(\"t\")\n#&gt; &lt;bytecode: 0x565520c999c8&gt;\n#&gt; &lt;environment: namespace:base&gt;\nt.test\n#&gt; function (x, ...) \n#&gt; UseMethod(\"t.test\")\n#&gt; &lt;bytecode: 0x56551ca39718&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\n\ngeneric2 &lt;- function(x) UseMethod(\"generic2\")\ngeneric2.a1 &lt;- function(x) \"a1\"\n# generic2.a2 &lt;- function(x) \"a2\"\ngeneric2.b &lt;- function(x) {\n  class(x) &lt;- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))\n#&gt; Error in NextMethod(): no method to invoke"
  },
  {
    "objectID": "Books/Advanced R(2e)/13 S3.html#函数总结",
    "href": "Books/Advanced R(2e)/13 S3.html#函数总结",
    "title": "13 S3",
    "section": "函数总结",
    "text": "函数总结\n\nx &lt;- table(rpois(100, 5))\nx\n#&gt; \n#&gt;  1  2  3  4  5  6  7  8  9 10 11 12 \n#&gt;  6  6 14 20 22 14  9  2  2  3  1  1\n\n\ntypeof(x) # 查看base type\n#&gt; [1] \"integer\"\nattributes(x) # 查看属性\n#&gt; $dim\n#&gt; [1] 12\n#&gt; \n#&gt; $dimnames\n#&gt; $dimnames[[1]]\n#&gt;  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\"\n#&gt; \n#&gt; \n#&gt; $class\n#&gt; [1] \"table\"\ns3_class(x) # 查看S3 class\n#&gt; [1] \"table\"\nclass() # 查看class\n#&gt; Error in class(): 0 arguments passed to 'class' which requires 1\ninherits(x, \"classname\") # 判断是否属于classname\n#&gt; [1] FALSE\nsloop::s3_methods_class(\"table\") # 查看类可以用的泛函\n#&gt; # A tibble: 10 × 4\n#&gt;   generic       class visible source             \n#&gt;   &lt;chr&gt;         &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 [             table TRUE    base               \n#&gt; 2 aperm         table TRUE    base               \n#&gt; 3 as.data.frame table TRUE    base               \n#&gt; 4 Axis          table FALSE   registered S3method\n#&gt; 5 lines         table FALSE   registered S3method\n#&gt; 6 plot          table FALSE   registered S3method\n#&gt; # ℹ 4 more rows\nsloop::s3_methods_generic(\"print\") # 查看与泛函相关的类\n#&gt; # A tibble: 294 × 4\n#&gt;   generic class             visible source             \n#&gt;   &lt;chr&gt;   &lt;chr&gt;             &lt;lgl&gt;   &lt;chr&gt;              \n#&gt; 1 print   acf               FALSE   registered S3method\n#&gt; 2 print   activeConcordance FALSE   registered S3method\n#&gt; 3 print   AES               FALSE   registered S3method\n#&gt; 4 print   all_vars          FALSE   registered S3method\n#&gt; 5 print   anova             FALSE   registered S3method\n#&gt; 6 print   any_vars          FALSE   registered S3method\n#&gt; # ℹ 288 more rows\n\nUseMethod()\n#&gt; Error in UseMethod(): there must be a 'generic' argument\n.class2(x)\n#&gt; [1] \"table\"\nmethods(\"print\")\n#&gt;   [1] print.acf*                                          \n#&gt;   [2] print.activeConcordance*                            \n#&gt;   [3] print.AES*                                          \n#&gt;   [4] print.all_vars*                                     \n#&gt;   [5] print.anova*                                        \n#&gt;   [6] print.any_vars*                                     \n#&gt;   [7] print.aov*                                          \n#&gt;   [8] print.aovlist*                                      \n#&gt;   [9] print.ar*                                           \n#&gt;  [10] print.Arima*                                        \n#&gt;  [11] print.arima0*                                       \n#&gt;  [12] print.AsIs                                          \n#&gt;  [13] print.aspell*                                       \n#&gt;  [14] print.aspell_inspect_context*                       \n#&gt;  [15] print.bibentry*                                     \n#&gt;  [16] print.Bibtex*                                       \n#&gt;  [17] print.browseVignettes*                              \n#&gt;  [18] print.by                                            \n#&gt;  [19] print.changedFiles*                                 \n#&gt;  [20] print.check_bogus_return*                           \n#&gt;  [21] print.check_code_usage_in_package*                  \n#&gt;  [22] print.check_compiled_code*                          \n#&gt;  [23] print.check_demo_index*                             \n#&gt;  [24] print.check_depdef*                                 \n#&gt;  [25] print.check_details*                                \n#&gt;  [26] print.check_details_changes*                        \n#&gt;  [27] print.check_doi_db*                                 \n#&gt;  [28] print.check_dotInternal*                            \n#&gt;  [29] print.check_make_vars*                              \n#&gt;  [30] print.check_nonAPI_calls*                           \n#&gt;  [31] print.check_package_code_assign_to_globalenv*       \n#&gt;  [32] print.check_package_code_attach*                    \n#&gt;  [33] print.check_package_code_data_into_globalenv*       \n#&gt;  [34] print.check_package_code_startup_functions*         \n#&gt;  [35] print.check_package_code_syntax*                    \n#&gt;  [36] print.check_package_code_unload_functions*          \n#&gt;  [37] print.check_package_compact_datasets*               \n#&gt;  [38] print.check_package_CRAN_incoming*                  \n#&gt;  [39] print.check_package_datalist*                       \n#&gt;  [40] print.check_package_datasets*                       \n#&gt;  [41] print.check_package_depends*                        \n#&gt;  [42] print.check_package_description*                    \n#&gt;  [43] print.check_package_description_encoding*           \n#&gt;  [44] print.check_package_license*                        \n#&gt;  [45] print.check_packages_in_dir*                        \n#&gt;  [46] print.check_packages_used*                          \n#&gt;  [47] print.check_po_files*                               \n#&gt;  [48] print.check_pragmas*                                \n#&gt;  [49] print.check_Rd_line_widths*                         \n#&gt;  [50] print.check_Rd_metadata*                            \n#&gt;  [51] print.check_Rd_xrefs*                               \n#&gt;  [52] print.check_RegSym_calls*                           \n#&gt;  [53] print.check_S3_methods_needing_delayed_registration*\n#&gt;  [54] print.check_so_symbols*                             \n#&gt;  [55] print.check_T_and_F*                                \n#&gt;  [56] print.check_url_db*                                 \n#&gt;  [57] print.check_vignette_index*                         \n#&gt;  [58] print.checkDocFiles*                                \n#&gt;  [59] print.checkDocStyle*                                \n#&gt;  [60] print.checkFF*                                      \n#&gt;  [61] print.checkRd*                                      \n#&gt;  [62] print.checkRdContents*                              \n#&gt;  [63] print.checkReplaceFuns*                             \n#&gt;  [64] print.checkS3methods*                               \n#&gt;  [65] print.checkTnF*                                     \n#&gt;  [66] print.checkVignettes*                               \n#&gt;  [67] print.citation*                                     \n#&gt;  [68] print.cli_ansi_html_style*                          \n#&gt;  [69] print.cli_ansi_string*                              \n#&gt;  [70] print.cli_ansi_style*                               \n#&gt;  [71] print.cli_boxx*                                     \n#&gt;  [72] print.cli_diff_chr*                                 \n#&gt;  [73] print.cli_doc*                                      \n#&gt;  [74] print.cli_progress_demo*                            \n#&gt;  [75] print.cli_rule*                                     \n#&gt;  [76] print.cli_sitrep*                                   \n#&gt;  [77] print.cli_spark*                                    \n#&gt;  [78] print.cli_spinner*                                  \n#&gt;  [79] print.cli_tree*                                     \n#&gt;  [80] print.codoc*                                        \n#&gt;  [81] print.codocClasses*                                 \n#&gt;  [82] print.codocData*                                    \n#&gt;  [83] print.colorConverter*                               \n#&gt;  [84] print.compactPDF*                                   \n#&gt;  [85] print.condition                                     \n#&gt;  [86] print.connection                                    \n#&gt;  [87] print.CRAN_package_reverse_dependencies_and_views*  \n#&gt;  [88] print.data.frame                                    \n#&gt;  [89] print.Date                                          \n#&gt;  [90] print.default                                       \n#&gt;  [91] print.dendrogram*                                   \n#&gt;  [92] print.density*                                      \n#&gt;  [93] print.difftime                                      \n#&gt;  [94] print.dist*                                         \n#&gt;  [95] print.Dlist                                         \n#&gt;  [96] print.DLLInfo                                       \n#&gt;  [97] print.DLLInfoList                                   \n#&gt;  [98] print.DLLRegisteredRoutines                         \n#&gt;  [99] print.dplyr_join_by*                                \n#&gt; [100] print.dplyr_sel_vars*                               \n#&gt; [101] print.dummy_coef*                                   \n#&gt; [102] print.dummy_coef_list*                              \n#&gt; [103] print.ecdf*                                         \n#&gt; [104] print.eigen                                         \n#&gt; [105] print.element*                                      \n#&gt; [106] print.evaluate_evaluation*                          \n#&gt; [107] print.factanal*                                     \n#&gt; [108] print.factor                                        \n#&gt; [109] print.family*                                       \n#&gt; [110] print.fileSnapshot*                                 \n#&gt; [111] print.findLineNumResult*                            \n#&gt; [112] print.flatGridListing*                              \n#&gt; [113] print.formula*                                      \n#&gt; [114] print.fseq*                                         \n#&gt; [115] print.ftable*                                       \n#&gt; [116] print.fun_list*                                     \n#&gt; [117] print.function                                      \n#&gt; [118] print.getAnywhere*                                  \n#&gt; [119] print.ggplot*                                       \n#&gt; [120] print.ggplot2_bins*                                 \n#&gt; [121] print.ggproto*                                      \n#&gt; [122] print.ggproto_method*                               \n#&gt; [123] print.gList*                                        \n#&gt; [124] print.glm*                                          \n#&gt; [125] print.glue*                                         \n#&gt; [126] print.gpar*                                         \n#&gt; [127] print.GridCoords*                                   \n#&gt; [128] print.GridGrobCoords*                               \n#&gt; [129] print.GridGTreeCoords*                              \n#&gt; [130] print.grob*                                         \n#&gt; [131] print.gtable*                                       \n#&gt; [132] print.hashtab*                                      \n#&gt; [133] print.hcl_palettes*                                 \n#&gt; [134] print.hclust*                                       \n#&gt; [135] print.help_files_with_topic*                        \n#&gt; [136] print.hexmode                                       \n#&gt; [137] print.HoltWinters*                                  \n#&gt; [138] print.hsearch*                                      \n#&gt; [139] print.hsearch_db*                                   \n#&gt; [140] print.htest*                                        \n#&gt; [141] print.html*                                         \n#&gt; [142] print.html_dependency*                              \n#&gt; [143] print.htmltools.selector*                           \n#&gt; [144] print.htmltools.selector.list*                      \n#&gt; [145] print.infl*                                         \n#&gt; [146] print.integrate*                                    \n#&gt; [147] print.isoreg*                                       \n#&gt; [148] print.json*                                         \n#&gt; [149] print.key_missing*                                  \n#&gt; [150] print.kmeans*                                       \n#&gt; [151] print.knitr_kable*                                  \n#&gt; [152] print.last_dplyr_warnings*                          \n#&gt; [153] print.Latex*                                        \n#&gt; [154] print.LaTeX*                                        \n#&gt; [155] print.libraryIQR                                    \n#&gt; [156] print.lifecycle_warnings*                           \n#&gt; [157] print.listof                                        \n#&gt; [158] print.lm*                                           \n#&gt; [159] print.loadings*                                     \n#&gt; [160] print.loess*                                        \n#&gt; [161] print.logLik*                                       \n#&gt; [162] print.ls_str*                                       \n#&gt; [163] print.medpolish*                                    \n#&gt; [164] print.method_table*                                 \n#&gt; [165] print.MethodsFunction*                              \n#&gt; [166] print.mtable*                                       \n#&gt; [167] print.NativeRoutineList                             \n#&gt; [168] print.news_db*                                      \n#&gt; [169] print.nls*                                          \n#&gt; [170] print.noquote                                       \n#&gt; [171] print.numeric_version                               \n#&gt; [172] print.object_size*                                  \n#&gt; [173] print.octmode                                       \n#&gt; [174] print.packageDescription*                           \n#&gt; [175] print.packageInfo                                   \n#&gt; [176] print.packageIQR*                                   \n#&gt; [177] print.packageStatus*                                \n#&gt; [178] print.paged_df*                                     \n#&gt; [179] print.pairwise.htest*                               \n#&gt; [180] print.path*                                         \n#&gt; [181] print.person*                                       \n#&gt; [182] print.pillar*                                       \n#&gt; [183] print.pillar_1e*                                    \n#&gt; [184] print.pillar_colonnade*                             \n#&gt; [185] print.pillar_ornament*                              \n#&gt; [186] print.pillar_shaft*                                 \n#&gt; [187] print.pillar_squeezed_colonnade*                    \n#&gt; [188] print.pillar_tbl_format_setup*                      \n#&gt; [189] print.pillar_vctr*                                  \n#&gt; [190] print.pillar_vctr_attr*                             \n#&gt; [191] print.POSIXct                                       \n#&gt; [192] print.POSIXlt                                       \n#&gt; [193] print.power.htest*                                  \n#&gt; [194] print.ppr*                                          \n#&gt; [195] print.prcomp*                                       \n#&gt; [196] print.princomp*                                     \n#&gt; [197] print.proc_time                                     \n#&gt; [198] print.purrr_function_compose*                       \n#&gt; [199] print.purrr_function_partial*                       \n#&gt; [200] print.purrr_rate_backoff*                           \n#&gt; [201] print.purrr_rate_delay*                             \n#&gt; [202] print.quosure*                                      \n#&gt; [203] print.quosures*                                     \n#&gt; [204] print.R6*                                           \n#&gt; [205] print.R6ClassGenerator*                             \n#&gt; [206] print.raster*                                       \n#&gt; [207] print.Rconcordance*                                 \n#&gt; [208] print.Rd*                                           \n#&gt; [209] print.recordedplot*                                 \n#&gt; [210] print.rel*                                          \n#&gt; [211] print.restart                                       \n#&gt; [212] print.RGBcolorConverter*                            \n#&gt; [213] print.RGlyphFont*                                   \n#&gt; [214] print.rlang_box_done*                               \n#&gt; [215] print.rlang_box_splice*                             \n#&gt; [216] print.rlang_data_pronoun*                           \n#&gt; [217] print.rlang_dict*                                   \n#&gt; [218] print.rlang_dyn_array*                              \n#&gt; [219] print.rlang_envs*                                   \n#&gt; [220] print.rlang_error*                                  \n#&gt; [221] print.rlang_fake_data_pronoun*                      \n#&gt; [222] print.rlang_lambda_function*                        \n#&gt; [223] print.rlang_message*                                \n#&gt; [224] print.rlang_trace*                                  \n#&gt; [225] print.rlang_warning*                                \n#&gt; [226] print.rlang_zap*                                    \n#&gt; [227] print.rlang:::list_of_conditions*                   \n#&gt; [228] print.rle                                           \n#&gt; [229] print.rlib_bytes*                                   \n#&gt; [230] print.rlib_error_3_0*                               \n#&gt; [231] print.rlib_trace_3_0*                               \n#&gt; [232] print.roman*                                        \n#&gt; [233] print.scalar*                                       \n#&gt; [234] print.sessionInfo*                                  \n#&gt; [235] print.shiny.tag*                                    \n#&gt; [236] print.shiny.tag.env*                                \n#&gt; [237] print.shiny.tag.list*                               \n#&gt; [238] print.shiny.tag.query*                              \n#&gt; [239] print.simple.list                                   \n#&gt; [240] print.smooth.spline*                                \n#&gt; [241] print.socket*                                       \n#&gt; [242] print.src*                                          \n#&gt; [243] print.srcfile                                       \n#&gt; [244] print.srcref                                        \n#&gt; [245] print.stepfun*                                      \n#&gt; [246] print.stl*                                          \n#&gt; [247] print.StructTS*                                     \n#&gt; [248] print.subdir_tests*                                 \n#&gt; [249] print.summarize_CRAN_check_status*                  \n#&gt; [250] print.summary.aov*                                  \n#&gt; [251] print.summary.aovlist*                              \n#&gt; [252] print.summary.ecdf*                                 \n#&gt; [253] print.summary.glm*                                  \n#&gt; [254] print.summary.lm*                                   \n#&gt; [255] print.summary.loess*                                \n#&gt; [256] print.summary.manova*                               \n#&gt; [257] print.summary.nls*                                  \n#&gt; [258] print.summary.packageStatus*                        \n#&gt; [259] print.summary.ppr*                                  \n#&gt; [260] print.summary.prcomp*                               \n#&gt; [261] print.summary.princomp*                             \n#&gt; [262] print.summary.table                                 \n#&gt; [263] print.summary.warnings                              \n#&gt; [264] print.summaryDefault                                \n#&gt; [265] print.table                                         \n#&gt; [266] print.tables_aov*                                   \n#&gt; [267] print.tbl*                                          \n#&gt; [268] print.terms*                                        \n#&gt; [269] print.theme*                                        \n#&gt; [270] print.transform*                                    \n#&gt; [271] print.trunc_mat*                                    \n#&gt; [272] print.ts*                                           \n#&gt; [273] print.tskernel*                                     \n#&gt; [274] print.TukeyHSD*                                     \n#&gt; [275] print.tukeyline*                                    \n#&gt; [276] print.tukeysmooth*                                  \n#&gt; [277] print.undoc*                                        \n#&gt; [278] print.uneval*                                       \n#&gt; [279] print.unit*                                         \n#&gt; [280] print.vctrs_bytes*                                  \n#&gt; [281] print.vctrs_sclr*                                   \n#&gt; [282] print.vctrs_unspecified*                            \n#&gt; [283] print.vctrs_vctr*                                   \n#&gt; [284] print.viewport*                                     \n#&gt; [285] print.vignette*                                     \n#&gt; [286] print.warnings                                      \n#&gt; [287] print.xfun_md_viewable*                             \n#&gt; [288] print.xfun_raw_string*                              \n#&gt; [289] print.xfun_record_results*                          \n#&gt; [290] print.xfun_rename_seq*                              \n#&gt; [291] print.xfun_strict_list*                             \n#&gt; [292] print.xgettext*                                     \n#&gt; [293] print.xngettext*                                    \n#&gt; [294] print.xtabs*                                        \n#&gt; see '?methods' for accessing help and source code"
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html",
    "href": "Books/Advanced R(2e)/1 Introduction.html",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#why-r",
    "href": "Books/Advanced R(2e)/1 Introduction.html#why-r",
    "title": "1 Introduction",
    "section": "",
    "text": "一千个人有一千个哈姆雷特。对于我而言，我因为生物信息了解R，因为tidyverse的编程哲学喜欢上了R。但R不是一个很严谨的语言，需要不断学习尝试，遵循一定惯例。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#who-should-read-this-book",
    "href": "Books/Advanced R(2e)/1 Introduction.html#who-should-read-this-book",
    "title": "1 Introduction",
    "section": "Who should read this book",
    "text": "Who should read this book\n本书适合两类人：\n\n中级 R 程序员，他们希望更深入地研究 R 语言，理解语言的工作原理，并学习解决各种问题的新策略。\n来自其他语言的程序员，他们正在学习 R，并且想要理解为什么 R 是这样工作的。\n\n为了阅读这本书之前，你需要用 R 或其他编程语言编写大量的代码，熟悉数据分析的基础知识 (即数据导入、操作和可视化) ，熟悉 CRAN 包的安装和使用。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-get-out-of-this-book",
    "href": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-get-out-of-this-book",
    "title": "1 Introduction",
    "section": "What you will get out of this book",
    "text": "What you will get out of this book\n阅读本书，你可以：\n\n熟悉 R 的基础知识。你将了解复杂数据类型以及对它们执行操作的最佳方法，对函数如何工作有深入的了解，知道什么是环境，以及如何使用条件系统。\n理解函数式编程的含义，以及为什么它是数据科学的有用工具。你将能够快速学习如何使用现有的工具，并且具备在需要时创建自己的功能性工具的知识。\n了解 R 的各种面向对象系统。你将最熟悉 S3，并且知道 S4 和 R6，以及在需要时在哪里查找更多信息。\n欣赏元编程的双刃剑。你将能够创建使用整洁计算、保存类型和创建优雅代码来表示重要操作的函数，也会明白什么是危险，什么时候应该避免。\n有一个良好的直觉，在 R 中的操作是缓慢的或使用大量的内存。你将知道如何使用分析来查明性能瓶颈，并且知道足够多的 C++ 来将慢速 R 函数转换为快速 C++ 等价物。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-not-learn",
    "href": "Books/Advanced R(2e)/1 Introduction.html#what-you-will-not-learn",
    "title": "1 Introduction",
    "section": "What you will not learn",
    "text": "What you will not learn\n本书不涉及：\n\n如何进行数据分析，数据分析推荐R for Data Science。\n如何生成R包，构建R包推荐R packages。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#meta-techniques",
    "href": "Books/Advanced R(2e)/1 Introduction.html#meta-techniques",
    "title": "1 Introduction",
    "section": "Meta-techniques",
    "text": "Meta-techniques\n提升编程能力的两个途径：\n\n阅读源代码。\n采用科学思维",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#recommended-reading",
    "href": "Books/Advanced R(2e)/1 Introduction.html#recommended-reading",
    "title": "1 Introduction",
    "section": "Recommended reading",
    "text": "Recommended reading\n\nThe Structure and Interpretation of Computer Programs：提升R面向对象的理解。\nConcepts, Techniques and Models of Computer Programming：理解R与其他语言的差异。\nThe Pragmatic Programmer",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#getting-help",
    "href": "Books/Advanced R(2e)/1 Introduction.html#getting-help",
    "title": "1 Introduction",
    "section": "Getting help",
    "text": "Getting help\n在遇到困难寻求帮助时，下面是一些问答网站：\n\nRstudio Community\nStackOverflow\nR-help mailing list\n\n在寻求帮助前，你要：\n\n确定你的R版本和R包版本，及环境。\n给出一个复现问题的最小示例（reprex）。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#acknowledgments",
    "href": "Books/Advanced R(2e)/1 Introduction.html#acknowledgments",
    "title": "1 Introduction",
    "section": "Acknowledgments",
    "text": "Acknowledgments\n…",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#conventions",
    "href": "Books/Advanced R(2e)/1 Introduction.html#conventions",
    "title": "1 Introduction",
    "section": "Conventions",
    "text": "Conventions\n对本书中的一些符号进行说明：\n\nf() 表示函数\ng 表示变量和函数参数\nh/ 表示路径\n#&gt; 表示终端运行结果\nset.seed(1014) 每章固定随机数种子",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/1 Introduction.html#colophon",
    "href": "Books/Advanced R(2e)/1 Introduction.html#colophon",
    "title": "1 Introduction",
    "section": "Colophon",
    "text": "Colophon\n书中的R 和 R包版本会实时更新，请阅读原文了解详细信息。",
    "crumbs": [
      "1 Introduction"
    ]
  },
  {
    "objectID": "Blog/Code chunks.html",
    "href": "Blog/Code chunks.html",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#label",
    "href": "Blog/Code chunks.html#label",
    "title": "quarto 中R代码块的设置",
    "section": "",
    "text": "每个代码块可以设置一个label，用来标记代码块和代码块的结果，可以用于交叉引用。\n```{r}\n#| label: simple-addition\n\n1 + 1\n```"
  },
  {
    "objectID": "Blog/Code chunks.html#execute",
    "href": "Blog/Code chunks.html#execute",
    "title": "quarto 中R代码块的设置",
    "section": "execute",
    "text": "execute\n可以使用execute选项来控制代码块；下面是对可用参数的总结。"
  },
  {
    "objectID": "Blog/Code chunks.html#knitr",
    "href": "Blog/Code chunks.html#knitr",
    "title": "quarto 中R代码块的设置",
    "section": "knitr",
    "text": "knitr\n因为quarto除对R代码块支持外，还支持python、Julia，所以除通用设置execute，quarto 还有R语言特有的设置——knitr。\nknitr:\n  opts_chunk:\n    comment: \"#&gt;\"\n    collapse: true\n上面的设置可以自动将R代码的运行结果于代码拼接起来，并使用#&gt;作为注释，达到下面的效果。\n\n1 + 1\n#&gt; 2"
  },
  {
    "objectID": "Blog/Code chunks.html#行代码",
    "href": "Blog/Code chunks.html#行代码",
    "title": "quarto 中R代码块的设置",
    "section": "行代码",
    "text": "行代码\n处理上面使用```{r}的代码块，quarto还使用`r的行代码。"
  },
  {
    "objectID": "Blog/Object in R1.html#成为面对对象的五个条件",
    "href": "Blog/Object in R1.html#成为面对对象的五个条件",
    "title": "R 中的面向对象(1)",
    "section": "成为面对对象的五个条件",
    "text": "成为面对对象的五个条件\n\n类\n对象\n继承\n封装\n多态\n\n定义一个类，这个类有一些属性和方法，方法被封装为接口和实现；类可以实例化一个对象；类之间具有父子关系，子类可以继承父类的属性和方法；不同类的方法名是重复的，可以根据类选择对应的实现，这称之为多态。"
  },
  {
    "objectID": "Blog/Object in R1.html#为什么使用面向对象",
    "href": "Blog/Object in R1.html#为什么使用面向对象",
    "title": "R 中的面向对象(1)",
    "section": "为什么使用面向对象：",
    "text": "为什么使用面向对象：\n\n封装提供了标准的使用接口，能够降低系统的耦合度。\n继承允许子类继承父类的特性，提高了代码的重用性。\n多态允许相同函数对于不同的类有不同的行为，提高了代码的灵活性。\n\n想象一下，当你想更新一个函数的使用方法，但是又得保持和以前的兼容性，你只需要再创建一个子类，然后重新实现父类的方法，就可以了。"
  },
  {
    "objectID": "Blog/Object in R1.html#r-中的面向对象",
    "href": "Blog/Object in R1.html#r-中的面向对象",
    "title": "R 中的面向对象(1)",
    "section": "R 中的面向对象",
    "text": "R 中的面向对象\nR 语言中存在多种面向对象的编程，包括封装类的如RC，R6；泛函类的如S3，S4等。\n\n基于S3的面向对象编程基于泛型函数（generic function），不基于类层级结构,没有类的继承，没有严格的层级结构式继承。\n基于S4的面向对象编程，相对S3健全，实现了类的继承，具有严格的层级结构式类继承，但是是在函数封装过程中同S3一样，基于泛型函数。\n基于RC（也称S5）的面向对象编程则更加完善，符合上面的要求。\n基于R6包的面向对象编程，同样符合上面的要求。\n基于proto包的面向对象编程在ggplot2包中使用。\n基于R.oo包的面向对象编程类似S3。"
  },
  {
    "objectID": "Blog/Object in R1.html#sloop-包",
    "href": "Blog/Object in R1.html#sloop-包",
    "title": "R 中的面向对象(1)",
    "section": "sloop 包",
    "text": "sloop 包\n包中的函数sloop::otype()可以用来检查对象的面向对象编程类型。\n\nlibrary(sloop)\n\notype(1:10)\n#&gt; [1] \"base\"\n\notype(mtcars)\n#&gt; [1] \"S3\"\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\notype(mle_obj)\n#&gt; [1] \"S4\""
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html",
    "href": "Books/Advanced R(2e)/12 Base types.html",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此对象非彼对象，前者指得是来自于S语言的base object，同我们研究的面向对象(OO object)不是一回事。\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#introduction",
    "href": "Books/Advanced R(2e)/12 Base types.html#introduction",
    "title": "12 Base types",
    "section": "",
    "text": "在R中，流传着这么一句话——R里的一切都是对象。但此对象非彼对象，前者指得是来自于S语言的base object，同我们研究的面向对象(OO object)不是一回事。\n下面我们介绍如何区分base object和OO object及所有base object的类别。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#base-vs-oo-objects",
    "href": "Books/Advanced R(2e)/12 Base types.html#base-vs-oo-objects",
    "title": "12 Base types",
    "section": "Base VS OO objects",
    "text": "Base VS OO objects\n区分二者的三种方法：\n\nis.object()：base object返回FALSE，OO object返回TRUE。\nsloop::otype()：base object返回base，OO object返回其他，如S3。\nattr()：base object返回NULL，OO object返回class属性。\n\n\nis.object(1:10)\n#&gt; [1] FALSE\nis.object(mtcars)\n#&gt; [1] TRUE\n\nsloop::otype(1:10)\n#&gt; [1] \"base\"\nsloop::otype(mtcars)\n#&gt; [1] \"S3\"\n\nattr(1:10, \"class\")\n#&gt; NULL\nattr(mtcars, \"class\")\n#&gt; [1] \"data.frame\"",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/12 Base types.html#base-types",
    "href": "Books/Advanced R(2e)/12 Base types.html#base-types",
    "title": "12 Base types",
    "section": "Base types",
    "text": "Base types\n无论是OO object还是base object，都有一个base type，使用typeof()来查看；不要使用mode()或storage.mode()，它们只适配S语言。\n\ntypeof(1:10)\n#&gt; [1] \"integer\"\n\ntypeof(mtcars)\n#&gt; [1] \"list\"\n\ntypeof(mean)\n#&gt; [1] \"closure\"\n\nR 的底层使用了C语言中的switch语句来对不同base type执行不同处理。想要新增一个base type需要修改R-core，所以通常不会随意增加base type。截至目前一共有25种base type，下面按照本书中出现的顺序列举。\n\nVector\n\n\n\nbase Type\nC Type\n\n\n\n\nNULL\nNILSXP\n\n\nlogical\nLGLSXP\n\n\ninteger\nINTSXP\n\n\ndouble\nREALSXP\n\n\ncomplex\nCPLXSXP\n\n\ncharacter\nSTRSXP\n\n\nlist\nVECSXP\n\n\nraw\nRAWSXP\n\n\n\n\ntypeof(NULL)\n#&gt; [1] \"NULL\"\ntypeof(1L)\n#&gt; [1] \"integer\"\ntypeof(1i)\n#&gt; [1] \"complex\"\n\n\n\nFunctions\n\n\n\nbase Type\nC Type\nfunction type\n\n\n\n\nclosure\nCLOSXP\nregular R functions\n\n\nspecial\nSPECIALSXP\ninternal functions\n\n\nbuiltin\nBUILTINSXP\nprimitive functions\n\n\n\n\ntypeof(mean)\n#&gt; [1] \"closure\"\ntypeof(`[`)\n#&gt; [1] \"special\"\ntypeof(sum)\n#&gt; [1] \"builtin\"\n\n\n\nEnvironments\n\n\n\nbase Type\nC Type\n\n\n\n\nenvironment\nENVSXP\n\n\n\n\ntypeof(globalenv())\n#&gt; [1] \"environment\"\n\n\n\nS4\n\n\n\nbase Type\nC Type\n\n\n\n\nS4\nS4SXP\n\n\n\n\nmle_obj &lt;- stats4::mle(function(x = 1) (x - 2)^2)\ntypeof(mle_obj)\n#&gt; [1] \"S4\"\n\n\n\nLanguage components\n\n\n\nbase Type\nC Type\n\n\n\n\nsymbol\nSYMSXP\n\n\nlanguage\nLANGSXP\n\n\npairlist\nLISTSXP\n\n\nexpression\nEXPRSXP\n\n\n\n\ntypeof(quote(a))\n#&gt; [1] \"symbol\"\ntypeof(quote(a + 1))\n#&gt; [1] \"language\"\ntypeof(formals(mean))\n#&gt; [1] \"pairlist\"\ntypeof(expression(1 + 0:9))\n#&gt; [1] \"expression\"\n\n\n\nOthers\n\n\n\nbase Type\nC Type\n\n\n\n\nexternalptr\nEXTPTRSXP\n\n\nweakref\nWEAKREFSXP\n\n\nbytecode\nBCODESXP\n\n\npromise\nPROMSXP\n\n\n...\nDOTSXP\n\n\nany\nANYSXP\n\n\n\n\n\nNumeric type\n“numeric”在R中存在三种解读：\n\n某些地方，numeric是double的别名。例如as.numeric()和as.double()等价，numeric()和double()等价。\n在S3和S4系统中，“numeric”用作”integer type”或”double type”的缩写：\n\nsloop::s3_class(1)\n#&gt; [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#&gt; [1] \"integer\" \"numeric\"\n\nis.numeric()用来检测那些行为类似number的对象。例如，因子的本质是”integer type”，但是没有number的行为（求取一个因子的均值毫无意义）。\n\ntypeof(factor(\"x\"))\n#&gt; [1] \"integer\"\nis.numeric(factor(\"x\"))\n#&gt; [1] FALSE\n\n\n本书中的numeric表示integer或double。",
    "crumbs": [
      "12 Base types"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html",
    "href": "Books/Advanced R(2e)/2 Names and values.html",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#introduction",
    "href": "Books/Advanced R(2e)/2 Names and values.html#introduction",
    "title": "2 Names and values",
    "section": "",
    "text": "厘清object和其name的区别十分重要，这可以帮助你：\n\n精准地判断代码对内存的消耗。\n理解代码运行缓慢的原因并优化。\n更好理解R的函数式编程。\n\n\n\n\n\n\n\nTip\n\n\n\n创建一个对象，你不需要使用&lt;-来绑定一个名字。1:10能创建一个，x &lt;- 1:10也能创建一个。\n\n\n\n\n\n2.2节：介绍对象和其name的不同。\n2.3节：copy-on-modify模式，使用tracemem()追踪对象内存地址变化。\n2.4节：R 对象消耗的内存，使用lobstr::obj_size()查看占用大小。\n2.5节：copy-on-modify模式的两个例外，环境对象和只有一个name的对象。\n2.6节：使用gc()释放内存。\n\n\n\n\n\nlibrary(lobstr)\n\n\n\n\n本章节的很多内容来自于下面3处：\n\nR documentation: ?Memory, ?gc.\nmemory profiling in Writing R extensions.\nSEXPs in R internals",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#binding-basics",
    "href": "Books/Advanced R(2e)/2 Names and values.html#binding-basics",
    "title": "2 Names and values",
    "section": "Binding basics",
    "text": "Binding basics\n考虑下面的代码：\n\nx &lt;- c(1, 2, 3)\ny &lt;- x\n\n我们创建了一个名为x，值为1,2,3的对象，然后复制了一份讲其命名为y。那么，R在内存中是否也复制了一份，也即消耗了2倍的内存呢？事实上，此时消耗的内存并不是两倍，实际情况如下图所示。\n\n解释一下：\n\nc(1,2,3)创建了对象，并占用内存，地址为0x74b。\n&lt;- 为对象绑定一个名字，即x。\ny &lt;- x虽然将x复制了一份，但是x和y的值相同，都是对象c(1,2,3)，所以内存地址是不变。\n\n也即是说：内存和&lt;-后面的对象有关系，后面的不变，内存地址不变，内存消耗几乎不变；&lt;-前面的只是对象绑定的名字，因为实际的内存地址会随着终端变动而发生变动，需要绑定一个标签，你在代码的其他地方可以调用。\n查看对象的地址可以使用lobstr::obj_addr()，当你运行时，结果肯定与我的结果不同，因为终端发生了变动。\n\nobj_addr(x)\n#&gt; [1] \"0x55d0df84afd8\"\nobj_addr(y)\n#&gt; [1] \"0x55d0df84afd8\"\n\n请注意：上述说的“x和y的值相同”，与“创建值相同的两个对象”不同。\n\na &lt;- c(1, 2, 3)\nb &lt;- c(1, 2, 3)\nobj_addr(a)\n#&gt; [1] \"0x55d0e04a6578\"\nobj_addr(b)\n#&gt; [1] \"0x55d0e04a5c18\"\n\n\nNon-syntactic names\nR 中对变量名的要求：必须由字母、数字、.、_构成，但_、数字、.+数字不能位于开头；不能使用关键字，查看关键字?Reserved；使用` 可以将任意字符包裹起来当作变量名；不建议使用'或\"将变量名包裹。\n\n_abc &lt;- 1\n\nif &lt;- 10\n\n`_abc` &lt;- 1\n`_abc`\n\n`if` &lt;- 10\n`if`\n#&gt; Error in parse(text = input): &lt;text&gt;:1:2: unexpected symbol\n#&gt; 1: _abc\n#&gt;      ^\n\n\n\nExercises\n\n下面所指的mean函数内存地址都相同。\n\n\nobj_addr(mean)\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(base::mean)\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(get(\"mean\"))\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(evalq(mean))\n#&gt; [1] \"0x55d0d8d06cf0\"\nobj_addr(match.fun(\"mean\"))\n#&gt; [1] \"0x55d0d8d06cf0\"\n\n\nutils::read.csv()添加参数check.names = FALSE可以抑制列名的强制转换。\nmake.names()在将非法名转换为合法名时，会遵循下面的规则：\n\n必要时添加前缀X。\n非法字符转换为.。\n缺失值转换为NA。\nR中的关键字后添加.。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#copy-on-modify",
    "href": "Books/Advanced R(2e)/2 Names and values.html#copy-on-modify",
    "title": "2 Names and values",
    "section": "Copy-on-modify",
    "text": "Copy-on-modify\n诚如上述，当对象相同时，没有发生内存的消耗；但是如果对y进行了值得修改，那么内存会发生变动，如下所示。\n\ny[[3]] &lt;- 4\nx\n#&gt; [1] 1 2 3\ny\n#&gt; [1] 1 2 4\nobj_addr(x)\n#&gt; [1] \"0x55d0df84afd8\"\nobj_addr(y)\n#&gt; [1] \"0x55d0e0e6d1c8\"\n\nx绑定得原对象值未改变，R 创建新的对象，重新与y进行绑定。\n\n如果你修改多次对象，R 会创建多个新的对象，然后重新绑定，但是旧的对象不会消失，仍然存在于内存中，如下所示。\n\ny[[3]] &lt;- 5\nobj_addr(y)\n#&gt; [1] \"0x55d0e0c68198\"\n\n\n\n\n\n\n\nNote\n\n\n\n请注意：在Rstudio中进行上述内存地址检查时，会有所不同。\n\n\n\ntracemem()\ntracemem()可以跟踪对象，在对象发生变动时显示变动情况，如下所示。\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x55d0df84afd8&gt;\n\ny &lt;- x\ny[[3]] &lt;- 4L\n#&gt; tracemem[0x55d0df84afd8 -&gt; 0x55d0df8f8288]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\ny[[3]] &lt;- 5L\n\n使用untracemem()可以停止跟踪，如下所示。\n\nuntracemem(y)\ny[[3]] &lt;- 6L\n\n\n\nFunction calls\n函数生成对象时遵循相同的规则，如下所示。\n\nf &lt;- function(a) {\n  a\n}\n\ncat(tracemem(x), \"\\n\")\n#&gt; &lt;0x55d0df84afd8&gt;\n\nz &lt;- f(x)\n# there's no copy here!\n\nuntracemem(x)\n\n\n解释一下：\n\n黄色部分表示函数，有参数a。\n灰色部分表示执行环境，返回函数运行后的结果a。\n因为返回结果和x一致，没有改变对象，所以仍然绑定相同的对象。\n当函数返回结果与x不一致时，会创建新的对象，重新绑定。\n\n\n\nLists\n与上面的向量不同，list格式的对象不仅本身有内存地址指定，它的元素也有内存地址指定。\n下面是一个简单的list对象，虽然看似简单，但是在内存分配上却不简单。\n\nl1 &lt;- list(1, 2, 3)\n\n\n当复制list对象时，同样内存不会发生改变：\n\nl2 &lt;- l1\n\n\n当复制的对象l2发生元素变动时，虽然R会创建一个新的内存地址，但同上面的情况略有不同：对list的复制是浅复制，不会复制所有的元素。与浅复制相对的是深复制，在R 3.1.0之前，都是深复制。\n\nl2[[3]] &lt;- 4\n\n\n使用lobstr::ref()可以查看list中每个元素的内存地址。注意对一个list单独使用，和对两个list同时使用的结果中前面的数字有不同（自己尝试一下）。\n\nref(l1, l2)\n#&gt; █ [1:0x55d0e0ae7878] &lt;list&gt; \n#&gt; ├─[2:0x55d0e0f33df8] &lt;dbl&gt; \n#&gt; ├─[3:0x55d0e0f33c38] &lt;dbl&gt; \n#&gt; └─[4:0x55d0e0f33a78] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [5:0x55d0decabc68] &lt;list&gt; \n#&gt; ├─[2:0x55d0e0f33df8] \n#&gt; ├─[3:0x55d0e0f33c38] \n#&gt; └─[6:0x55d0de935b58] &lt;dbl&gt;\n\n关于list中的内存指向，你可以试着嵌套一些复杂的list，然后观察内存分配情况。\n\n\nData frames\ndata.frame 其本质就是list，所以它的行为同list一样。\n\nd1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 &lt;- d1\nd2[, 2] &lt;- d2[, 2] * 2\nd3 &lt;- d1\nd3[1, ] &lt;- d3[1, ] * 3\n\nref(d1, d2, d3)\n#&gt; █ [1:0x55d0dfd0a848] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x55d0dfc799f8] &lt;dbl&gt; \n#&gt; └─y = [3:0x55d0dfc799a8] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [4:0x55d0dfd42ee8] &lt;df[,2]&gt; \n#&gt; ├─x = [2:0x55d0dfc799f8] \n#&gt; └─y = [5:0x55d0dfcc9848] &lt;dbl&gt; \n#&gt;  \n#&gt; █ [6:0x55d0dfd70f68] &lt;df[,2]&gt; \n#&gt; ├─x = [7:0x55d0dfd41b98] &lt;dbl&gt; \n#&gt; └─y = [8:0x55d0dfd41b48] &lt;dbl&gt;\n\n\n\nCharacter vectors\n对于字符串类型的向量，R 使用全局字符串池来储存字符串。\n\nx &lt;- c(\"a\", \"a\", \"abc\", \"d\")\ny &lt;- c(\"a\", \"d\")\nz &lt;- list(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n#&gt; █ [1:0x55d0e0566f78] &lt;chr&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] \n#&gt; ├─[3:0x55d0d92ae280] &lt;string: \"abc\"&gt; \n#&gt; └─[4:0x55d0d91f9d30] &lt;string: \"d\"&gt;\nref(y, character = TRUE)\n#&gt; █ [1:0x55d0e0776c78] &lt;chr&gt; \n#&gt; ├─[2:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; └─[3:0x55d0d91f9d30] &lt;string: \"d\"&gt;\nref(z, character = TRUE)\n#&gt; █ [1:0x55d0e0565a88] &lt;list&gt; \n#&gt; ├─█ [2:0x55d0df3484b8] &lt;chr&gt; \n#&gt; │ └─[3:0x55d0d8d8bd90] &lt;string: \"a\"&gt; \n#&gt; ├─█ [4:0x55d0df3482f8] &lt;chr&gt; \n#&gt; │ └─[3:0x55d0d8d8bd90] \n#&gt; ├─█ [5:0x55d0df348138] &lt;chr&gt; \n#&gt; │ └─[6:0x55d0d92ae280] &lt;string: \"abc\"&gt; \n#&gt; └─█ [7:0x55d0df347f78] &lt;chr&gt; \n#&gt;   └─[8:0x55d0d91f9d30] &lt;string: \"d\"&gt;\n\n\n\n\nExercises\n\n1:10在内存中创建了对象，但是没有绑定，R无法对没有name的对象进行操作。\nx最先是integer类型，x[[3]] &lt;- 4 使用了double类型的数据替换，会导致R先复制一份double类型的向量，然后再替换数据。数据类型见下一章。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#object-size",
    "href": "Books/Advanced R(2e)/2 Names and values.html#object-size",
    "title": "2 Names and values",
    "section": "Object size",
    "text": "Object size\n使用lobstr::obj_size()可以查看对象的大小。\n\nobj_size(letters)\n#&gt; 1.71 kB\nobj_size(ggplot2::diamonds)\n#&gt; 3.46 MB\n\nlist对象，因为有上述的浅复制机制，实际大小会与想象的不同。\n\nx &lt;- runif(1e6)\nobj_size(x)\n#&gt; 8.00 MB\n\ny &lt;- list(x, x, x)\nobj_size(y)\n#&gt; 8.00 MB\n\n上述对象中，y比x要略大一些，大约80b，因为包含了三份空元素的list大小是80b。\n\nobj_size(list(NULL, NULL, NULL))\n#&gt; 80 B\n\n字符串向量也有相同的现象。\n\nbanana &lt;- \"bananas bananas bananas\"\nobj_size(banana)\n#&gt; 136 B\nobj_size(rep(banana, 100))\n#&gt; 928 B\n\n\nExercises\n…",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#modify-in-place",
    "href": "Books/Advanced R(2e)/2 Names and values.html#modify-in-place",
    "title": "2 Names and values",
    "section": "Modify-in-place",
    "text": "Modify-in-place\n诚如上述，当复制的对象发生值的改动，R会复制一份新，然后再修改值。但存在两个特例：\n\n当对象只绑定了一个name时，会直接修改对象的值。\n环境变量是一个特殊的对象，它总是直接修改对象的值。\n\n\nObjects with a single binding\n上面提到的“当对象只绑定了一个name时，会直接修改对象的值”，我在实际使用中，发现内存地址会发生变化。我简单的在不同系统中进行了实验，推测可能是系统原因。\n\nv &lt;- c(1, 2, 3)\nlobstr::obj_addr(v)\n#&gt; [1] \"0x55d0de95c0e8\"\nv[[3]] &lt;- 4\nlobstr::obj_addr(v)\n#&gt; [1] \"0x55d0de9607e8\"\n\n在R中存在下面两种情况，使得无法准确预测是否会发生复制:\n\nR 对于对象所绑定的name统计只能统计为：0，1，many；一旦对象绑定了多个name，那么就会始终被认为是many，无法回退。\n绝大多数函数都会复制对象，除非是用C语言实现的函数。\n\n例如下面的示例（按道理，上面的示例应该是不会发生变化的）：\n\n# 复制一份对象，a,b的地址是一样的\na &lt;- c(1,2,3)\nb &lt;- a\nlobstr::obj_addr(a)\n#&gt; [1] \"0x55d0df898108\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x55d0df898108\"\n# 当把名字a绑定另外一个对象后，在修改b的值，b的内存地址会发生变化\na &lt;- c(2,3,4)\nb[[3]] &lt;- 4\nlobstr::obj_addr(a)\n#&gt; [1] \"0x55d0df983d48\"\nlobstr::obj_addr(b)\n#&gt; [1] \"0x55d0df9f9588\"\n\n上面所描述的对象复制过程，也是R base中for loop缓慢的原因，即for loop本身并不慢，而是因为每次循环都会发生复制修改对象的操作，导致运行缓慢。下面示例中每次循环都会发生两次复制，而转换为list结构时，总共只发生一次复制。\n\nx &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians &lt;- vapply(x, median, numeric(1))\n\n\n# 每次循环都复制两次\ncat(tracemem(x), \"\\n\")\n\nfor (i in 1:5) {\n  x[[i]] &lt;- x[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x564653d5bca8 -&gt; 0x564656d3b6e8]:\n#&gt; tracemem[0x564656d3b6e8 -&gt; 0x564656d3b838]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3b838 -&gt; 0x564656d3b9f8]:\n#&gt; tracemem[0x564656d3b9f8 -&gt; 0x564656d3bbb8]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bbb8 -&gt; 0x564656d3be58]:\n#&gt; tracemem[0x564656d3be58 -&gt; 0x564656d3bf38]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3bf38 -&gt; 0x564656d3c248]:\n#&gt; tracemem[0x564656d3c248 -&gt; 0x564656d3c558]: [[&lt;-.data.frame [[&lt;-\n#&gt; tracemem[0x564656d3c558 -&gt; 0x564656d3cc58]:\n#&gt; tracemem[0x564656d3cc58 -&gt; 0x564656d37838]: [[&lt;-.data.frame [[&lt;-\nuntracemem(x)\n\n\n\n# 总共复制一次\ny &lt;- as.list(x)\ncat(tracemem(y), \"\\n\")\n#&gt; &lt;0x55d0db6c7c68&gt;\n\nfor (i in 1:5) {\n  y[[i]] &lt;- y[[i]] - medians[[i]]\n}\n#&gt; tracemem[0x55d0db6c7c68 -&gt; 0x55d0df9b5568]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\n\n\nEnvironments\n环境变量储存着对象和name之间的绑定关系，它总是直接修改对象的值，不会进行复制。因为环境本质是一个查找表，存储变量名及其值，如果它们像向量或列表那样每次修改时都进行复制的话，会导致显著的性能开销。\n\ne1 &lt;- rlang::env(a = 1, b = 2, c = 3)\ne2 &lt;- e1\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x55d0d98d3df8\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x55d0d98d3df8\"\n\n\n\ne1$c &lt;- 4\ne2$c\n#&gt; [1] 4\n\nlobstr::obj_addr(e1)\n#&gt; [1] \"0x55d0d98d3df8\"\nlobstr::obj_addr(e2)\n#&gt; [1] \"0x55d0d98d3df8\"",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/2 Names and values.html#unbinding-and-the-garbage-collector",
    "href": "Books/Advanced R(2e)/2 Names and values.html#unbinding-and-the-garbage-collector",
    "title": "2 Names and values",
    "section": "Unbinding and the garbage collector",
    "text": "Unbinding and the garbage collector\n关于garbage collector（gc），可以总结为以下几点：\n\nrm()只是解除name绑定，不会清除对象。\nR 环境中没有name绑定的对象，使用gc()会被清除掉。\nR 会在内存不足时自动运行gc()，使用gcinfo(TRUE)后，R每次gc()都会输出信息。\n你无需手动运行gc()，这是没有必要的操作。",
    "crumbs": [
      "2 Names and values"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Foundations Introduction.html",
    "href": "Books/Advanced R(2e)/Foundations Introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "第二章：object和它的name之间的区别。认识到它们的区别，你会在复制对象时更加的小心，因为这涉及内存的消耗，你会明白哪些操作是廉价的，哪些是昂贵的。\n第三章：vector的类型和属性(attributes)。\n第四章：子集操作。\n第五章：控制流，if,for,switch(),while等语句。\n第六章：函数function构建细节，运行机制，退出机制；lazy 语式。\n第七章：R环境的数据结构。\n第八章：控制如何输出错误，警告，信息等。\n\n\n\n\n Back to top",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html",
    "href": "Books/R4DS2/26 Iteration.html",
    "title": "26 Iteration",
    "section": "",
    "text": "在tidyverse中有一些常见的循环操作，如：\n\n绘制分面——facet_wrap(),facet_grid()\n分组总结–group_by(),summarise()\nlist-column解压——unnest_wider(),unnest_longer()\n\n下面我们学习另外一些循环技巧。\n\nlibrary(tidyverse)",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#选择列",
    "href": "Books/R4DS2/26 Iteration.html#选择列",
    "title": "26 Iteration",
    "section": "选择列",
    "text": "选择列\n.cols控制选择哪几列，是一个tidy-select类，类似于dplyr中的select()，可以使用适配select()的函数，如starts_with()、contains()等。\n更多有过关于tidy-select的内容，可以参考?dplyr_tidy_select。\n\ndf &lt;- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median))\n#&gt; # A tibble: 2 × 5\n#&gt;     grp       a       b     c     d\n#&gt;   &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1 -0.0935 -0.0163 0.363 0.364\n#&gt; 2     2  0.312  -0.0576 0.208 0.565",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数",
    "href": "Books/R4DS2/26 Iteration.html#函数",
    "title": "26 Iteration",
    "section": "函数",
    "text": "函数\n.fns参数提供across()进行call的函数，可以是 - 函数名，例如mean，注意此处函数后不能有() - purrr-style lambda，例如~mean(.x, na.rm = TRUE) - 上述两种函数组成的named list，例如list(mean = mean,n_miss = ~ sum(is.na(.x))\n\n\n\n函数名\n\n# 函数名后有`()`会报错。\ndf |&gt;\n  group_by(grp) |&gt;\n  summarize(across(everything(), median()))\n#&gt; Error in `summarize()`:\n#&gt; ℹ In argument: `across(everything(), median())`.\n#&gt; Caused by error in `median.default()`:\n#&gt; ! argument \"x\" is missing, with no default\n\n\n\n\n\npurrr-style lambda\n\nrnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss &lt;- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, ~ median(., na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 5\n#&gt;       a     b      c     d     n\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1 0.139 -1.11 -0.387  1.15     5\n\n\n\n\n\n函数list\n\ndf_miss |&gt;\n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n#&gt; # A tibble: 1 × 9\n#&gt;   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#&gt;      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1    0.139        1    -1.11        1   -0.387        2     1.15        0\n#&gt; # ℹ 1 more variable: n &lt;int&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#列名",
    "href": "Books/R4DS2/26 Iteration.html#列名",
    "title": "26 Iteration",
    "section": "列名",
    "text": "列名\n如果你仔细观察，上面例子中的列名类似于{.col}_{.fn}（这也是为什么函数list是要有name属性的原因）。\n.names参数控制列名定义规则，使用{.col}表示原始列名，{.fn}表示函数名；单个函数默认{.col}，多个函数默认{.col}_{.fn}。\nacross()在与mutate()联用时会将原来的列覆盖，因为.names()默认是{.col}，所以看不出来，当参数值改变后就会直观的体现出来：\n\n\n\n与mutate联用\n\ndf_miss |&gt;\n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n#&gt; # A tibble: 5 × 8\n#&gt;        a      b      c     d a_na_zero b_na_zero c_na_zero d_na_zero\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60      0.434    -1.25      0         1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776     0        -1.43     -0.297     0.776\n#&gt; 3 -0.156 -0.980 NA     1.15     -0.156    -0.980     0         1.15 \n#&gt; 4 -2.61  -0.683 -0.785 2.13     -2.61     -0.683    -0.785     2.13 \n#&gt; 5  1.11  NA     -0.387 0.704     1.11      0        -0.387     0.704",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "href": "Books/R4DS2/26 Iteration.html#filter中的循环",
    "title": "26 Iteration",
    "section": "filter()中的循环",
    "text": "filter()中的循环\ndplyr 提供了两个across()的变体:\n\nif_any()：至少有一个条件返回TRUE\nif_all()：所有条件返回TRUE\n\n\n# same as df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |&gt; filter(if_any(a:d, is.na))\n#&gt; # A tibble: 4 × 4\n#&gt;        a      b      c     d\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  0.434 -1.25  NA     1.60 \n#&gt; 2 NA     -1.43  -0.297 0.776\n#&gt; 3 -0.156 -0.980 NA     1.15 \n#&gt; 4  1.11  NA     -0.387 0.704\n\n# same as df_miss |&gt; filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |&gt; filter(if_all(a:d, is.na))\n#&gt; # A tibble: 0 × 4\n#&gt; # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "href": "Books/R4DS2/26 Iteration.html#与piovt_longer对比",
    "title": "26 Iteration",
    "section": "与piovt_longer()对比",
    "text": "与piovt_longer()对比\n使用piovt_longer()可以实现across()，反之则不成立。例如下面的两个例子\n\n\n\nacross\n\ndf |&gt;\n  summarize(across(a:d, list(median = median, mean = mean)))\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\npivot_longer 复现\n\nlong &lt;- df |&gt;\n  pivot_longer(a:d) |&gt;\n  group_by(name) |&gt;\n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong |&gt;\n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n#&gt; # A tibble: 1 × 8\n#&gt;   a_median a_mean b_median b_mean c_median c_mean d_median d_mean\n#&gt;      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1   0.0380  0.205  -0.0163 0.0910    0.260 0.0716    0.540  0.508\n\n\n\n\n\n只能使用pivot_longer\n\ndf_paired &lt;- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n\ndf_long &lt;- df_paired |&gt;\n  pivot_longer(\n    everything(),\n    names_to = c(\"group\", \".value\"),\n    names_sep = \"_\"\n  )\ndf_long\n#&gt; # A tibble: 40 × 3\n#&gt;   group    val   wts\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a      0.715 0.518\n#&gt; 2 b     -0.709 0.691\n#&gt; 3 c      0.718 0.216\n#&gt; 4 d     -0.217 0.733\n#&gt; 5 a     -1.09  0.979\n#&gt; 6 b     -0.209 0.675\n#&gt; # ℹ 34 more rows\n\ndf_long |&gt;\n  group_by(group) |&gt;\n  summarize(mean = weighted.mean(val, wts))\n#&gt; # A tibble: 4 × 2\n#&gt;   group    mean\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;\n#&gt; 1 a      0.126 \n#&gt; 2 b     -0.0704\n#&gt; 3 c     -0.360 \n#&gt; 4 d     -0.248",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "href": "Books/R4DS2/26 Iteration.html#返回结果不同",
    "title": "26 Iteration",
    "section": "返回结果不同",
    "text": "返回结果不同\nmap()函数会返回一个list，其变体则不同。\n\n返回输入值\nwalk()函数只能隐性返回输入，对.f生成的结果没有处理，这在循环绘图中十分便利。\nres &lt;- 1:4 |&gt;\n  walk(\\(x) {\n    hist(rnorm(100, x))\n  })\n\nres\n#&gt; [1] 1 2 3 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n返回结果结构与输入相同\nmodify()函数会输出一个与输入结构完全相同的结果，常用来修改元素类型。\n\n# Convert to characters\niris |&gt; str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\niris |&gt;\n  modify(as.character) |&gt;\n  str()\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: chr  \"5.1\" \"4.9\" \"4.7\" \"4.6\" ...\n#&gt;  $ Sepal.Width : chr  \"3.5\" \"3\" \"3.2\" \"3.1\" ...\n#&gt;  $ Petal.Length: chr  \"1.4\" \"1.4\" \"1.3\" \"1.5\" ...\n#&gt;  $ Petal.Width : chr  \"0.2\" \"0.2\" \"0.2\" \"0.2\" ...\n#&gt;  $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n其还有变体modify_if()，modify_at()，modify2()，imodify()，使用方法相似，具体差异同下面讲到的一样。\n\n\n返回原子向量\n这一类有map_lgl(),map_int(),map_dbl(),map_chr(),map_vec()；要求返回的原子向量类型为函数名后缀规定的类型，否则报错。例如：map_lgl()函数要求返回结果为由TRUE和FALSE构成的向量，否则报错。map_vec()函数提供了参数.ptype，可以指定返回结果的类型。\n\nnumbers &lt;- list(1, 2, 3, 4)\n\nmap_lgl(numbers, ~ .x %% 2 == 0)\n#&gt; [1] FALSE  TRUE FALSE  TRUE\n\nmap_lgl(numbers, ~ .x * 2)\n#&gt; Error in `map_lgl()`:\n#&gt; ℹ In index: 1.\n#&gt; Caused by error:\n#&gt; ! Can't coerce from a number to a logical.\n\n\n\n返回数据框\n这一类有map_dfc(),map_dfr()，这两类函数在官方文档中已经不再推荐使用，而是使用map() + list_rbind()/list_cbind()的组合方式。\n\n# map ---------------------------------------------\n# Was:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map_dfr(\\(mod) as.data.frame(t(as.matrix(coef(mod)))))\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438\n# Now:\nmtcars |&gt;\n  split(mtcars$cyl) |&gt;\n  map(\\(df) lm(mpg ~ wt, data = df)) |&gt;\n  map(\\(mod) as.data.frame(t(as.matrix(coef(mod))))) |&gt;\n  list_rbind()\n#&gt;   (Intercept)        wt\n#&gt; 1    39.57120 -5.647025\n#&gt; 2    28.40884 -2.780106\n#&gt; 3    23.86803 -2.192438",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "href": "Books/R4DS2/26 Iteration.html#输入元素不同",
    "title": "26 Iteration",
    "section": "输入元素不同",
    "text": "输入元素不同\n这一类有：\n\n对不同位置元素操作：map_at(),map_if(),map_depth()。\n要求元素类型为长度是1的list：lmap()和其变体lmap_at(),lmap_if()。\n\n\nmap_at()\n通过参数.at，提供元素在输入中的位置或name属性，针对特定元素进行操作。\n\nl3 &lt;- list(\n  a = 1:3,\n  b = LETTERS[1:3],\n  c = 7:9\n)\n\nl3 |&gt;\n  map_at(.at = c(\"a\", \"c\"), ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_if()\n通过参数.p，提供元素要满足的条件，针对特定元素进行操作，可以是判断函数，也可以是逻辑向量。\n\nl3 |&gt;\n  map_if(.p = is.numeric, ~ .x + 1)\n#&gt; $a\n#&gt; [1] 2 3 4\n#&gt; \n#&gt; $b\n#&gt; [1] \"A\" \"B\" \"C\"\n#&gt; \n#&gt; $c\n#&gt; [1]  8  9 10\n\n\n\nmap_depth()\n通过参数.depth，提供元素的深度，针对该深度处的元素进行操作。\n\nx &lt;- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))\nx |&gt; str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: int [1:2] 1 2\n#&gt;   ..$ bar: int [1:2] 3 4\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: int [1:2] 5 6\n\nx |&gt;\n  map_depth(2, \\(y) paste(y, collapse = \"/\")) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n# Equivalent to:\nx |&gt;\n  map(\\(y) map(y, \\(z) paste(z, collapse = \"/\"))) |&gt;\n  str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: chr \"1/2\"\n#&gt;   ..$ bar: chr \"3/4\"\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: chr \"5/6\"\n\n\n\nlmap() 类\nlmap()与map()的不同之处在于，后者提取使用[[i]]来提取list中的元素，返回一个向量，前者使用[i]提取list中的元素，返回一个list。\n由于lmap()操作对象是list，所以它可以使用list中的name属性；在返回结果时，它会使用c()将list合并。下面是一个示例：\n\nadd_minus &lt;- function(x) {\n  res1 &lt;- lapply(x, function(y) y - 1)\n  names(res1) &lt;- paste0(names(x), \"_minus\")\n  res2 &lt;- lapply(x, function(y) y + 1)\n  names(res2) &lt;- paste0(names(x), \"_plus\")\n  c(res1, res2)\n}\n\n# The output size varies each time we map f()\ntest &lt;- list(a = 1:4, c = 8:9)\ntest |&gt;\n  lmap(add_minus) |&gt;\n  str()\n#&gt; List of 4\n#&gt;  $ a_minus: num [1:4] 0 1 2 3\n#&gt;  $ a_plus : num [1:4] 2 3 4 5\n#&gt;  $ c_minus: num [1:2] 7 8\n#&gt;  $ c_plus : num [1:2] 9 10\n\n所以，lmap()对参数.x，.f有不同的要求：\n\n.x：list 或 data.frame\n.f：该函数输入为长度是1的list，输出是任意长度的list。",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "href": "Books/R4DS2/26 Iteration.html#函数参数数目",
    "title": "26 Iteration",
    "section": "函数参数数目",
    "text": "函数参数数目\n这一类函数有map2()、pmap()和map2()的变体imap()。这些函数与map()的使用方法类似，只是多提供了一组或多组.f函数的参数。同时这些函数都有*_lgl(),*_int(), *_dbl(), *_chr(), *_vec(), *_dfc(), *_dfr(),*walk()等变体，使用方法同上。\n\nimap()\nimap()是map2(x, names(x), ...)或map2(x, seq_along(x), ...)的简写，其余使用方法相同。\n\nset.seed(123)\nimap_chr(sample(10), paste)\n#&gt;  [1] \"3 1\"  \"10 2\" \"2 3\"  \"8 4\"  \"6 5\"  \"9 6\"  \"1 7\"  \"7 8\"  \"5 9\"  \"4 10\"",
    "crumbs": [
      "26 Iteration"
    ]
  },
  {
    "objectID": "Books/R4DS2/index.html",
    "href": "Books/R4DS2/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍R for Data Science的学习笔记。\n原文见：R for Data Science (2e)\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/Tidy Modeling with R/index.html",
    "href": "Books/Tidy Modeling with R/index.html",
    "title": "index",
    "section": "",
    "text": "本篇为书籍Tidy Modeling with R的学习笔记。\n原文见：Tidy Modeling with R\ntidymodels R包官方网站：https://www.tidymodels.org\n本书主要包含两方面：\n\n如何使用tidymodels包进行机器学习建模\n统计建模中的实践经验\n\n下面是全文概览：\n\n第1章：概述模型的分类，强调什么是好的建模软件。\n第2章：回顾 tidyverse 语法。\n第3章：base R中的统计建模总览及其不足。\n第4~9章：tidymodel系列包的介绍：recipes，parsnip，workflows，yardstick等。\n第10~15章：模型性能评估与调参。\n第16~21章：如何理解和解构模型。\n\n\n\n\n Back to top",
    "crumbs": [
      "index"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html",
    "href": "Books/quarto/Project Basics.html",
    "title": "Project Basics",
    "section": "",
    "text": "原文：https://quarto.org/docs/projects/quarto-projects.html\nquarto的官方网站提供了许多创建项目的教程，如下图，如何创建项目，这里不再赘述。\n\n\n\n官网教程\n\n\n\n\n当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true\n\n\n\n\n使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#shared-metadata",
    "href": "Books/quarto/Project Basics.html#shared-metadata",
    "title": "Project Basics",
    "section": "",
    "text": "当你创建一个项目后，会自动生成一个项目级的YAML文件——_quarto.yml，该文件用来配置整个项目。示例如下：\nproject:\n  output-dir: _output\n\ntoc: true\nnumber-sections: true\nbibliography: references.bib\n\nformat:\n  html:\n    css: styles.css\n    html-math-method: katex\n  pdf:\n    documentclass: report\n    margin-left: 30mm\n    margin-right: 30mm\n随着项目的持续进行，对各部分的调控会显得及其臃肿，最好的办法是将其进行拆分。使用metadata-files可以进行配置，下面是一个混合导航栏的拆分示例，更多导航栏信息见https://quarto.org/docs/websites/website-navigation.html。\n\n\n_quarto.yml\n\nproject:\n  type: website\n\nwebsite:\n  navbar:\n    left:\n      - text: Books\n        menu:\n          - sidebar:ggplot2\n\nmetadata-files:\n  - ggplot2/_ggplot.yml\n\n\n\n_ggplot.yml\n\nwebsite:\n  sidebar:\n    - id: ggplot2\n      title: ggplot2\n      contents:\n        - ggplot2/index.qmd\n\n与上面导航栏示例不同，quarto提供了另外一种——文件夹级配置文件——_metadata.yml。如下：\n\n\n_metadata.yml\n\nformat:\n  revealjs:\n    menu: false\n    progress: false\nsearch: false\n\nquarto中的配置信息分为三级，按优先级由低到高：\n\n项目级配置文件：_quarto.yml\n文件夹级配置文件：dir/_metadata.yml\n文件级配置文件：dir/file.qmd\n\nquarto会自动对配置文件进行合并或覆盖，示例如下，最终的配置体现在文件级配置文件中。\n\n\n\n\n\n\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    toc: true\nbibliography:\n  - refs.bib\n\n\n\ndir/_metadata.yml\n\nformat:\n  html:\n    code-fold: true\nbibliography:\n  - proj.bib\n\n\n\nmerge\n\nformat:\n  html:\n    toc: true\n    code-fold: true\nbibliography:\n  - refs.bib\n  - proj.bib\n\n\n\n\n也可以设置本地配置文件_quarto.yml.local，不进行上传，该文件会自动添加到.gitignore中。\n\n\n_quarto.yml.local\n\nexecute:\n  cache: true",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "Books/quarto/Project Basics.html#rendering-projects",
    "href": "Books/quarto/Project Basics.html#rendering-projects",
    "title": "Project Basics",
    "section": "",
    "text": "使用quarto 进行渲染时，你可以：\n\n渲染整个项目quarto render\n渲染某个目录quarto render subdir\n渲染为不同格式的文件quarto render --to pdf\n\n如果不想渲染整个项目，只渲染部分文档，可以进行如下配置：\nproject:\n  render:\n    - section1.qmd\n    - section2.qmd\nproject:\n  render:\n    - section*.qmd\n当你想配置某些文件不渲染时，可以进行如下配置，注意一定要包含*.qmd:\nproject:\n  render:\n    - \"*.qmd\"\n    - \"!ignored.qmd\"\n    - \"!ignored-dir/\"",
    "crumbs": [
      "Project Basics"
    ]
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nquarto 中R代码块的设置\n\n\n\n\n\n\nquarto\n\n\n\n\n\n\n\n\n\n2025-03-15\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nR 中的面向对象(1)\n\n\n\n\n\n\n面向对象\n\n\n\n\n\n\n\n\n\n2025-03-16\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nData Masking(1)\n\n\n\n\n\n\nrlang\n\n\n\n\n\n\n\n\n\n2025-04-25\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\nR 中的 | 与 &\n\n\n\n\n\n\ntriky skill\n\n\n\n\n\n\n\n\n\n2025-04-25\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\ncapture.output\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2025-04-25\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\n相关性计算\n\n\n\n\n\n\ntriky skill\n\n\n\n\n\n\n\n\n\n2025-06-27\n\n\n大番薯本薯\n\n\n\n\n\n\n\n\n\n\n\n\n绘制点脊图\n\n\n\n\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n2025-07-03\n\n\n大番薯本薯\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html",
    "href": "Books/Advanced R(2e)/4 Subsetting.html",
    "title": "4 Subsetting",
    "section": "",
    "text": "R 中的提取子集操作上手很快，使用起来也很方便。但是想要掌握，需要理解并整合下面几点内容：\n\n有6种方法提取atomic向量的子集。\n有3种提取函数：[、[[和$。\n提取不同类型的对象，提取函数有不同的表现。\n提取函数可以搭配&lt;-来赋值。\n\n\n\n\n\n\n\nNote\n\n\n\n[、[[和$ 本质上是S3面向对象类型的函数\n\n\n\n\n\n4.2节：介绍[函数，及其在不同类型对象上的用法。\n4.3节：介绍[[和$函数，及其在不同类型对象上的用法。\n4.4节：介绍提取函数与&lt;-的搭配使用。\n4.5节：介绍8个实践案例。",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#introduction",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#introduction",
    "title": "4 Subsetting",
    "section": "",
    "text": "R 中的提取子集操作上手很快，使用起来也很方便。但是想要掌握，需要理解并整合下面几点内容：\n\n有6种方法提取atomic向量的子集。\n有3种提取函数：[、[[和$。\n提取不同类型的对象，提取函数有不同的表现。\n提取函数可以搭配&lt;-来赋值。\n\n\n\n\n\n\n\nNote\n\n\n\n[、[[和$ 本质上是S3面向对象类型的函数\n\n\n\n\n\n4.2节：介绍[函数，及其在不同类型对象上的用法。\n4.3节：介绍[[和$函数，及其在不同类型对象上的用法。\n4.4节：介绍提取函数与&lt;-的搭配使用。\n4.5节：介绍8个实践案例。",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#selecting-multiple-elements",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#selecting-multiple-elements",
    "title": "4 Subsetting",
    "section": "Selecting multiple elements",
    "text": "Selecting multiple elements\n\nAtomic vectors\n以提取atomic向量为例，介绍用作提取子集时的6种坐标：\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\n\n正整数：表示元素在向量中的位置。\n\n\nx[c(3, 1)]\n#&gt; [1] 3.3 2.1\nx[order(x)]\n#&gt; [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n#&gt; [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n#&gt; [1] 4.2 4.2\n\n\n负整数：负号表示删除，正负不能同时存在。\n\n\nx[-c(3, 1)]\n#&gt; [1] 4.2 5.4\n\n\nx[c(-1, 2)]\n#&gt; Error in x[c(-1, 2)]: only 0's may be mixed with negative subscripts\n\n\n逻辑值：TRUE表示保留，FALSE表示删除，NA返回NA。在x[y]的模式中，如果二者长度不等，会发生循环，遵循R base中的循环原则：循环短的一方。\n\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#&gt; [1] 2.1 4.2\nx[x &gt; 3]\n#&gt; [1] 4.2 3.3 5.4\nx[c(TRUE, NA, FALSE, TRUE)]\n#&gt; [1] 2.1  NA 5.4\n\n\nNothing：返回完整的对象，在后面对data.frame提取时有用。\n\n\nx[]\n#&gt; [1] 2.1 4.2 3.3 5.4\n\n\nZero：返回长度为0的向量。\n\n\nx[0]\n#&gt; numeric(0)\n\n\n字符串：有name属性的向量元素。\n\n\n(y &lt;- setNames(x, letters[1:4]))\n#&gt;   a   b   c   d \n#&gt; 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n#&gt;   d   c   a \n#&gt; 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n#&gt;   a   a   a \n#&gt; 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz &lt;- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n#&gt; &lt;NA&gt; &lt;NA&gt; \n#&gt;   NA   NA\n\n\n\n\n\n\n\nNote\n\n\n\n不要使用因子化的字符串向量提取子集，字符串向量因子化后，会视为整数。\n\ny[factor(\"b\")]\n#&gt;   a \n#&gt; 2.1\n\n\n\n\n\nLists\n[函数作用于list时，返回得仍然是一个list；[[和$函数作用于list时，返回得是list中的元素。\n\n\nMatrices and arrays\n对于多维的atomic Vector，只需要在每个维度上应用上述6种坐标，就可以得到子集。\n\na &lt;- matrix(1:9, nrow = 3)\ncolnames(a) &lt;- c(\"A\", \"B\", \"C\")\na[1:2, ]\n#&gt;      A B C\n#&gt; [1,] 1 4 7\n#&gt; [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n#&gt;      B A\n#&gt; [1,] 4 1\n#&gt; [2,] 6 3\na[0, -2]\n#&gt;      A C\n\n因为Matrices和Arrays是带有特殊属性的向量，所以仍然可以只使用一维的向量来提取，但要注意：它们都是列向量。\n\nvals &lt;- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] \n#&gt; [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#&gt; [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#&gt; [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#&gt; [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#&gt; [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n#&gt; [1] \"4,1\" \"5,3\"\n\n可以使用一个两列matrix提取2维Matrices，三列matrix提取3维Arrays；一行表示一个坐标，返回一个向量。\n\nselect &lt;- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nselect\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    1\n#&gt; [2,]    3    1\n#&gt; [3,]    2    4\nvals[select]\n#&gt; [1] \"1,1\" \"3,1\" \"2,4\"\n\n\n\nData frames and tibbles\nData.frame具有list和matrix的特性：\n\n当只提供一个index时，会将其视作list，返回列。\n当提供两个index时，将其视作matrix，返回矩阵。\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n#&gt;   x y z\n#&gt; 2 2 2 b\ndf[c(1, 3), ]\n#&gt;   x y z\n#&gt; 1 1 3 a\n#&gt; 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n#&gt;   x z\n#&gt; 1 1 a\n#&gt; 2 2 b\n#&gt; 3 3 c\n\n\n# There's an important difference if you select a single\n# column: matrix subsetting simplifies by default, list\n# subsetting does not.\nstr(df[\"x\"])\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\nstr(df[, \"x\"])\n#&gt;  int [1:3] 1 2 3\n\n对tibble使用[，始终返回tibble。\n\ntib &lt;- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(tib[\"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\nstr(tib[, \"x\"])\n#&gt; tibble [3 × 1] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ x: int [1:3] 1 2 3\n\n\n\nPreserving dimensionality\n[函数有额外的参数drop用于控制是否在只有一列时降维，默认为TRUE。\n正如上面例子中的结果一样，data.frame在列方向上的index长度为1时，会发生降维：df[\"x\"]没有发生降维，df[, \"x\"]则发生了降维。\n\nstr(df[, \"x\", drop = FALSE])\n#&gt; 'data.frame':    3 obs. of  1 variable:\n#&gt;  $ x: int  1 2 3\n\nmatrix则表现为任意维度的index长度为1时，都会发生降维：\n\na &lt;- matrix(1:4, nrow = 2)\nstr(a[1, ])\n#&gt;  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n#&gt;  int [1, 1:2] 1 3\n\n在factor中使用[时，也有参数drop；但该参数的意义为：是否丢弃没有值的级别，默认为FALSE。\n\nz &lt;- factor(c(\"a\", \"b\"))\nz[1]\n#&gt; [1] a\n#&gt; Levels: a b\nz[1, drop = TRUE]\n#&gt; [1] a\n#&gt; Levels: a\n\n\n\nExercises\n…",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#selecting-a-single-element",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#selecting-a-single-element",
    "title": "4 Subsetting",
    "section": "Selecting a single element",
    "text": "Selecting a single element\n\n[[\n[[函数广泛应用在list或dataframe对象上，它与[函数的不同在于，返回得是降维的子对象。将一个list比作一列火车，[[返回的是火车中某车厢上的所有元素，[返回的是带有选取车厢的整列火车。\n\nx &lt;- list(1:3, \"a\", 4:6)\n\n\n\n\n使用[[函数时要注意：\n\n只能提供长度为1的整数或字符串作为index。\n当提供的长度大于1后，会递归地提取子对象。\n\n\nx1 &lt;- list(\n  1:3,\n  list( \"a\", \"b\"),\n  4:6\n)\n\nx1[[c(2,1)]]\n#&gt; [1] \"a\"\n# 等价于\nx1[[2]][[1]]\n#&gt; [1] \"a\"\n\n\n\n$\nx$y大致等于x[[\"y\", exact = FALSE]]。\n在使用$时，常见的错误是：使用当前环境变量中的某些变量来替代数据框或list中的name，此时推荐使用[[。\n\nvar &lt;- \"cyl\"\n# Doesn't work - mtcars$var translated to mtcars[[\"var\"]]\nmtcars$var\n#&gt; NULL\n\n# Instead use [[\nmtcars[[var]]\n#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n\n$与[[最大的不同是，$会自动地执行从左到右地部分匹配；可以添加options(warnPartialMatchDollar = TRUE)来添加提醒。\n\nx &lt;- list(abc = 1)\nx$a\n#&gt; [1] 1\nx[[\"a\"]]\n#&gt; NULL\n\n\noptions(warnPartialMatchDollar = TRUE)\nx$a\n#&gt; Warning in x$a: partial match of 'a' to 'abc'\n#&gt; [1] 1\n\n\n\nMissing and out-of-bounds indices\n在使用[[函数时，如果index无效，不同类型对象的结果不同。如下表中总结，三种类型的数据：atomic向量，list和NULL，四种无效的index：长度为0，超出范围（整数、字符串），缺失。\n\n\n\n\n\n\n\n\n\n\nrow[[col]]\nZero-length\nOut of bounds(Integer)\nOut of bounds(character)\nMissing\n\n\n\n\nAtomic\nError\nError\nError\nError\n\n\nList\nError\nError\nNULL\nNULL\n\n\nNULL\nNULL\nNULL\nNULL\nNULL\n\n\n\n\nx &lt;- setNames(1:3, letters[1:3])\ny &lt;- list(A = 1:3, B = 4:6, C = 7:9)\nz &lt;- NULL\n\nx[[NULL]]\nx[[4]]\nx[[\"d\"]]\nx[[NA]]\n\ny[[NULL]]\ny[[4]]\ny[[\"D\"]]\ny[[NA]]\n\nz[[NULL]]\nz[[4]]\nz[[\"D\"]]\nz[[NA]]\n\n从表中可以看出，[[的结果存在非一致性。purrr包提供了另外两种取子集的函数purrr::pluck(),purrr::chuck()。purrr::pluck()可以设置元素缺失时的默认返回值（默认为NULL），purrr::chuck()总是返回错误。pluck()也允许混合整数和字符串的index。pluck()的优点，使得其在处理结构化数据json或web api结果时非常有用。\n\nx &lt;- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n#&gt; [1] 1\n\npurrr::pluck(x, \"c\", 1)\n#&gt; NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n#&gt; [1] NA\n\n\n\n@ and slot()\n@和slot()设计到S4面向对象系统，我们将在后面的章节中学习。\n\n\nExercises\n…",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#subsetting-and-assignment",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#subsetting-and-assignment",
    "title": "4 Subsetting",
    "section": "Subsetting and assignment",
    "text": "Subsetting and assignment\n查看函数说明文档，如果包含FUN(x) &lt;-形式的函数，就支持赋值。\n\nx &lt;- 1:5\nx[c(1, 2)] &lt;- c(101, 102)\nx\n#&gt; [1] 101 102   3   4   5\n\n在使用赋值前，一定要检查好提取的子集长度等于赋的值长度、子集index唯一。因为base R的循环原则，会使得结果完全不符合预期。\n对于list，可以使用x[[i]] &lt;- NULL删除某个元素，如果是增加一个内容为NULL的元素可以使用x[i] &lt;- list(NULL)。\n\nx &lt;- list(a = 1, b = 2)\nx[[\"b\"]] &lt;- NULL\nstr(x)\n#&gt; List of 1\n#&gt;  $ a: num 1\n\ny &lt;- list(a = 1, b = 2)\ny[\"b\"] &lt;- list(NULL)\nstr(y)\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: NULL\n\n前面讲到，提取空元素对atomic向量没有太多用处，但对数据框有重要作用：它可以保持数据框的数据结构：\n\nmtcars[] &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] TRUE\n\nmtcars &lt;- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#&gt; [1] FALSE",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/4 Subsetting.html#applications",
    "href": "Books/Advanced R(2e)/4 Subsetting.html#applications",
    "title": "4 Subsetting",
    "section": "Applications",
    "text": "Applications\n利用取子集的功能，你可以对数据框进行查找、拼接、排序、抽样、解压、删除等操作，下面是一些应用广泛的例子：\n\nLookup tables (character subsetting)\n创建查询表格，进行数据转换。\n\nx &lt;- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup &lt;- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n#&gt;        m        f        u        f        f        m        m \n#&gt;   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\n\n# 去除name\nunname(lookup[x])\n#&gt; [1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\"\n\n\n\nMatching and merging by hand (integer subsetting)\n使用match()函数与整数索引进行数据匹配和合并。\n\ngrades &lt;- c(1, 2, 2, 3, 1)\n\ninfo &lt;- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\n\nid &lt;- match(grades, info$grade)\nid\n#&gt; [1] 3 2 2 1 3\ninfo[id, ]\n#&gt;     grade      desc  fail\n#&gt; 3       1      Poor  TRUE\n#&gt; 2       2      Good FALSE\n#&gt; 2.1     2      Good FALSE\n#&gt; 1       3 Excellent FALSE\n#&gt; 3.1     1      Poor  TRUE\n\n\n\nRandom samples and bootstraps (integer subsetting)\n同上，使用整数索引，搭配sample()函数，模拟抽样与bootstrap。\n\ndf &lt;- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 3 3 3 c\n#&gt; 4 1 2 d\n#&gt; 1 1 5 a\n#&gt; 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n#&gt;   x y z\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n#&gt;     x y z\n#&gt; 5   2 1 e\n#&gt; 5.1 2 1 e\n#&gt; 5.2 2 1 e\n#&gt; 2   2 4 b\n#&gt; 3   3 3 c\n#&gt; 3.1 3 3 c\n\n\n\nOrdering (integer subsetting)\n同上，使用整数索引，搭配order()函数，对数据框排序。\n\n# Randomly reorder df\ndf2 &lt;- df[sample(nrow(df)), 3:1]\ndf2\n#&gt;   z y x\n#&gt; 5 e 1 2\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\n\ndf2[order(df2$x), ]\n#&gt;   z y x\n#&gt; 1 a 5 1\n#&gt; 4 d 2 1\n#&gt; 5 e 1 2\n#&gt; 2 b 4 2\n#&gt; 3 c 3 3\ndf2[, order(names(df2))]\n#&gt;   x y z\n#&gt; 5 2 1 e\n#&gt; 1 1 5 a\n#&gt; 4 1 2 d\n#&gt; 2 2 4 b\n#&gt; 3 3 3 c\n\n\n\nExpanding aggregated counts (integer subsetting)\n使用函数rep()，将行相同且具有重复数的数据框解压。\n\ndf &lt;- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n#&gt; [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n#&gt;     x  y n\n#&gt; 1   2  9 3\n#&gt; 1.1 2  9 3\n#&gt; 1.2 2  9 3\n#&gt; 2   4 11 5\n#&gt; 2.1 4 11 5\n#&gt; 2.2 4 11 5\n#&gt; 2.3 4 11 5\n#&gt; 2.4 4 11 5\n#&gt; 3   1  6 1\n\n\n\nRemoving columns from data frames (character)\n删除数据框的某列。\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z &lt;- NULL\n\n\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\ndf[setdiff(names(df), \"z\")]\n#&gt;   x y\n#&gt; 1 1 3\n#&gt; 2 2 2\n#&gt; 3 3 1\n\n\n\nSelecting rows based on a condition (logical subsetting)\n使用逻辑向量筛选数据框的行。\n\ndata(mtcars)\nmtcars[mtcars$gear == 5, ]\n#&gt;                 mpg cyl  disp  hp drat    wt qsec vs am gear carb\n#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.5  0  1    5    4\n#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.5  0  1    5    6\n#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.570 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n#&gt;                mpg cyl  disp  hp drat    wt qsec vs am gear carb\n#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.7  0  1    5    2\n#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\n\n\n\nBoolean algebra versus sets (logical and integer )\nwhich()函数可以将布尔索引转换为整数索引。但x[which(y)]与x[y]仍然有一些差别：\n\n当布尔索引中存在缺失值NA时，对应得返回值也是NA。而which()会自动丢掉NA。\nx[-which(y)]与x[!y]不是等价的：如有y全部是FALSE，which(y)返回integer(0)，而-integer(0)仍然是integer(0)，最终前者返回一个空的向量，后者返回全部值。\n\n\nx &lt;- c(1, 2, 3, 4, NA, 5)\n\nx[which(x &gt; 2)]\n#&gt; [1] 3 4 5\nx[x &gt; 2]\n#&gt; [1]  3  4 NA  5\n\nx[-which(x &gt; 10)]\n#&gt; numeric(0)\nx[!x &gt; 10]\n#&gt; [1]  1  2  3  4 NA  5\n\n布尔向量的运算可以使用intersect()，`union()，setdiff()等函数进行等价替换。\n\n(x1 &lt;- 1:10 %% 2 == 0)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 &lt;- which(x1))\n#&gt; [1]  2  4  6  8 10\n(y1 &lt;- 1:10 %% 5 == 0)\n#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 &lt;- which(y1))\n#&gt; [1]  5 10\n\n# X & Y &lt;-&gt; intersect(x, y)\nx1 & y1\n#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n#&gt; [1] 10\n\n# X | Y &lt;-&gt; union(x, y)\nx1 | y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n#&gt; [1]  2  4  6  8 10  5\n\n# X & !Y &lt;-&gt; setdiff(x, y)\nx1 & !y1\n#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n#&gt; [1] 2 4 6 8\n\n# xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n#&gt; [1] 2 4 6 8 5",
    "crumbs": [
      "4 Subsetting"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html",
    "href": "Books/Advanced R(2e)/5 Control flow.html",
    "title": "5 Control flow",
    "section": "",
    "text": "R 中有两类主要的控制流类型工具：选择（if）和循环（for）。选择包含if、switch()等声明；循环包含for、while等声明。这里假定你已经学会了它们的基础用法，本章主要介绍一些技术细节和鲜为人知的高级用法。\n\n\n\n5.2节：介绍if、ifelse()、switch()函数。\n5.3节：介绍for、while、repeat等声明。",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#introduction",
    "href": "Books/Advanced R(2e)/5 Control flow.html#introduction",
    "title": "5 Control flow",
    "section": "",
    "text": "R 中有两类主要的控制流类型工具：选择（if）和循环（for）。选择包含if、switch()等声明；循环包含for、while等声明。这里假定你已经学会了它们的基础用法，本章主要介绍一些技术细节和鲜为人知的高级用法。\n\n\n\n5.2节：介绍if、ifelse()、switch()函数。\n5.3节：介绍for、while、repeat等声明。",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#choices",
    "href": "Books/Advanced R(2e)/5 Control flow.html#choices",
    "title": "5 Control flow",
    "section": "Choices",
    "text": "Choices\n下面是if-else语句的基本使用格式：\n\nif (condition) true_action\n\nif (condition) true_action else false_action\n\nif (condition1) {\n  true_action1\n} else if (condition2) {\n  true_action2\n} else {\n  false_action\n}\n\nif语句也可以进行赋值操作；在实际书写代码时，建议只有在if-else语句可以写为一行时，才使用赋值操作。\n\nx1 &lt;- if (TRUE) 1 else 2\nx2 &lt;- if (FALSE) 1 else 2\n\nc(x1, x2)\n#&gt; [1] 1 2\n\n当if-else语句只有if声明时，如果条件不满足，则返回NULL。函数c()、paste()会自动去除返回值中的NULL值。\n\ngreet &lt;- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#&gt; [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#&gt; [1] \"Hi Jaime and HAPPY BIRTHDAY\"\n\n\nInvalid inputs\n需要注意的是，if声明中的条件返回值只能是长度为1的布尔值。如果长度大于1，在R 4.0版本前会选择第一个值，但在R 4.0版本后会报错。其他类型的输入也会报错。\n\nif (\"x\") 1\n#&gt; Error in if (\"x\") 1: argument is not interpretable as logical\nif (logical()) 1\n#&gt; Error in if (logical()) 1: argument is of length zero\nif (NA) 1\n#&gt; Error in if (NA) 1: missing value where TRUE/FALSE needed\nif (c(TRUE, FALSE)) 1\n#&gt; Error in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1\n\n\n\nVectorised if\nif-else 语句只能判断一次，假如你想要判断很多次，可以使用ifelse()函数。该函数接受三个参数：条件，返回值，其他值。如果条件为TRUE，返回值作为结果，否则返回其他值。条件处可以是向量，返回的也是向量。（可以理解for循环if-else语句）\n\nx &lt;- c(1:10, NA, 12)\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#&gt;  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\" NA    \"12\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#&gt;  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n#&gt; [11] NA     \"even\"\n\n\n\n\n\n\n\nTip\n\n\n\n建议只有在yes和no条件的返回值类型一致时，再使用ifelse()函数。如果不同，因为c()是atomic向量，会强制进行类型转换。函数要求得条件如果不是布尔值，则会进行类型转换as.logical()，如果转换结果仍不是布尔值，则会返回转换后的值。\n\n\ndplyr包提供了等价函数case_when()，使用方法如下：\n\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n#&gt;  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\"\n#&gt; [11] \"???\"  \"12\"\n\n\n\nswitch() statement\nswitch()语句是对if-else语句的压缩，例如你可以将下面的if-else语句:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\"\n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\n简化为switch()语句:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\n\n再判断条件的末尾添加错误信息，可以提高代码的可读性，因为当不满足匹配条件时，switch()语句返回NULL。\n\n(switch(\"c\",\n  a = 1,\n  b = 2\n))\n#&gt; NULL\n\n如果不同的输入条件返回值相同，可以省略返回值，switch()会自动向下匹配，例如:\n\nlegs &lt;- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n#&gt; [1] 4\nlegs(\"dog\")\n#&gt; [1] 4\n\n\n\n\n\n\n\nTip\n\n\n\nswitch()的输入可以是数值、字符串，但建议只使用字符串。\n\n\n\n\nExercises\n…",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/5 Control flow.html#loops",
    "href": "Books/Advanced R(2e)/5 Control flow.html#loops",
    "title": "5 Control flow",
    "section": "Loops",
    "text": "Loops\nfor 循环的基本格式如下：\n\nfor (item in vector) perform_action\n\n有两种中断循环的方法：break和next。break用于跳出整个循环，next用于跳出当前循环，继续下一个循环。\n\nfor (i in 1:10) {\n  if (i &lt; 3) {\n    next\n  }\n\n  print(i)\n\n  if (i &gt;= 5) {\n    break\n  }\n}\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n\n\n\n\n\n\nNote\n\n\n\n要注意在环境变量中不要有与item名重复的变量。for循环会赋值给item变量，这样会导致item变量的值变化。\n\ni &lt;- 100\nfor (i in 1:3) {}\ni\n#&gt; [1] 3\n\n\n\n\nCommon pitfalls\n在使用for循环时，有三个常见的易错陷阱：\n\n进行赋值操作前，没有定义容纳结果的变量。\n使用1:length(x)作为索引，而不是seq_along(x)。\n直接索引S3对象。\n\n如果没有事先定义容器，会导致for循环十分缓慢。可以使用vector()函数，定义容器类型：\n\nmeans &lt;- c(1, 50, 20)\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n1:length(x)在x的长度为0时，会报错。因为:对升序和降序都兼容，使用seq_along()函数可以变相的解决该问题。seq_along()函数返回一个长度与x相同的等差向量。\n\nx &lt;- c(1, 2, 3, 1,2,3)\ny &lt;- numeric(0)\n\n1:length(x)\n#&gt; [1] 1 2 3 4 5 6\nseq_along(x)\n#&gt; [1] 1 2 3 4 5 6\n\n1:length(y) # 在for循环中报错\n#&gt; [1] 1 0\nseq_along(y)\n#&gt; integer(0)\n\n\nmeans &lt;- c()\nout &lt;- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n#&gt; Error in rnorm(10, means[[i]]): invalid arguments\n\nout &lt;- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] &lt;- rnorm(10, means[[i]])\n}\n\n直接迭代S3对象时，for循环会丢掉S3对象的属性：\n\nxs &lt;- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#&gt; [1] 18262\n#&gt; [1] 14610\n\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#&gt; [1] \"2020-01-01\"\n#&gt; [1] \"2010-01-01\"\n\n\n\nRelated tools\n当你不知道要迭代多少次，可以使用while()和repeat()，它们的基本格式如下：\n\n# 当满足条件时，执行动作，直到条件不满足\nwhile (condition) action\n# 无限循环，直到遇到 break\nrepeat(action)\n\n\nx &lt;- 0\nwhile (x &lt; 10) {\n  x &lt;- x + 1\n  print(x)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n\nrepeat {\n  print(x)\n  x &lt;- x + 1\n  if (x &gt; 10) {\n    break\n  }\n}\n#&gt; [1] 10\n\n理论上讲：所有for循环都可以用while循环替代，所有while循环都可以用repeat循环替代，但是反过来不行；这意味着for循环的灵活性很低，但是在实践中，我们应该使用灵活性低的for循环。\n在数据分析中，我们可以使用更高级的map()和apply()函数。\n\n\nExercises\n\n一定要避免使用1:length(x)，下面的例子，不会报错，但是返回结果不对。\n\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n#&gt; [[1]]\n#&gt; [1] NA\n\nx &lt;- numeric()\nout &lt;- vector(\"list\", length(x))\nfor (i in seq_along(x)) {\n  out[i] &lt;- x[i]^2\n}\nout\n#&gt; list()\n\n\nR的for循环只评估一次输入，即使for循环中对评估进行了更新，也不会改变，避免了无限循环的可能。\n\n\nxs &lt;- c(1, 2, 3)\nfor (x in xs) {\n  xs &lt;- c(xs, x * 2)\n}\nxs\n#&gt; [1] 1 2 3 2 4 6\n\n\nR的for循环对于item的更新发生在每次迭代开始前，for循环中对item进行的更新无效。\n\n\nfor (i in 1:3) {\n  i &lt;- i * 2\n  print(i)\n}\n#&gt; [1] 2\n#&gt; [1] 4\n#&gt; [1] 6",
    "crumbs": [
      "5 Control flow"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html",
    "href": "Books/Advanced R(2e)/6 Functions.html",
    "title": "6 Functions",
    "section": "",
    "text": "在学习本章之前，你一定已经写过很多用来减少重复工作的函数，本章会将你在工作中的一些知识进行整合提升，帮助你从理论的视角看待函数。在本章，你会看到一些有趣的小技巧和复杂技术，请一定要留心，这些内容是后面章节中的基石。\n\n\n\n下面的代码运行时会报错吗？\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n\n无论运行成功或失败，函数如何都执行一些操作？\n\n\n\n\n\n6.2节：构成函数的三要素和原始函数（primitive function）。\n6.3节：函数联合使用的三种方法及其优劣。\n6.4节：词法作用域规则（rules of lexical scoping）——如何根据名字找到对应的值。\n6.5节：参数评估原则：只在第一次使用时评估，避免循环。\n6.6节：特殊参数...。\n6.7节：函数退出机制。\n6.8节：四种函数格式。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#introduction",
    "href": "Books/Advanced R(2e)/6 Functions.html#introduction",
    "title": "6 Functions",
    "section": "",
    "text": "在学习本章之前，你一定已经写过很多用来减少重复工作的函数，本章会将你在工作中的一些知识进行整合提升，帮助你从理论的视角看待函数。在本章，你会看到一些有趣的小技巧和复杂技术，请一定要留心，这些内容是后面章节中的基石。\n\n\n\n下面的代码运行时会报错吗？\n\n\nf2 &lt;- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))\n\n\n无论运行成功或失败，函数如何都执行一些操作？\n\n\n\n\n\n6.2节：构成函数的三要素和原始函数（primitive function）。\n6.3节：函数联合使用的三种方法及其优劣。\n6.4节：词法作用域规则（rules of lexical scoping）——如何根据名字找到对应的值。\n6.5节：参数评估原则：只在第一次使用时评估，避免循环。\n6.6节：特殊参数...。\n6.7节：函数退出机制。\n6.8节：四种函数格式。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-fundamentals",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-fundamentals",
    "title": "6 Functions",
    "section": "Function fundamentals",
    "text": "Function fundamentals\n\nFunction components\n函数由三部分组成：\n\nformals()：参数和函数名，控制如何调用函数。\nbody()：函数具体实现。\nenvironment()：环境，决定函数如何找到参数对应的值。\n\n在这三部分中，formals和body十分显性，构建出函数时就可以直观地看到；environment相对隐性，需要使用函数environment()。\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#&gt; $x\n#&gt; \n#&gt; \n#&gt; $y\n\nbody(f02)\n#&gt; {\n#&gt;     x + y\n#&gt; }\n\nenvironment(f02)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n与R中的其他对象一样，函数也会拥有一些属性。一个常见的属性是srcref（source reference），记录了函数的源代码，如下所示。\n\nattr(f02, \"srcref\")\n#&gt; NULL\n\n\n\nPrimitive functions\n原始函数（primitive function）是一个例外，不包含上面的三要素。\n\nsum\n#&gt; function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#&gt; .Primitive(\"[\")\n\n它们的base type不同。（base type 见第12章）\n\ntypeof(sum)\n#&gt; [1] \"builtin\"\ntypeof(`[`)\n#&gt; [1] \"special\"\n\n因为它们的底层是C语言，所以formals()、body()和environment()返回值都是NULL。\n\nformals(sum)\n#&gt; NULL\nbody(sum)\n#&gt; NULL\nenvironment(sum)\n#&gt; NULL\n\n\n\nFirst-class functions\n所谓的first-class，就是指函数本身就是对象，可以用来赋值给变量，可以传递给函数等等。创建函数只需要function()来定义，使用&lt;-进行绑定。\n如果一个函数没有绑定名字，那么它就是匿名函数。匿名函数通常用在lapply()等函数中，用来实现高效的数据处理。\n\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x)^2, 0, pi)\n\n有关R函数的闭包特性，见第7章。\n\n\nInvoking a function\n使用函数的常见方式是myfun(param1, param2, ...)，如果你有了一组参数数据，可以使用do.call()来调用函数。\n\nargs &lt;- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#&gt; [1] 5.5\n\n\n\nExercises\n\n使用is.function()来判断一个对象是否是函数。对于原始函数，使用is.primitive()。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-composition",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-composition",
    "title": "6 Functions",
    "section": "Function composition",
    "text": "Function composition\nbase R 提供了两种函数组合使用的方式。例如，当你想使用sqrt()和mean()计算某个群体的方差：\n\nx &lt;- runif(100)\nsquare &lt;- function(x) x^2\ndeviation &lt;- function(x) x - mean(x)\n\n第一种方法：\n\nsqrt(mean(square(deviation(x))))\n#&gt; [1] 0.2744786\n\n第二种方法：\n\nout &lt;- deviation(x)\nout &lt;- square(out)\nout &lt;- mean(out)\nout &lt;- sqrt(out)\nout\n#&gt; [1] 0.2744786\n\nmagrittr包提供了第三种方式——管道符%&gt;%（R 4.0 之后可以之间使用 |&gt; 代替）。\n\nlibrary(magrittr)\n\nx %&gt;%\n  deviation() %&gt;%\n  square() %&gt;%\n  mean() %&gt;%\n  sqrt()\n#&gt; [1] 0.2744786",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#lexical-scoping",
    "href": "Books/Advanced R(2e)/6 Functions.html#lexical-scoping",
    "title": "6 Functions",
    "section": "Lexical scoping",
    "text": "Lexical scoping\n在第二章中，我们讲到为对象命名；在这里，我们介绍它的反面，根据名字找到对象——词法作用域(lexical scoping)。\nR 的词法作用域遵循下面四个规则：\n\nName masking——函数内部的变量优先于函数外部的变量。\nFunctions versus variables——当某个函数与变量同名时，R自动找到对应的对象。\nA fresh start——函数每次执行都是独立的。\nDynamic lookup——函数只有在运行时才会查找对应的对象。\n\n\nName masking\n函数查找变量时，首先查找函数内的变量，然后再查找函数外，即——由内到外逐级查找，直至找到为止。\n\nx &lt;- 10\ny &lt;- 20\nz &lt;- 30\ng05 &lt;- function() {\n  x &lt;- 1\n  y &lt;- 2\n  c(x, y, z)\n}\ng05()\n#&gt; [1]  1  2 30\n\n\n\nFunctions versus variables\n诚如上述，函数也是普通的对象，在进行函数的查找时，遵循相同的规则。\n\ng07 &lt;- function(x) x + 1\ng08 &lt;- function() {\n  g07 &lt;- function(x) x + 100\n  g07(10)\n}\ng08()\n#&gt; [1] 110\n\n如果，函数名和变量名重复（函数和变量在不同的环境中）时，R会自动找到对应类型的对象，例如下面的g09。实际编写代码时，我们要尽可能避免这种情况的发生，因为十分歧义和迷惑。\n\ng09 &lt;- function(x) x + 100\ng10 &lt;- function() {\n  g09 &lt;- 10\n  g09(g09)\n}\ng10()\n#&gt; [1] 110\n\n\n\nA fresh start\n下面的例子，每次运行g11()结果都是相同的，因为每次运行函数时，都会创建一个变量域（环境），它们之间相互独立。\n\ng11 &lt;- function() {\n  if (!exists(\"a\")) {\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\ng11()\n#&gt; [1] 1\ng11()\n#&gt; [1] 1\n\n当你使用a &lt;- g11()时，就打破了独立。\n\na &lt;- g11()\ng11()\n#&gt; [1] 2\ng11()\n#&gt; [1] 2\n\n\n\nDynamic lookup\n函数只有在运行时才会根据名字查找对象，也即前后环境不一致时，函数前后运行值也就不一样。\n\ng12 &lt;- function() x + 1\nx &lt;- 15\ng12()\n#&gt; [1] 16\n\nx &lt;- 20\ng12()\n#&gt; [1] 21\n\n使用codetools::findGlobals()可以里列出函数内的外部依赖项。\n\ncodetools::findGlobals(g12)\n#&gt; [1] \"+\" \"x\"\n\nenvironment(g12) &lt;- emptyenv()\ng12()\n#&gt; Error in x + 1: could not find function \"+\"\n\n\n\nExercises\n…",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#lazy-evaluation",
    "href": "Books/Advanced R(2e)/6 Functions.html#lazy-evaluation",
    "title": "6 Functions",
    "section": "Lazy evaluation",
    "text": "Lazy evaluation\nR 函数中的参数具有延迟评估（Lazy evaluation）特点：只有参数被使用时，才会对其进行评估（运行）。\n\nh01 &lt;- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#&gt; [1] 10\n\n这一特性允许解析耗时的参数只有在函数运行且被调用时进行解析。\n\nPromises\n延迟评估由一种被称为promise或thunk的数据结构赋能（这种数据结构，本人也不是很了解，可以GPT一下）。\npromise有三种类型：\n\n表达式，如1 + 1。\n创建的环境，如：函数自己的变量域。\n\n\ny &lt;- 10\nh02 &lt;- function(x) {\n  y &lt;- 100\n  x + 1\n}\n\nh02(y)\n#&gt; [1] 11\nh02(y &lt;- 1000)\n#&gt; [1] 1001\ny\n#&gt; [1] 1000\n\n\n无需重复计算的值，如下面的message结果只打印一次。\n\n\ndouble &lt;- function(x) {\n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 &lt;- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#&gt; [1] 40 40\n\nx &lt;- double(20)\nh03(x)\n#&gt; [1] 40 40\n\npromise类型的延迟评估具有一种“薛定谔的猫”的特点，任何尝试用R去评估它的操作都会破坏其promise特性。\n\n\nDefault arguments\n延迟评估，允许函数在设置默认参数时，引用函数内部变量域，例如下面的例子。在base R中的许多函数都有类似的应用，但是不推荐这样使用，这样会增加函数理解的困难。\n\nh04 &lt;- function(x = 1, y = x * 2, z = a + b) {\n  a &lt;- 10\n  b &lt;- 100\n\n  c(x, y, z)\n}\n\nh04()\n#&gt; [1]   1   2 110\n\n另外一个需要注意的是：将要延迟评估的表达式，“作为默认参数”和“直接传递给函数”，是两种不同的情况。下面的示例中，ls()作为默认参数时，评估的是函数内部的变量域，而不是外部环境。\n\nh05 &lt;- function(x = ls()) {\n  a &lt;- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#&gt; [1] \"a\" \"x\"\n\nh05(ls())\n#&gt;  [1] \"a\"         \"args\"      \"deviation\" \"double\"    \"f02\"       \"g05\"      \n#&gt;  [7] \"g07\"       \"g08\"       \"g09\"       \"g10\"       \"g11\"       \"g12\"      \n#&gt; [13] \"h01\"       \"h02\"       \"h03\"       \"h04\"       \"h05\"       \"out\"      \n#&gt; [19] \"square\"    \"status\"    \"x\"         \"y\"         \"z\"\n\n\n\nMissing arguments\n函数missing()可以用来判断函数参数值来源，若来自于默认值，那么返回TRUE，否则返回FALSE。\n\nh06 &lt;- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#&gt; List of 2\n#&gt;  $ : logi TRUE\n#&gt;  $ : num 10\nstr(h06(10))\n#&gt; List of 2\n#&gt;  $ : logi FALSE\n#&gt;  $ : num 10\n\n\n\nExercises\n\n下面代码发生的过程：\n\npromisex = {y &lt;- 1; 2}在函数f1自己创建的环境中被评估，赋值1给y，返回数值2。\npromise最终的运行结果——2，赋值给函数参数x。\n因为Name masking，不使用函数默认值，使用先前赋值为1的y。\n因为函数内部评估不影响外部变量，所以最外面的y仍为10。\n\n\n\ny &lt;- 10\nf1 &lt;- function(x = {\n                 y &lt;- 1\n                 2\n               }, y = 0) {\n  c(x, y)\n}\nf1()\n#&gt; [1] 2 1\ny\n#&gt; [1] 10",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#dot-dot-dot",
    "href": "Books/Advanced R(2e)/6 Functions.html#dot-dot-dot",
    "title": "6 Functions",
    "section": "...(dot-dot-dot)",
    "text": "...(dot-dot-dot)\n...是R函数的一个特殊参数，它使得R函数可以有任意数目的参数。\n\n应用...\n...主要应用在下面两种情况：\n\n要传递额外参数给另外一个函数。\n\n\ni01 &lt;- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 &lt;- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#&gt; List of 2\n#&gt;  $ y: num 2\n#&gt;  $ z: num 3\n\n# 常见的apply家族函数\nx &lt;- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#&gt; List of 2\n#&gt;  $ : num 2\n#&gt;  $ : num 5\n\n\nS3面向对象中的方法函数，如下面的print()函数，对于不同类使用不同参数。S3面向对象详见第13章。\n\n\nprint(factor(letters), max.levels = 4)\n#&gt;  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\n#&gt; 26 Levels: a b c ... z\n\nprint(y ~ x, showEnv = TRUE)\n#&gt; y ~ x\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n\n解析...\n\n可以使用..N的形式，来访问...中的第N个参数。\n\n\ni03 &lt;- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#&gt; List of 2\n#&gt;  $ first: num 1\n#&gt;  $ third: num 3\n\n\n可以使用list(...)将其转换为list，储存起来。\n\n\ni04 &lt;- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#&gt; List of 2\n#&gt;  $ a: num 1\n#&gt;  $ b: num 2\n\n\nrlang包提供了额外的解析方法。\n\n\nrlang::list2()\nrlang::enquos()",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#exiting-a-function",
    "href": "Books/Advanced R(2e)/6 Functions.html#exiting-a-function",
    "title": "6 Functions",
    "section": "Exiting a function",
    "text": "Exiting a function\n大多数函数的退出机制有两种：\n\n显性或隐性的返回一个值，表示运行成功。\n抛出错误信息，表示运行失败。\n\n\nImplicit versus explicit returns\n\n使用return()指定返回值。\n如果不使用return()指定返回值，默认使用最后运行代码的值作为返回值。\n\n\nj01 &lt;- function(x) {\n  if (x &lt; 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#&gt; [1] 0\nj01(15)\n#&gt; [1] 10\n\nj02 &lt;- function(x) {\n  if (x &lt; 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}\nj02(5)\n#&gt; [1] 0\nj02(15)\n#&gt; [1] 10\n\n\n\nInvisible values\n如果没有将函数的返回值赋值给某个变量，函数会将结果打印出来。\n\nj03 &lt;- function() 1\nx &lt;- j03()\nj03()\n#&gt; [1] 1\n\n使用invisible()可以阻止函数自动打印。\n\nj04 &lt;- function() invisible(1)\nj04()\nprint(j04())\n#&gt; [1] 1\n(j04())\n#&gt; [1] 1\n\n使用withVisible()可以获取函数的返回值和是否可见。\n\nstr(withVisible(j04()))\n#&gt; List of 2\n#&gt;  $ value  : num 1\n#&gt;  $ visible: logi FALSE\n\n最常见的隐藏返回值的函数就是&lt;-。\n\na &lt;- 2\n(a &lt;- 2)\n#&gt; [1] 2\n\n\n\nErrors\n当函数运行失败时，应当使用stop()函数抛出错误信息，并终止函数运行。抛出错误信息是为了让使用者知道函数运行失败的原因，以及如何处理。\n\nj05 &lt;- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#&gt; Error in j05(): I'm an error\n\n\n\nExit handlers\n在函数处理过程中，经常会有更新当前工作路径、绘图参数等全局变量，在函数运行结束后又要复原这些全局变量的操作。此时可以使用on.exit()函数来添加函数在退出时的操作。下面的示例显示了：无论函数运行成功还是失败，on.exit()函数都会执行。\n\nj06 &lt;- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n\n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#&gt; Hello\n#&gt; Goodbye!\n#&gt; [1] 10\n\nj06(FALSE)\n#&gt; Hello\n#&gt; Error in j06(FALSE): Error\n\non.exit()函数的另外两个参数：\n\nadd：当有多个退出操作时，如果add为FALSE则新的操作会覆盖原来的操作，推荐总是设置为TRUE。\nafter：当有多个退出操作时，如果after为FALSE，新的操作会最先执行。\n\n\nj08 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = FALSE)\n}\nj08()\n\nj09 &lt;- function() {\n  on.exit(message(\"a\"), add = TRUE, after = TRUE)\n  on.exit(message(\"b\"), add = TRUE, after = TRUE)\n  on.exit(message(\"c\"), add = TRUE, after = FALSE)\n}\nj09()\n\n\n\nExercises\n了解一下sink(),capture.output()函数。",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/6 Functions.html#function-forms",
    "href": "Books/Advanced R(2e)/6 Functions.html#function-forms",
    "title": "6 Functions",
    "section": "Function forms",
    "text": "Function forms\n\n\n\n\n\n\nTip\n\n\n\nR 里面的两句slogan：\n\nEverything that exists is an object.\nEverything that happens is a function call. — John Chambers\n\n\n\nR 中的函数有四种变体：\n\nprefix：函数名在参数前，例如mean(x)。\ninfix：函数名在参数之间，例如x + y的+；可以使用%前后包裹函数名，进行自定义。\nreplacement：带有&lt;-赋值操作的函数，例如names(df) &lt;- c(\"a\", \"b\")。\nspecial：例如[[、if、for等。\n\n\nRewriting to prefix form\n任何形式的函数都可以改写成prefix形式。\n\nx + y\n`+`(x, y)\n\nnames(df) &lt;- c(\"x\", \"y\", \"z\")\n`names&lt;-`(df, c(\"x\", \"y\", \"z\"))\n\nfor (i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n\nR 的这种特性，可以让你随意地更改R中的基本函数。下面是一个更新了(函数的例子，大约10次中有1次，返回值会加1。\n\n`(` &lt;- function(e1) {\n  if (is.numeric(e1) && runif(1) &lt; 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#&gt;  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#&gt; [37] 3 3 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\n\n\n\nPrefix form\nprefix 格式的函数可以通过下面三种方式检索参数（也是检索优先级，由高至低）：\n\n使用参数名。\n使用参数名部分匹配。\n使用参数位置。\n\n\nk01 &lt;- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\n\n\nstr(k01(1, 2, 3))\nstr(k01(2, 3, abcdef = 1)) 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n\n# But this doesn't work because abbreviation is ambiguous\nstr(k01(1, 3, b = 1))\n#&gt; Error in parse(text = input): &lt;text&gt;:2:28: unexpected numeric constant\n#&gt; 1: str(k01(1, 2, 3))\n#&gt; 2: str(k01(2, 3, abcdef = 1)) 3\n#&gt;                               ^\n\n通常使用位置的参数是函数参数中最常用的几个，不推荐使用部分匹配设置参数。很遗憾，在R中无法禁用模糊匹配，但可以设置options(warnPartialMatchArgs = TRUE)，生成警告信息。\n\noptions(warnPartialMatchArgs = TRUE)\nx &lt;- k01(a = 1, 2, 3)\n\n\n\nInfix form\ninfix 格式的函数要求只能有两个参数。在base R中有许多这种格式的函数：:, ::, :::, $, @, ^, *, /, +, -, &gt;, &gt;=, &lt;, &lt;=, ==, !=, !, &, &&, |, ||, ~, &lt;-, and &lt;&lt;-。也可以使用%前后包裹函数名，进行自定义。例如%*%,%in%等。\n\n`%+%` &lt;- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#&gt; [1] \"new string\"\n\n%之间的函数名可以是除%外的任意字符，需要转义的字符只需在定义时进行转义，使用时无须转义。\n\n`% %` &lt;- function(a, b) paste(a, b)\n`%/\\\\%` &lt;- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#&gt; [1] \"a b\"\n\"a\" %/\\% \"b\"\n#&gt; [1] \"a b\"\n\ninfix 格式的函数总是将其左右两端的参数作为输入。\n\n`%-%` &lt;- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#&gt; [1] \"((a %-% b) %-% c)\"\n\n\n\nReplacement form\nreplacement 格式的函数要求：\n\n至少两个参数，分别是待赋值的对象和值。\n必须返回更新值后的对象。\n\n\n`second&lt;-` &lt;- function(x, value) {\n  x[2] &lt;- value\n  x\n}\n\nx &lt;- 1:10\nsecond(x) &lt;- 5L\nx\n#&gt;  [1]  1  5  3  4  5  6  7  8  9 10\n\n如果你要添加额外参数，需要将其放置在x和value之间。\n\n`modify&lt;-` &lt;- function(x, position, value) {\n  x[position] &lt;- value\n  x\n}\nmodify(x, 1) &lt;- 10\nx\n#&gt;  [1] 10  5  3  4  5  6  7  8  9 10\n\n使用tracemem()追踪内存地址的变化。\n\nx &lt;- 1:10\ntracemem(x)\n#&gt; [1] \"&lt;0x5586ac400b08&gt;\"\n\nsecond(x) &lt;- 6L\n#&gt; tracemem[0x5586ac400b08 -&gt; 0x5586b3037368]: eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main \n#&gt; tracemem[0x5586b3037368 -&gt; 0x5586b3036488]: second&lt;- eval eval withVisible withCallingHandlers eval eval with_handlers doWithOneRestart withOneRestart withRestartList doWithOneRestart withOneRestart withRestartList withRestarts &lt;Anonymous&gt; evaluate in_dir in_input_dir eng_r block_exec call_block process_group withCallingHandlers &lt;Anonymous&gt; process_file &lt;Anonymous&gt; &lt;Anonymous&gt; execute .main\n\n\n\nSepcial forms\n下面是一些特殊格式的函数和它转换为prefix后的格式\n\n\n\n\n\n\n\nspecial form\nprefix form\n\n\n\n\n(x)\n`(`(x)\n\n\n{x}\n`{`(x)\n\n\nx[i]\n`[`(x, i)\n\n\nx[[i]]\n`[[`(x, i)\n\n\nif (cond) true\n`if`(cond, true)\n\n\nif (cond) true else false\n`if`(cond, true, false)\n\n\nfor(var in seq) action\n`for`(var, seq, action)\n\n\nwhile (cond) action\n`while`(cond, action)\n\n\nrepeat expr\n`repeat`(expr)\n\n\nnext\n`next`()\n\n\nbreak\n`break`()\n\n\nfunction(arg1, arg2) {body}\n`function`(alist(arg1, arg2), body, env )\n\n\n\n\n\nExercises\n…",
    "crumbs": [
      "6 Functions"
    ]
  },
  {
    "objectID": "Blog/dot dot dot.html",
    "href": "Blog/dot dot dot.html",
    "title": "评估参数…",
    "section": "",
    "text": "rlang::list2()\n#&gt; list()\nrlang::enquos()\n#&gt; &lt;list_of&lt;quosure&gt;&gt;\n#&gt; \n#&gt; named list()\nsum()\n#&gt; [1] 0\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Blog/Data Masking.html",
    "href": "Blog/Data Masking.html",
    "title": "Data Masking(1)",
    "section": "",
    "text": "library(tidyverse)\nlibrary(rlang)"
  },
  {
    "objectID": "Blog/Data Masking.html#什么是data-masking",
    "href": "Blog/Data Masking.html#什么是data-masking",
    "title": "Data Masking(1)",
    "section": "什么是data-masking",
    "text": "什么是data-masking\nData-masking 是一种允许直接调用数据框中的列名作为一个正常环境变量的技术。例如下例，使用with函数实现该目的：\n\n# Unmasked programming\nmean(mtcars$cyl + mtcars$am)\n#&gt; [1] 6.59375\n\n# Referring to columns is an error - Where is the data?\nmean(cyl + am)\n#&gt; Error: object 'cyl' not found\n\n# Data-masking\nwith(mtcars, mean(cyl + am))\n#&gt; [1] 6.59375"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-带来的问题",
    "href": "Blog/Data Masking.html#data-masking-带来的问题",
    "title": "Data Masking(1)",
    "section": "data-masking 带来的问题",
    "text": "data-masking 带来的问题\n虽然 data-masking 技术使得操作数据框十分方便，但会增加创造函数的困难。例如下面例子中的var,var2在函数bodys中并不表示参数，而是被 data-masking 解释为数据data中的列。\n\nmy_mean &lt;- function(data, var1, var2) {\n  dplyr::summarise(data, mean(var1 + var2))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt; Error in `dplyr::summarise()`:\n#&gt; ℹ In argument: `mean(var1 + var2)`.\n#&gt; Caused by error:\n#&gt; ! object 'cyl' not found\n\n使用{{可以避免 data-masking 带来的问题，因为它会把var1和var2解释为参数而不是数据data中的列。\n\nmy_mean &lt;- function(data, var1, var2) {\n  dplyr::summarise(data, mean({{ var1 }} + {{ var2 }}))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt;   mean(cyl + am)\n#&gt; 1        6.59375"
  },
  {
    "objectID": "Blog/Data Masking.html#masking-具体是什么意思",
    "href": "Blog/Data Masking.html#masking-具体是什么意思",
    "title": "Data Masking(1)",
    "section": "masking 具体是什么意思？",
    "text": "masking 具体是什么意思？\n从上面的例子中也可以看出，所谓的masking，就是词法作用域的优先级。相同变量名在data-masking中会被优先解释为数据框中的列，而非外部环境中的变量。rlang 包所构建的tidy eval框架提供了pronouns来声明变量的所属环境。\n\ncyl &lt;- 1000\n\nmtcars %&gt;%\n  dplyr::summarise(\n    mean_data = mean(.data$cyl),\n    mean_env = mean(.env$cyl)\n  )\n#&gt;   mean_data mean_env\n#&gt; 1    6.1875     1000"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-如何工作",
    "href": "Blog/Data Masking.html#data-masking-如何工作",
    "title": "Data Masking(1)",
    "section": "data-masking 如何工作？",
    "text": "data-masking 如何工作？\ndata-masking 依赖R语言的三个特点：\n\ndefuse 变量，如 base R 中的substitute()、rlang 中的enquo(),{{等。\nfirst class environment。环境在R中一个类似list的特殊对象，R 允许将list或dataframe转换为环境。\n\n\nas.environment(mtcars)\n#&gt; &lt;environment: 0x564b1f41a790&gt;\n\n\n评估函数——eval()(base)、eval_tidy()(rlang)。\n\n也即：先将变量名转换为defused状态，变得不可用，然后将dataframe转换为环境，最后在转换后的环境中重新评估变量。"
  },
  {
    "objectID": "Blog/Data Masking.html#data-masking-编程模式",
    "href": "Blog/Data Masking.html#data-masking-编程模式",
    "title": "Data Masking(1)",
    "section": "data-masking 编程模式",
    "text": "data-masking 编程模式\n诚如上述，在函数中使用 data-masking，需要特殊处理才能正确解析参数。在rlang官网上，有四种解决方案。\n\nforwarding pattern\n\n\n使用{{\n{{用来直接解析单个参数，并且不丢失原有的信息（观察下面例子列名）。\n\nmy_summarise &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise({{ var }})\n}\n\nmtcars %&gt;% my_summarise(mean(cyl))\n#&gt;   mean(cyl)\n#&gt; 1    6.1875\n\nx &lt;- \"cyl\"\nmtcars %&gt;% my_summarise(mean(.data[[x]]))\n#&gt;   mean(.data[[\"cyl\"]])\n#&gt; 1               6.1875\n\n\n\n...\n... 不要求额外的语法设置，可以直接使用，用来解析多个参数。\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(...)\n}\n\nmtcars %&gt;% my_group_by(cyl = cyl * 100, am)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21     600   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21     600   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8   400   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4   600   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7   800   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1   600   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\nmy_select &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::select(...)\n}\n\nmtcars %&gt;% my_select(starts_with(\"c\"), vs:carb)\n#&gt;                     cyl carb vs am gear\n#&gt; Mazda RX4             6    4  0  1    4\n#&gt; Mazda RX4 Wag         6    4  0  1    4\n#&gt; Datsun 710            4    1  1  1    4\n#&gt; Hornet 4 Drive        6    1  1  0    3\n#&gt; Hornet Sportabout     8    2  0  0    3\n#&gt; Valiant               6    1  1  0    3\n#&gt; Duster 360            8    4  0  0    3\n#&gt; Merc 240D             4    2  1  0    4\n#&gt; Merc 230              4    2  1  0    4\n#&gt; Merc 280              6    4  1  0    4\n#&gt; Merc 280C             6    4  1  0    4\n#&gt; Merc 450SE            8    3  0  0    3\n#&gt; Merc 450SL            8    3  0  0    3\n#&gt; Merc 450SLC           8    3  0  0    3\n#&gt; Cadillac Fleetwood    8    4  0  0    3\n#&gt; Lincoln Continental   8    4  0  0    3\n#&gt; Chrysler Imperial     8    4  0  0    3\n#&gt; Fiat 128              4    1  1  1    4\n#&gt; Honda Civic           4    2  1  1    4\n#&gt; Toyota Corolla        4    1  1  1    4\n#&gt; Toyota Corona         4    1  1  0    3\n#&gt; Dodge Challenger      8    2  0  0    3\n#&gt; AMC Javelin           8    2  0  0    3\n#&gt; Camaro Z28            8    4  0  0    3\n#&gt; Pontiac Firebird      8    2  0  0    3\n#&gt; Fiat X1-9             4    1  1  1    4\n#&gt; Porsche 914-2         4    2  0  1    5\n#&gt; Lotus Europa          4    2  1  1    5\n#&gt; Ford Pantera L        8    4  0  1    5\n#&gt; Ferrari Dino          6    6  0  1    5\n#&gt; Maserati Bora         8    8  0  1    5\n#&gt; Volvo 142E            4    2  1  1    4\n\n有些函数会将多个参数同时传递给函数中的一个参数，如下例所示。此时c()生成的不是向量，而是tidy-select组合。\n\nmy_pivot_longer &lt;- function(.data, ...) {\n  .data %&gt;% tidyr::pivot_longer(c(...))\n}\n\nmtcars %&gt;% my_pivot_longer(starts_with(\"c\"), vs:carb)\n#&gt; # A tibble: 160 × 8\n#&gt;     mpg  disp    hp  drat    wt  qsec name  value\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1    21   160   110   3.9  2.62  16.5 cyl       6\n#&gt; 2    21   160   110   3.9  2.62  16.5 carb      4\n#&gt; 3    21   160   110   3.9  2.62  16.5 vs        0\n#&gt; 4    21   160   110   3.9  2.62  16.5 am        1\n#&gt; 5    21   160   110   3.9  2.62  16.5 gear      4\n#&gt; 6    21   160   110   3.9  2.88  17.0 cyl       6\n#&gt; # ℹ 154 more rows\n\n\n\nname pattern\n使用tidy eval框架提供的pronouns，可以直接使用参数。\n\nmy_mean &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise(mean = mean(.data[[var]]))\n}\n\nmy_mean(mtcars, \"cyl\")\n#&gt;     mean\n#&gt; 1 6.1875\n\n遗憾的是，这种方法只能处理单个参数的情况。\n\nmtcars %&gt;% dplyr::summarise(.data[c(\"cyl\", \"am\")])\n#&gt; Error in `dplyr::summarise()`:\n#&gt; ℹ In argument: `.data[c(\"cyl\", \"am\")]`.\n#&gt; Caused by error in `.data[c(\"cyl\", \"am\")]`:\n#&gt; ! `[` is not supported by the `.data` pronoun, use `[[` or $ instead.\n\n\n\nbridge pattern\n使用中间桥梁函数解析参数，如across()、transmute()等\n\nacross()\n\nmy_group_by &lt;- function(data, var) {\n  data %&gt;% dplyr::group_by(across({{ var }}))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb [9]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(across(c(...)))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"), vs:gear)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb, vs, am, gear [15]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\nmy_group_by &lt;- function(data, vars) {\n  data %&gt;% dplyr::group_by(across(all_of(vars)))\n}\n\nmtcars %&gt;% my_group_by(c(\"cyl\", \"am\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n#&gt; 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n#&gt; 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n#&gt; 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n#&gt; 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n#&gt; 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n#&gt; # ℹ 26 more rows\n\n\n\n\ntransmute()\n\nmy_pivot_longer &lt;- function(data, ...) {\n  # Forward `...` in data-mask context with `transmute()`\n  # and save the inputs names\n  inputs &lt;- dplyr::transmute(data, ...)\n  names &lt;- names(inputs)\n\n  # Update the data with the inputs\n  data &lt;- dplyr::mutate(data, !!!inputs)\n\n  # Select the inputs by name with `all_of()`\n  tidyr::pivot_longer(data, cols = all_of(names))\n}\n\nmtcars %&gt;% my_pivot_longer(cyl, am = am * 100)\n#&gt; # A tibble: 64 × 11\n#&gt;     mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1  21     160   110  3.9   2.62  16.5     0     4     4 cyl       6\n#&gt; 2  21     160   110  3.9   2.62  16.5     0     4     4 am      100\n#&gt; 3  21     160   110  3.9   2.88  17.0     0     4     4 cyl       6\n#&gt; 4  21     160   110  3.9   2.88  17.0     0     4     4 am      100\n#&gt; 5  22.8   108    93  3.85  2.32  18.6     1     4     1 cyl       4\n#&gt; 6  22.8   108    93  3.85  2.32  18.6     1     4     1 am      100\n#&gt; # ℹ 58 more rows\n\n使用transmute()创建新的数据框，然后提取name，最后更新数据框。\n\n\nTransformation patterns\n对多个参数执行相同的操作，有下面两种类型：\n\nTransforming inputs with across()\n\nmy_mean &lt;- function(data, ...) {\n  data %&gt;% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE)))\n}\n\nmtcars %&gt;% my_mean(cyl, carb)\n#&gt;      cyl   carb\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(foo = cyl, bar = carb)\n#&gt;      foo    bar\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(starts_with(\"c\"), mpg:disp)\n#&gt;      cyl   carb      mpg     disp\n#&gt; 1 6.1875 2.8125 20.09062 230.7219\n\n\n\nTransforming inputs with if_all() and if_any()\n\nfilter_non_baseline &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::filter(if_all(c(...), ~ .x != min(.x, na.rm = TRUE)))\n}\n\nmtcars %&gt;% filter_non_baseline(vs, am, gear)\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"
  },
  {
    "objectID": "Blog/| and & in R.html",
    "href": "Blog/| and & in R.html",
    "title": "R 中的 | 与 &",
    "section": "",
    "text": "`%||%` &lt;- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\n\nx_ok &lt;- function(x) {\n  !is.null(x) && length(x) == 1 && x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; [1] FALSE\n#&gt; [1] FALSE\nx_ok(1)\n#&gt; [1] TRUE\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE\n#&gt; [1] FALSE\n\nx_ok &lt;- function(x) {\n  !is.null(x) & length(x) == 1 & x &gt; 0\n}\n\nx_ok(NULL)\n#&gt; logical(0)\n#&gt; logical(0)\nx_ok(1)\n#&gt; [1] TRUE\n#&gt; [1] TRUE\nx_ok(1:3)\n#&gt; [1] FALSE FALSE FALSE\n#&gt; [1] FALSE FALSE FALSE\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Books/Js4R/01 Overview.html",
    "href": "Books/Js4R/01 Overview.html",
    "title": "01 Overview",
    "section": "",
    "text": "将风马牛不相及的两种语言——R、Javascript 结合使用，目的是为了取长补短，发挥各自优势（实际上我只知道R，Javascript 却完全不懂，我只想单纯想用R写出web）。\n一个直白的原因是：R 想实现的功能可能在Javascript 中已经存在，我们没有必要重新发明轮子，为 R 打包一个调用 JavaScript 的API即可。例如rmapshaper包，提供了调用 JavaScript 对GeoJSON文件进行修改的API。\n\nlibrary(rmapshaper)\n\n# get data\ndata(states, package = \"geojsonio\")\n\nstates_json &lt;- geojsonio::geojson_json(\n  states,\n  geometry = \"polygon\",\n  group = \"group\"\n)\nstates_sp &lt;- geojsonio::geojson_sp(states_json)\n\n# print shape file size\nprint(object.size(states_sp), units = \"Mb\")\n#&gt; 0.4 Mb\n#&gt; 0.4 Mb\n\n# simplify with rmapshaper\nstates_sm &lt;- rmapshaper::ms_simplify(states_sp, keep = 0.05)\n\n# print reduced size\nprint(object.size(states_sm), units = \"Mb\")\n#&gt; 0.2 Mb\n\n另外一个原因是：JavaScript 可以做 R 不能做的事。例如下面的plotly包，生成一个可交互的图形。\n\nlibrary(plotly)\n\nplot_ly(diamonds, x = ~cut, color = ~clarity, width = \"100%\")\n\n\n\n\n\n最后一个原因：JavaScript 可以与 R 协同工作，改进我们交流的方式，例如shiny应用——显示一个等待框。\n\nlibrary(shiny)\nlibrary(waiter)\n\nui &lt;- fluidPage(\n  use_waiter(), # include dependencies\n  actionButton(\"show\", \"Show loading for 3 seconds\")\n)\n\nserver &lt;- function(input, output, session) {\n  # create a waiter\n  w &lt;- Waiter$new()\n\n  # on button click\n  observeEvent(input$show, {\n    w$show()\n    Sys.sleep(3)\n    w$hide()\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#rationale为什么结合r与javascript",
    "href": "Books/Js4R/01 Overview.html#rationale为什么结合r与javascript",
    "title": "01 Overview",
    "section": "",
    "text": "将风马牛不相及的两种语言——R、Javascript 结合使用，目的是为了取长补短，发挥各自优势（实际上我只知道R，Javascript 却完全不懂，我只想单纯想用R写出web）。\n一个直白的原因是：R 想实现的功能可能在Javascript 中已经存在，我们没有必要重新发明轮子，为 R 打包一个调用 JavaScript 的API即可。例如rmapshaper包，提供了调用 JavaScript 对GeoJSON文件进行修改的API。\n\nlibrary(rmapshaper)\n\n# get data\ndata(states, package = \"geojsonio\")\n\nstates_json &lt;- geojsonio::geojson_json(\n  states,\n  geometry = \"polygon\",\n  group = \"group\"\n)\nstates_sp &lt;- geojsonio::geojson_sp(states_json)\n\n# print shape file size\nprint(object.size(states_sp), units = \"Mb\")\n#&gt; 0.4 Mb\n#&gt; 0.4 Mb\n\n# simplify with rmapshaper\nstates_sm &lt;- rmapshaper::ms_simplify(states_sp, keep = 0.05)\n\n# print reduced size\nprint(object.size(states_sm), units = \"Mb\")\n#&gt; 0.2 Mb\n\n另外一个原因是：JavaScript 可以做 R 不能做的事。例如下面的plotly包，生成一个可交互的图形。\n\nlibrary(plotly)\n\nplot_ly(diamonds, x = ~cut, color = ~clarity, width = \"100%\")\n\n\n\n\n\n最后一个原因：JavaScript 可以与 R 协同工作，改进我们交流的方式，例如shiny应用——显示一个等待框。\n\nlibrary(shiny)\nlibrary(waiter)\n\nui &lt;- fluidPage(\n  use_waiter(), # include dependencies\n  actionButton(\"show\", \"Show loading for 3 seconds\")\n)\n\nserver &lt;- function(input, output, session) {\n  # create a waiter\n  w &lt;- Waiter$new()\n\n  # on button click\n  observeEvent(input$show, {\n    w$show()\n    Sys.sleep(3)\n    w$hide()\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#methods结合r与javascript的方法",
    "href": "Books/Js4R/01 Overview.html#methods结合r与javascript的方法",
    "title": "01 Overview",
    "section": "Methods(结合R与Javascript的方法)",
    "text": "Methods(结合R与Javascript的方法)\n上面示例，都结合了R与Javascript，但是它们的方法不同。\n\nV8\nV8 是一个基于Chrome的 JavaScript 引擎，它允许我们使用R语言调用JavaScript代码。这是rmapshaper包中调用JavaScript代码的基础。\n\nlibrary(V8)\n\nctx &lt;- v8()\n\nctx$eval(\"2 + 2\") # this is evaluated in JavaScript!\n#&gt; [1] \"4\"\n#&gt; [1] \"4\"\n\n\n\nhtmlwidgets\nhtmlwidgets 调用JavaScript库，生成可交互的图像。上面的plotly包就是基于htmlwidgets包，同时还有DT、highcharts、leaflet等。\n\n\nshiny\nshiny 框架允许创建web应用，使得前后端进行数据传输。",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/01 Overview.html#methods-amiss没有提及的方法",
    "href": "Books/Js4R/01 Overview.html#methods-amiss没有提及的方法",
    "title": "01 Overview",
    "section": "Methods Amiss(没有提及的方法)",
    "text": "Methods Amiss(没有提及的方法)\n除上面三种框架外，还有两种方法没有提及：\n\nreactR & vueR\nReactR 包，类似于htmlwidgets，但是它适用于 React 框架；而且，它不仅限于可视化输出，还提供了构建输入的功能，例如，下拉菜单等。reactable 包，类似于DT包，生成可交互的表格，但是它使用React框架。\n\nreactable::reactable(iris[1:5, ], showPagination = TRUE)\n\n\n\n\n\nvueR 包与reactR 类似，但是它使用Vue框架。\n\n\nr2d3\nr2d3 包，允许我们使用R语言调用D3 JavaScript库(d3.js)，生成图片，但它的底层逻辑与htmlwidgets完全不同。\n\n# 你需要创建一个 JavaScript 文件 chord.js\n# chord.js 代码见 https://rstudio.github.io/r2d3/articles/gallery/chord/\nlibrary(r2d3)\nr2d3(data = matrix(round(runif(16, 1, 10000)), ncol = 4, nrow = 4), script = \"chord.js\")",
    "crumbs": [
      "01 Overview"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html",
    "href": "Books/Js4R/00 Preface.html",
    "title": "00 Preface",
    "section": "",
    "text": "本书的主要内容是如何将Javascript与R有机结合，使得能在R中书写网页应用。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#引言",
    "href": "Books/Js4R/00 Preface.html#引言",
    "title": "00 Preface",
    "section": "引言",
    "text": "引言\n很多R语言使用者对shiny，rmarkdown等或多或少的熟悉，却不熟悉web核心技术——JavaScript，本书旨在通过揭示 JavaScript 在多大程度上能够极大地增强数据科学流水线的各个阶段，从分析到结果传达，来弥补这一缺陷。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#目录",
    "href": "Books/Js4R/00 Preface.html#目录",
    "title": "00 Preface",
    "section": "目录",
    "text": "目录",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html",
    "href": "Books/Js4R/02 Prerequisites.html",
    "title": "02 Prerequisites",
    "section": "",
    "text": "本章介绍一些后续会用到的必要知识：\n即：以shiny框架为基础，通过Json格式数据，沟通R与JavaScript，将这种沟通方式打包为R包，方便调用与测试。"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#构建r包",
    "href": "Books/Js4R/02 Prerequisites.html#构建r包",
    "title": "02 Prerequisites",
    "section": "构建R包",
    "text": "构建R包\n这里简单简绍构建R包的方法，具体可参考 R Packages\n\ninstall.packages(c(\"devtools\", \"usethis\"))\n\n\n创建R包\n使用Rstudio创建R包：File &gt; New Project &gt; New Directory &gt; R Package\n\n使用usethis创建R包，Rstudio使用相同的命令创建R包。\n\n# 在当前工作目录下创建名为test的R包，同时自动设置工作目录为test包路径\nusethis::create_package(\"test\")\n# getwd()\n\n\n\nMetadata\n每个R包都有DESCRIPTION文件，该文件包含包名、版本、作者、依赖等信息。例如下面是test包的默认DESCRIPTION文件：\nPackage: test\nTitle: What the Package Does (One Line, Title Case)\nVersion: 0.0.0.9000\nAuthors@R:\n    person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"))\nDescription: What the package does (one paragraph).\nLicense: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n    license\nEncoding: UTF-8\nRoxygen: list(markdown = TRUE)\nRoxygenNote: 7.3.2\n假如你创建了一个依赖stringr包的脚本string.R，那么你需要在DESCRIPTION文件中添加依赖项。如果有多个，使用,分割。\nImports:\n  stringr,\n  dplyr\n也可以使用usethis添加依赖项。\n\n# add stringr under Imports\nusethis::use_package(\"stringr\")\n\nSuggests与Imports类似，但不会强制安装。\n\n\nR code\nR 包有着严格的结构要求，R/目录只能用来存放以.R结尾的R文件。上面的string.R文件就是在R/目录下。\n\n\nDocumentation\nroxygen2包可以识别在R函数前添加#'开头的注释，自动生成使用?进行查询的函数说明文档。这些说明文档以.Rd结尾，存放在man/目录下。\n在注释中，可以使用一些roxygen2标签，如@param、@example、@importFrom、@export等。\n\n@param: 参数说明，参数类型，参数描述。\n@example: 函数使用示例。\n@importFrom: 导入R包，该包中的函数。\n@export: 导出函数，使得该函数可以被用户调用。\n\n\n#' Strings Length\n#'\n#' Returns the number of characters in strings.\n#'\n#' @param strings A vector of character strings.\n#'\n#' @example string_length(c(\"hello\", \"world\"))\n#'\n#' @importFrom stringr str_length\n#'\n#' @export\nstring_length &lt;- function(strings) {\n  str_length(strings) # namespace removed\n}\n\nroxygen2 包会收集函数名，生成NAMESPACE文件，该文件包含了被该包导入和导出的函数。例如将上面的code替换之前的string.R文件，然后使用devtools::document()命令，生成man/文件夹和NAMESPACE文件。\n\n\nInstalled files\n在inst/目录下，用来存放一些能够被用户使用system.file()获取的文件。在本书中，你会见到很多这种用法。\n\n# return path to `inst/dependency.js` in `myPackage`\npath &lt;- system.file(\"dependency.js\", package = \"myPackage\")\n\n\n\nBuild, load and install\n在使用devtools::document()生成说明文档后，可以使用devtools::install()进行本地安装。但在实际开发R包时，通常使用devtools::load_all()进行本地加载。下面是一个开发R包的惯用流程：\n\nWrite some code\nRun devtools::document() (if documentation tags have changed)\nRun devtools::load_all()\nRepeat"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#json",
    "href": "Books/Js4R/02 Prerequisites.html#json",
    "title": "02 Prerequisites",
    "section": "Json",
    "text": "Json\nJSON (JavaScript Object Notation) 是一种流行的数据交换格式。在R中，我们使用jsonlite包进行序列化与反序列化。\n\nSerialising\nJson数据格式类似R中的list，可以存放除dataframe外的任何数据。下面是一个简单示例，参数pretty控制输出格式是否有空格。\n\n# install.packages(\"jsonlite\")\nlibrary(jsonlite)\n\nlst &lt;- list(\n  a = 1,\n  b = list(\n    c = c(\"A\", \"B\")\n  ),\n  d = 1:5\n)\n\ntoJSON(lst, pretty = TRUE)\n#&gt; {\n#&gt;   \"a\": [1],\n#&gt;   \"b\": {\n#&gt;     \"c\": [\"A\", \"B\"]\n#&gt;   },\n#&gt;   \"d\": [1, 2, 3, 4, 5]\n#&gt; }\n\n仔细观察上面的R list对象和json结果，a = 1虽然是单个数字，但其在R中实际是长度为1的向量，所以json中表现为\"a\": [1]。\n\nx &lt;- 1\nlength(x)\n#&gt; [1] 1\nis.vector(x)\n#&gt; [1] TRUE\n\n可以使用参数auto_unbox = TRUE来自动去除长度为1的向量中的[]，并且转换为json中的特殊数据类型：integer、number、boolean等。\n\ntoJSON(lst, pretty = TRUE, auto_unbox = TRUE)\n#&gt; {\n#&gt;   \"a\": 1,\n#&gt;   \"b\": {\n#&gt;     \"c\": [\"A\", \"B\"]\n#&gt;   },\n#&gt;   \"d\": [1, 2, 3, 4, 5]\n#&gt; }\n\n要注意，如果你将a=1变为a=list(1)，那么toJSON(lst, pretty = TRUE, auto_unbox = TRUE)将返回\"a\": [1]，而不是\"a\": 1。\n\n\nTabular Data\n如果数据是dataframe，jsonlite会逐行将dataframe转换为json。\n\n# subset of built-in dataset\ndf &lt;- cars[1:2, ]\n\ntoJSON(df, pretty = TRUE)\n#&gt; [\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 2\n#&gt;   },\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 10\n#&gt;   }\n#&gt; ]\n\n上面的代码也可以使用下面的步骤实现：去除行名，按行生成list。\n\nrow.names(df) &lt;- NULL\ndf_list &lt;- apply(df, 1, as.list)\n\ntoJSON(df_list, pretty = TRUE, auto_unbox = TRUE)\n#&gt; [\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 2\n#&gt;   },\n#&gt;   {\n#&gt;     \"speed\": 4,\n#&gt;     \"dist\": 10\n#&gt;   }\n#&gt; ]\n\njsonlite在读取json时，会自动将这种格式的数据转换为dataframe。\n\nclass(df_list)\n#&gt; [1] \"list\"\njson &lt;- toJSON(df_list)\nfromJSON(json)\n#&gt;   speed dist\n#&gt; 1     4    2\n#&gt; 2     4   10"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#javascript",
    "href": "Books/Js4R/02 Prerequisites.html#javascript",
    "title": "02 Prerequisites",
    "section": "JavaScript",
    "text": "JavaScript\nJavaScript的简介请自查。\n\nVariable Declaration and Scope\n一个与R显著不同的地方是：Javascript需要使用var,let,const来声明变量。\n\nvar: 可以只声明一个变量但不赋值，后续可以进行赋值更新。\nconst: 声明一个常量，不能进行赋值更新。\nlet: 常用于在if,switch,for和while中，声明一个变量，不能进行赋值更新。\n\nvar y; // declare\ny = [1,2,3]; // define it as array\ny = 'string'; // change to character string\n\nconst x = 1; // declare constant\nx = 2; // error\n\nif(true){\n  let x = 1;\n  var y = 1;\n}\n\nconsole.log(x) // error x does not exist\nconsole.log(y) // works\n\n\nDocument Object Model\nhtml中的DOM结构会被JavaScript解析为document对象，通过document对象，JavaScript可以访问和修改HTML结构。例如下面通过getElementById方法获取id为content的p元素，并修改其内容。\n &lt;!–– index.html ––&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"content\"&gt;Trying JavaScript!&lt;/p&gt;\n  &lt;/body&gt;\n  &lt;script&gt;\n    var cnt = document.getElementById(\"content\");\n    cnt.innerText = \"The text has changed\";\n  &lt;/script&gt;\n&lt;/html&gt;\n同CSS一样，使用quarySelector选择器来选择元素时，#开头表示选择id，.开头表示选择class。\n &lt;!–– index.html ––&gt;\n&lt;html&gt;\n  &lt;head&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p id=\"content\" class=\"stuff\"&gt;Trying JavaScript!&lt;/p&gt;\n  &lt;/body&gt;\n  &lt;script&gt;\n    // select by id\n    var x = document.getElementById(\"content\");\n    var y = document.querySelector(\"#content\");\n\n    console.log(x == y); // true\n\n    // select by class\n    var z = document.querySelector(\".stuff\");\n  &lt;/script&gt;\n&lt;/html&gt;"
  },
  {
    "objectID": "Books/Js4R/02 Prerequisites.html#shiny",
    "href": "Books/Js4R/02 Prerequisites.html#shiny",
    "title": "02 Prerequisites",
    "section": "Shiny",
    "text": "Shiny\n静态文件指的是会被客户端下载的文件，如图片、css、js等。R包中的inst文件夹就是用来存放静态文件的，同样可以用来存放Shiny 应用的静态文件。\n有两种将静态文件引入到shiny中的方式：\n\n手动引入。\n使用htmltools包引入。\n\n\nServing Static Files\n使用addResourcePath()声明静态文件路径，参数prefix为URL中显示的路径名，directoryPath为静态文件路径。\n运行下面的shiny应用，可以通过files/script.js(127.0.0.1:3000/files/script.js)访问到script.js文件。\n\n# run from root of app (where app.R is located)\ndir.create(\"assets\")\nwriteLines(\"console.log('Hello JS!');\", con = \"assets/script.js\")\n\n\n# app.R\nlibrary(shiny)\n\n# serve the files\naddResourcePath(prefix = \"files\", directoryPath = \"assets\")\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"files/script.js\")\n  ),\n  h1(\"R and JavaScript\")\n)\n\nserver &lt;- function(input, output) {}\n\nshinyApp(ui, server)\nshinyApp(ui, server)\n\n上面的步骤使得客户端可以访问到静态文件。仍需要在代码中添加使用这些静态文件的相关代码。下面的例子会在浏览器终端console中打印”Hello JS!“。\n\n# app.R\nlibrary(shiny)\n\n# serve the files\naddResourcePath(prefix = \"files\", directoryPath = \"assets\")\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$script(src = \"files/script.js\")\n  ),\n  h1(\"R and JavaScript\")\n)\n\nserver &lt;- function(input, output) {}\n\nshinyApp(ui, server)\n\n\n\nHtmltools\nhtmltools中的htmlDependency()函数可以创建shiny依赖性并且只加载一次。参数src可以是一个URL(href)或者一个本地文件夹路径(file)，文件夹中存放script和stylesheet参数提供的文件。\n\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = c(file = \"path/to/directory\"),\n  script = \"script.js\",\n  stylesheet = \"styles.css\"\n)\n\n\n# dependency to the latest jQuery\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = c(\n    href = \"https://cdn.jsdelivr.net/gh/jquery/jquery/dist/\"\n  ),\n  script = \"jquery.min.js\"\n)\n\n同样地，实际最终地html中会生成如下代码：\n&lt;script\n  src=\"https://cdn.jsdelivr.net/gh/jquery/jquery/\n    dist/jquery.min.js\"&gt;\n&lt;/script&gt;\nhtmltools::htmlDependency也可以接受一个package参数，用来定位R包中地依赖文件。下面例子中最终的路径为myPackage/inst/assets/script.js。\n\ndependency &lt;- htmltools::htmlDependency(\n  name = \"myDependency\",\n  version = \"1.0.0\",\n  src = \"assets\",\n  script = c(file = \"script.js\"),\n  package = \"myPackage\" # user package\n)\n\n创建好的依赖对象，只需放入到UI中即可使用。\n\nui &lt;- fluidPage(\n  dependency\n)"
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html",
    "href": "Books/Js4R/03 Introduction to Widgets.html",
    "title": "03 Introduction to Widgets",
    "section": "",
    "text": "本书此部分介绍如何通过htmlwidgets包整合R与JavaScript。htmlwidgets包起源于2012年的rCharts包，该包常用来数据可视化，但不限于此。在学习如何编写自己的第一个widget前，本章先介绍一些已经在CRAN上存在的widgets，通过它们，了解htmlwidgets包如何工作。",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#plotly-package",
    "href": "Books/Js4R/03 Introduction to Widgets.html#plotly-package",
    "title": "03 Introduction to Widgets",
    "section": "plotly package",
    "text": "plotly package\nplotly包提供了plotly.js在R中的API接口，可以绘制超40种，包括3D，统计，地理等方面的图形。\n有关plotly包的更多介绍见：Interactive web-based data visualization with R, plotly, and shiny。\n下面是一个可以交互的简单示例：\n\nlibrary(plotly)\n\nplot_ly(cars, x = ~speed, y = ~dist) %&gt;%\n  add_markers()\n\n\n\nplotly scatter plot\n\n\nplotly包也可以使用ggplotly()函数将ggplot2绘制的静态图进行转换（仅支持部分类型图）：\n\np &lt;- ggplot(diamonds, aes(x = log(carat), y = log(price))) +\n  geom_hex(bins = 100)\nggplotly(p)\n\n\n\nInteractive ggplot2 with plotly\n\n\nplotly包使用类似ggplot2包中的geom语法——add_*添加图层。\n\nplot_ly(mtcars, x = ~disp) %&gt;%\n  add_markers(y = ~mpg, text = rownames(mtcars)) %&gt;%\n  add_lines(y = ~ fitted(loess(mpg ~ disp)))\n\n\n\nMultiple layers with plotly",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#dt-package",
    "href": "Books/Js4R/03 Introduction to Widgets.html#dt-package",
    "title": "03 Introduction to Widgets",
    "section": "DT package",
    "text": "DT package\nDT package 可以根据data.frame创建交互表格。\n\nDT::datatable(cars)\n\n\n\nInteractive table with DT\n\n\nDT 创建的表格也十分常见地用在shiny中。\n\nlibrary(DT)\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(8, DTOutput(\"myTable\")),\n    column(\n      4,\n      h4(\"Indices of selected rows\"),\n      verbatimTextOutput(\"selected\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$myTable &lt;- renderDT({\n    datatable(mtcars)\n  })\n\n  output$selected &lt;- renderPrint({\n    input$myTable_rows_selected\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/03 Introduction to Widgets.html#crosstalk",
    "href": "Books/Js4R/03 Introduction to Widgets.html#crosstalk",
    "title": "03 Introduction to Widgets",
    "section": "Crosstalk",
    "text": "Crosstalk\ncrosstalk包允许多个htmlwidgets之间进行数据交流。下面是一个共享数据的图标与散点图的示例。更多支持的widgets见：Crosstalk.\n\nlibrary(DT)\nlibrary(plotly)\nlibrary(crosstalk)\n\nsd &lt;- SharedData$new(iris[, c(\"Sepal.Length\", \"Sepal.Width\")])\n\nbscols(\n  device = \"lg\",\n  datatable(sd, width = \"100%\"),\n  plot_ly(sd, x = ~Sepal.Length, y = ~Sepal.Width)\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nDT and plotly with crosstalk",
    "crumbs": [
      "03 Introduction to Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html",
    "href": "Books/Js4R/04 Basics of Building Widgets.html",
    "title": "04 Basics of Building Widgets",
    "section": "",
    "text": "将某个JavaScript库整合到R中的第一步就是：学习这个JavaScript库。\n\n阅读库的简介，了解这个库的功能，输入，输出。\n阅读安装文档，了解这个库的依赖。\n以某个例子为切入点，深入了解将库整合到R中的难易程度。\n阅读API文档，准确把握API的使用。\n多使用库，实现对库API的精简与提升。",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#read-and-study",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#read-and-study",
    "title": "04 Basics of Building Widgets",
    "section": "",
    "text": "将某个JavaScript库整合到R中的第一步就是：学习这个JavaScript库。\n\n阅读库的简介，了解这个库的功能，输入，输出。\n阅读安装文档，了解这个库的依赖。\n以某个例子为切入点，深入了解将库整合到R中的难易程度。\n阅读API文档，准确把握API的使用。\n多使用库，实现对库API的精简与提升。",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#candidate-libraries",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#candidate-libraries",
    "title": "04 Basics of Building Widgets",
    "section": "Candidate Libraries",
    "text": "Candidate Libraries\n下面介绍一些htmlwidgets中常见的JavaScript库，并展示这些库在html中使用的共通点：\n\n引入js库\n声明一个展示图片的div。\njs获取图片的div位置，使用绘图结果替代div中的内容。\n\n\nPlotly.js\nplotly.js是plotlyR包的底层依赖库。其官方文档地址为：https://plotly.com/javascript 。下面是一个在html文本中简单使用的例子。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://cdn.plot.ly/plotly-3.0.1.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- div to hold visualisation --&gt;\n  &lt;div id=\"chart\" style=\"width:600px;height:400px;\"&gt;&lt;/div&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    el = document.getElementById('chart');\n    Plotly.newPlot(el, [{\n      x: [1, 2, 3, 4, 5],\n      y: [1, 2, 4, 8, 16]\n    }]\n    );\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n\n\nHighchart.js\nhighchart.js 是另外一个常见的绘图库，但不是全部免费，其官网为：https://www.highcharts.com 。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://code.highcharts.com/highcharts.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- div to hold visualisation --&gt;\n  &lt;div id=\"chart\" style=\"width:100%;height:400px;\"&gt;&lt;/div&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    var myChart = Highcharts.chart('chart', {\n        xAxis: {\n            categories: ['Apples', 'Bananas', 'Oranges']\n        },\n        series: [{\n            name: 'Jane',\n            data: [1, 0, 4]\n        }, {\n            name: 'John',\n            data: [5, 7, 3]\n        }]\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\nChart.js\nchart.js 以免费和便捷API出名，其官网为：https://www.chartjs.org 。\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\" xml:lang=\"\"&gt;\n&lt;head&gt;\n  &lt;!-- Import library --&gt;\n  &lt;script src=\"https://cdn.jsdelivr.net/npm/chart.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- canvas to hold visualisation --&gt;\n  &lt;canvas id=\"chart\"&gt;&lt;/canvas&gt;\n  &lt;!-- Script to create visualisation --&gt;\n  &lt;script&gt;\n    var el = document.getElementById('chart').getContext('2d');\n    var myChart = new Chart(el, {\n      type: 'bar',\n      data: {\n        labels: [\n          'Red', 'Blue', 'Yellow', 'Green',\n          'Purple', 'Orange'],\n        datasets: [{\n          label: '# of Votes',\n          data: [12, 19, 3, 5, 2, 3]\n        }]\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#plotly-chart",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#plotly-chart",
    "title": "04 Basics of Building Widgets",
    "section": "Plotly Chart",
    "text": "Plotly Chart\n\nPlotly = await require(\"@observablehq/plotly\")\n\n// 绘制图表\nPlotly.newPlot([{\n  x: [1, 2, 3, 4, 5],\n  y: [1, 2, 4, 8, 16]\n}]);"
  },
  {
    "objectID": "Books/Js4R/04 Basics of Building Widgets.html#how-it-works",
    "href": "Books/Js4R/04 Basics of Building Widgets.html#how-it-works",
    "title": "04 Basics of Building Widgets",
    "section": "How it works",
    "text": "How it works\n\n创建一个html文件。\n在html文件中引入Chart.js库。\n创建一个html元素（例如div），用于绘制图表。\nR将绘图数据转换为能被绘图模块使用的JSON格式，并嵌入到html文件中。\n上述所有元素能在Rmarkdown，Shiny或其他环境中运行。\n\n\n\n\n\n\nflowchart LR\n    subgraph i1[R environment]\n        A[Data]\n        B[Chart options]\n    end\n    subgraph i2[HTML]\n        C[JSON]\n        D[Dependencies]\n        E[JavaScript]\n        F[HTML element]\n    end\n    A --&gt;C\n    B --&gt;C\n    C --&gt;E\n    D --&gt;E\n    E --&gt;F\n    style i1 fill:#FFF\n    style i2 fill:#FFF",
    "crumbs": [
      "04 Basics of Building Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html",
    "href": "Books/Js4R/05 Your First Widget.html",
    "title": "05 Your First Widget",
    "section": "",
    "text": "通过R包的形式创建widget可以使事情变得简单一些，下面我们以一个playgroundR包例，创建一个widget。\n首先使用usethis::create_package()创建一个R包。\nusethis::create_package(\"playground\")\n使用htmlwidgets::scaffoldWidget()函数自动创建一个widget脚手架——“play”：生成play.R，play.js，play.yaml三个文件。你可以在一个包中使用该函数创建多个widget。\nplay.R脚本中定义了三个函数：\n\nplay()：widget的核心API。\nrender*()：在shiny服务器中处理widget的函数。\n*output()：在shinyUI界面处理widget的函数。\n\n.js脚本包含生成可视化结果的JavaScript函数。\nhtmlwidgets::scaffoldWidget(\"play\")\n生成R包说明文档并加载函数，此时已经可以初步使用“play”widget了（虽然此时只能显示文本信息）。\ndevtools::document()\ndevtools::load_all()\nplay(message = \"This is a widget!\")\n\n在Rstudio中，你可以点击“Viewer”中的，在浏览器中打开生成的网页，然后使用浏览器调试工具进行调试，十分方便后续开发。同样地，在vscode中，你可以使用htmlwidgets::saveWidget()函数将widget保存为HTML文件，然后在浏览器中进行调试。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#the-scaffold",
    "href": "Books/Js4R/05 Your First Widget.html#the-scaffold",
    "title": "05 Your First Widget",
    "section": "",
    "text": "通过R包的形式创建widget可以使事情变得简单一些，下面我们以一个playgroundR包例，创建一个widget。\n首先使用usethis::create_package()创建一个R包。\nusethis::create_package(\"playground\")\n使用htmlwidgets::scaffoldWidget()函数自动创建一个widget脚手架——“play”：生成play.R，play.js，play.yaml三个文件。你可以在一个包中使用该函数创建多个widget。\nplay.R脚本中定义了三个函数：\n\nplay()：widget的核心API。\nrender*()：在shiny服务器中处理widget的函数。\n*output()：在shinyUI界面处理widget的函数。\n\n.js脚本包含生成可视化结果的JavaScript函数。\nhtmlwidgets::scaffoldWidget(\"play\")\n生成R包说明文档并加载函数，此时已经可以初步使用“play”widget了（虽然此时只能显示文本信息）。\ndevtools::document()\ndevtools::load_all()\nplay(message = \"This is a widget!\")\n\n在Rstudio中，你可以点击“Viewer”中的，在浏览器中打开生成的网页，然后使用浏览器调试工具进行调试，十分方便后续开发。同样地，在vscode中，你可以使用htmlwidgets::saveWidget()函数将widget保存为HTML文件，然后在浏览器中进行调试。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#the-html-output",
    "href": "Books/Js4R/05 Your First Widget.html#the-html-output",
    "title": "05 Your First Widget",
    "section": "The HTML Output",
    "text": "The HTML Output\n下面是上面play(\"This is a widget!\")生成的html文件中body标签的内容。生成内容的逻辑同上一章的内容。\n&lt;div id=\"htmlwidget_container\"&gt;\n  &lt;div\n    id=\"htmlwidget-c21cca0e76e520b46fc7\"\n    style=\"width:960px;height:500px;\"\n    class=\"play html-widget\"&gt;\n    This is a widget!\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script\n  type=\"application/json\"\n  data-for=\"htmlwidget-c21cca0e76e520b46fc7\"&gt;\n  {\"x\":{\"message\":\"This is a widget!\"},\"evals\":[],\"jsHooks\":[]}\n&lt;/script&gt;\n上面的html源码中，div元素由play()函数创建，它的class属性与widget（play）相关，id属性由elementId参数指定，如果没有指定，则生成随机id。script中JSON数据的x与play()函数中的x参数一致。\n# specify the id\nplay(\"This is another widget\", elementId = \"myViz\")\n&lt;!-- div bears id specified in R --&gt;\n&lt;div id=\"myViz\"\n  style=\"width:960px;height:500px;\"\n  class=\"play html-widget\"&gt;\n  This is another widget\n&lt;/div&gt;\n仔细观察script，会发现它的data-for属性与elementId相关。\n&lt;script type=\"application/json\"\n  data-for=\"myViz\"&gt;\n  {\"x\":{\"message\":\"This is a widget!\"},\"evals\":[],\"jsHooks\":[]}\n&lt;/script&gt;",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/05 Your First Widget.html#javascript-files",
    "href": "Books/Js4R/05 Your First Widget.html#javascript-files",
    "title": "05 Your First Widget",
    "section": "JavaScript Files",
    "text": "JavaScript Files\nhtmlwidgets::scaffoldWidget(\"play\")自动生成的play.js文件包含以下内容：\nHTMLWidgets.widget({\n\n  name: 'play',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // TODO: code to render the widget, e.g.\n        el.innerText = x.message;\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n结合play.R文件中的htmlwidgets::createWidget()内容，我们可以大致将htmlwidgets在创建和渲染的过程描述如下：\n\n\n\n\n\nflowchart LR\n  subgraph i1[R]\n    A[\"play(id)\"]\n  end\n  subgraph i2[HTML]\n    B[\"&lt;scipt data-for=id&gt;\"]\n    C[\"dependencies(play.js)\"]\n    D[JavaScript]\n    E[\"&lt;div class=play id=id&gt;\"]\n    B--&gt;|import|D\n    C--&gt;|use|D\n    D--&gt;|Generate viz|E\n  end\n  A--&gt;|id|B\n  A--&gt;|id and class|E\n  style i1 fill:#FFF\n  style i2 fill:#FFF\n\n\n\n\n\n\nfactory函数的返回值是两个函数resize和renderValue。前者用来动态调整结果框的大小，后者用来生成结果框，我们先关注renderValue函数。该函数使用参数x中的message值来替代html中的元素el.innerText，其中x.message是JSON格式的提取元素方式，类似R中list的x$message。\n你可以在play.js中添加如下代码，并重新加载函数，重新生成网页，然后使用浏览器调试工具查看结果。\n// el.innerText = x.message; 后续添加\nconsole.log(x);\nel.innerText = x.message;\n\n使用相同的方法，我们可以查看一下el对象的具体信息。\nconsole.log(el);\n\n可以发现，el对象就是play()函数同时创建的div元素。如果你熟悉JavaScript，你可以使用document.getElementById来获取el对象，同时修改元素的位置，颜色，大小等。\n// print the id of the element\nconsole.log(el.id);\nel.innerText = x.message;\n\n在play.js中使用的innerText只能替换文本，而innerHTML则可以替换任何HTML元素。将el.innerText = x.message;修改为el.innerHTML = x.message;，重新加载函数后运行play(\"&lt;h1&gt;Using HTML!&lt;/h1&gt;\")。生成下图：\n\n上面的例子使得play()函数更加灵活，但是使用\"&lt;h1&gt;Using HTML!&lt;/h1&gt;\"未免有些麻烦。好在shiny和htmltools提供了一些工具，使得创建HTML元素更加容易。\n\nhtml &lt;- shiny::h1(\"HTML tag\")\n\nclass(html)\n#&gt; [1] \"shiny.tag\"\n\n# returns string\nas.character(html)\n#&gt; [1] \"&lt;h1&gt;HTML tag&lt;/h1&gt;\"\n\n修改play()函数中对message的处理:\n# forward options using x\nx = list(\n  message = as.character(message)\n)\n重新加载函数后，就可以直接使用shiny或htmltools创建的HTML元素作为message了。\nplay(\n  shiny::h2(\"Chocolate is a colour\", style = \"color:chocolate;\")\n)\n\n综上，play()函数的内容会通过对象x传递到html中，并被JavaScript解析，然后替换同时由play()生成的div中的内容。",
    "crumbs": [
      "05 Your First Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html",
    "href": "Books/Js4R/06 A Realistic Widget.html",
    "title": "06 A Realistic Widget",
    "section": "",
    "text": "本章我们创建一个名为peity的R包，它以peity.js为基础，创建内联图（类似小图标的东西）。\n具体工作原理是：先加载JavaScript库，然后$(\"#bar\").peity(\"bar\")将span标签中的数据转换成图表。",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#示例图表",
    "href": "Books/Js4R/06 A Realistic Widget.html#示例图表",
    "title": "06 A Realistic Widget",
    "section": "示例图表",
    "text": "示例图表\n以下是一个使用 peity 创建的简单条形图：\n\n5,3,9,6,5,9,7,3,5,2"
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#dependencies",
    "href": "Books/Js4R/06 A Realistic Widget.html#dependencies",
    "title": "06 A Realistic Widget",
    "section": "Dependencies",
    "text": "Dependencies\n创建好包和scaffold后，我们需要为包添加JavaScript依赖库。分别为上述两个依赖库peity.js和jQuery创建单独目录，并放置源文件，这样可以使包变得更加鲁棒。\ndir.create(\"./inst/htmlwidgets/jquery\")\ndir.create(\"./inst/htmlwidgets/peity\")\n\npeity &lt;- paste0(\n  \"https://raw.githubusercontent.com/benpickles/\",\n  \"peity/master/jquery.peity.min.js\"\n)\njquery &lt;- paste0(\n  \"https://code.jquery.com/jquery-3.5.1.min.js\"\n)\n\ndownload.file(\n  jquery, \"./inst/htmlwidgets/jquery/jquery.min.js\"\n)\ndownload.file(\n  peity, \"./inst/htmlwidgets/peity/jquery.peity.min.js\"\n)\n完成后，R包目录下的结构大致如下：\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   └── peity.R\n└── inst\n    └── htmlwidgets\n        ├── jquery\n        │   └── jquery.min.js\n        ├── peity\n        │   └── jquery.peity.min.js\n        ├── peity.js\n        └── peity.yaml\n配置依赖的文件为inst/htmlwidgets/peity.yaml文件，它的最开始几行是一个模板。\n# (uncomment to add a dependency)\n# dependencies:\n#  - name:\n#    version:\n#    src:\n#    script:\n#    stylesheet:\n正确添加依赖项：依赖性的顺序很重要，因为peity.js依赖jquery.js，所以它最后被添加。scr自动指向R包目录中的inst/文件夹。\ndependencies:\n  - name: jQuery\n    version: 3.5.1\n    src: htmlwidgets/jquery\n    script: jquery.min.js\n  - name: peity\n    version: 3.3.0\n    src: htmlwidgets/peity\n    script: jquery.peity.min.js\n加载peity包，使用peity(\"test\")函数生成测试网页，点击Rstudio中Viewer处的，使用浏览器工具，你可以看到在网页&lt;head&gt;处加载了jquery.min.js和jquery.peity.min.js\ndevtools::load_all()\nsystem.file(\"htmlwidgets/peity\", package = \"peity\")\n#&gt; \"/home/me/packages/peity/inst/htmlwidgets/peity\"\npeity(\"test\")",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#implementation",
    "href": "Books/Js4R/06 A Realistic Widget.html#implementation",
    "title": "06 A Realistic Widget",
    "section": "Implementation",
    "text": "Implementation\npeity.js的使用方法相对简单：piety函数应用到id = 'elementId'块，函数第一个参数使绘图类型，第二个参数是可选的JSON参数。\n$(\"#elementId\").peity(\"bar\", {\n  fill: [\"red\", \"green\", \"blue\"]\n})\npiety函数使用的数据不是由参数传入，而是由块提供：\n&lt;span id=\"elementId\"&gt;5,3,9,6&lt;/span&gt;\n那么，要想实现R调用JavaScript，我们需要R：\n\n创建一个有数据的块，传递块给peity函数。\n传递peity函数的参数。\n\n上一章节中，我们讲到playground包会自动创建一个块，并传递message给块，最终显示在网页上；peity包同样：\npeity(c(1,5,6,2))\n&lt;div\n  id=\"htmlwidget-495cf47d1a2a4a56c851\"\n  style=\"width:960px;height:500px;\"\n  class=\"play html-widget\"&gt;\n  1,5,6,2\n&lt;/div&gt;\n与message相同的传递方式，我们可以将数据和参数通过x对象进行传递。更新./R/peity.R文件中的函数，如下所示：\npeity &lt;- function(data, type = c(\"bar\", \"line\", \"pie\", \"donut\"),\n  ..., width = NULL, height = NULL, elementId = NULL) {\n\n  type &lt;- match.arg(type)\n\n  # forward options using x\n  x = list(\n    data = data,\n    type = type,\n    options = list(...)\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'peity',\n    x,\n    width = width,\n    height = height,\n    package = 'peity',\n    elementId = elementId\n  )\n}\n与message相同的处理方式，在./inst/htmlwidgets/peity.js文件中，添加对传入的x对象处理，运行js中的peity函数。\nrenderValue: function(x) {\n\n  // insert data\n  el.innerText = x.data;\n\n  // run peity\n  // $(\"#\" + el.id).peity(x.type, x.options)\n  $(el).peity(x.type, x.options)\n\n}\n重新加载函数，运行如下代码会显示\n\n  5,3,9,6,7\n\n\n  2, 1.8198638, 0.9582295, 0.2660590, 1.1532798\n\n\n  1/4\n\n\n  3,5\n\n\n\nlibrary(htmltools)\n\nbrowsable(\n  tagList(\n    peity(runif(5)),\n    peity(runif(5), type = \"line\"),\n    peity(\"1/4\", type = \"pie\", fill = c(\"#c6d9fd\", \"#4d89f9\")),\n    peity(c(3,5), type = \"donut\")\n  )\n)",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/06 A Realistic Widget.html#html-element",
    "href": "Books/Js4R/06 A Realistic Widget.html#html-element",
    "title": "06 A Realistic Widget",
    "section": "HTML Element",
    "text": "HTML Element\npiety.js生成的图像用来插入到某行中，通常搭配&lt;span&gt;标签。如果你检查上例中html源码，会发现生成的图是被&lt;div&gt;标签包裹。\n\n为了实现被&lt;span&gt;标签包裹，我们需要在./R/piety.R中定义一个函数，将&lt;div&gt;标签替换为&lt;span&gt;标签，示例如下：\npeity_html &lt;- function(...){\n  htmltools::tags$span(...)\n}\n你可以重新加载函数，再次检查html源码中使用的标签。\n函数名peity_html是一种固定的格式——widgetName_html。该函数会被htmlwidgets自动搜索，如果有就使用函数中的标签，如果没有就使用默认的&lt;div&gt;。参数...为固定参数，用来传递id,class,style等不确定参数。你也可以写出如下具有固定参数的格式。\nmyWidget_html &lt;- function(..., class){\n  htmltools::tags$div(..., class = c(class, \"my-class\"))\n}\n重新运行下面的代码会生成\nWe can now 5,3,9,6,7 use peity 2, 1.8198638, 0.9582295, 0.2660590, 1.1532798 inline with text! 4,2\n\nbrowsable(\n  tagList(\n    p(\n      \"We can now\", peity(runif(5)),\n      \"use peity\", peity(runif(5), type = \"line\"),\n      \"inline with text!\",\n      peity(c(4,2), type = \"donut\")\n    )\n  )\n)",
    "crumbs": [
      "06 A Realistic Widget"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html",
    "href": "Books/Js4R/07 The Full Monty.html",
    "title": "07 The Full Monty",
    "section": "",
    "text": "本章以gio.js库为基础，学习输入数据的处理方式。gio.js用来在三维地球图上，通过曲线绘制国家之间的联系。下面是该库的一个简单示例：",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#creating-package",
    "href": "Books/Js4R/07 The Full Monty.html#creating-package",
    "title": "07 The Full Monty",
    "section": "Creating Package",
    "text": "Creating Package\n同上一章一样：\n\n首先创建gioR包及scaffold：\n\nusethis::create_package(\"gio\")\nhtmlwidgets::scaffoldWidget(\"gio\")\n\n然后下载依赖JS库，修改inst/htmlwidgets/gio.yaml文件\n\n# create directories for JS dependencies\ndir.create(\"./inst/htmlwidgets/three\", recursive = TRUE)\ndir.create(\"./inst/htmlwidgets/gio\", recursive = TRUE)\n\n# download JS dependencies\nthree &lt;- paste0(\n  \"https://cdnjs.cloudflare.com/ajax/\",\n  \"libs/three.js/110/three.min.js\"\n)\ngio &lt;- paste0(\n  \"https://raw.githubusercontent.com/\",\n  \"syt123450/giojs/master/build/gio.min.js\"\n)\n\ndownload.file(three, \"./inst/htmlwidgets/three/three.min.js\")\ndownload.file(gio, \"./inst/htmlwidgets/gio/gio.min.js\")\ndependencies:\n  - name: three\n    version: 110\n    src: htmlwidgets/three\n    script: three.min.js\n  - name: gio\n    version: 2.0\n    src: htmlwidgets/gio\n    script: gio.min.js\n\n修改int/htmlwidgets/gio.js文件中的函数：因为gio.js直接使用widget创建的el对象，所以我们无需使用var container = document.getElementById(\"globe\")来获取el对象，而是直接使用el对象；同时需要的数据由x对象传入。\n\n// gio.js\nHTMLWidgets.widget({\n\n  name: 'gio',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // var container = document.getElementById(\"globe\");\n        var controller = new GIO.Controller(el);\n        controller.addData(x.data);\n        controller.init();\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n\n最后修改R/gio.R文件：上面的js需要输入对象x要有data属性，所以这里需要修改gio函数的参数和x的数据结构。\n\n# 注意：将message修改为data\ngio &lt;- function(data, width = NULL, height = NULL, elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n最后运行devtools::document();devtools::load_all()加载函数，使用gio(data)创建widget。",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#working-with-data",
    "href": "Books/Js4R/07 The Full Monty.html#working-with-data",
    "title": "07 The Full Monty",
    "section": "Working with Data",
    "text": "Working with Data\n现在只需要我们创建gio.js需要的json数据，即可创建gio.js的widget。阅读jio.js的文档，其要求的数据结构为：e——exporting country, i——importing country, v——value。\n[\n  {\n    \"e\": \"CN\",\n    \"i\": \"US\",\n    \"v\": 3300000\n  },\n  {\n    \"e\": \"CN\",\n    \"i\": \"RU\",\n    \"v\": 10000\n  }\n]\n我们使用R读取该JSON数据，会发现数据结构转为data.frame。\n\n# data.frame to test\narcs &lt;- jsonlite::fromJSON(\n  '[\n    {\n      \"e\": \"CN\",\n      \"i\": \"US\",\n      \"v\": 3300000\n    },\n    {\n      \"e\": \"CN\",\n      \"i\": \"RU\",\n      \"v\": 10000\n    }\n  ]'\n)\n\nprint(arcs)\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n\n当我们直接将arcs传入gio函数时，会发现只有一个空白的widget。使用console.log或查看HTML源码，会发现传入的数据结构和预期的不符。\n{\n  \"x\":{\n    \"data\":{\n      \"e\":[\"CN\",\"CN\"],\n      \"i\":[\"US\",\"RU\"],\n      \"v\":[3300000,10000]\n    }\n  },\n  \"evals\":[],\n  \"jsHooks\":[]\n}\n\n出现上述情况的原因是：row-wise的JSON被jsonlite::fromJSON自动转换为了dataframe，而htmlwidgets的createWidget函数会自动将dataframe转为column-wise的JSON，从而导致数据结构不符。\n\n# column-wise\njsonlite::toJSON(arcs, dataframe = \"columns\")\n#&gt; {\"e\":[\"CN\",\"CN\"],\"i\":[\"US\",\"RU\"],\"v\":[3300000,10000]}\n# row-wise\njsonlite::toJSON(arcs, dataframe = \"rows\")\n#&gt; [{\"e\":\"CN\",\"i\":\"US\",\"v\":3300000},{\"e\":\"CN\",\"i\":\"RU\",\"v\":10000}]",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#transforming-data",
    "href": "Books/Js4R/07 The Full Monty.html#transforming-data",
    "title": "07 The Full Monty",
    "section": "Transforming Data",
    "text": "Transforming Data\n下面介绍一些确保dataframe被row-wise的方法。\n\nUsing JavaScript\nhtmlwidgets JavaScript 库提供了dataframeToD3函数，将column-wise的JSON转为row-wise的JSON。\n// gio.js\nrenderValue: function(x) {\n\n  // long to wide\n  x.data = HTMLWidgets.dataframeToD3(x.data);\n\n  var controller = new GIO.Controller(el);\n  controller.addData(x.data);\n  controller.init();\n\n}\n\n\nModify Serialiser\n正如前面讲到的那样，我们可以设置htmlwidgets的createWidget函数自动将dataframe转为row-wise的JSON。\n下面是createWidget函数的底层逻辑，可以看到只要修改dataframe参数为\"rows\"即可。\nfunction (x, ..., dataframe = \"columns\", null = \"null\",\nna = \"null\", auto_unbox = TRUE, use_signif = TRUE,\n  digits = getOption(\"shiny.json.digits\", 16), force = TRUE,\n  POSIXt = \"ISO8601\", UTC = TRUE, rownames = FALSE,\n  keep_vec_names = TRUE, strict_atomic = TRUE)\n{\n  if (strict_atomic)\n      x &lt;- I(x)\n  jsonlite::toJSON(x, dataframe = dataframe, null = null, na = na,\n    auto_unbox = auto_unbox, digits = digits, force = force,\n    use_signif = use_signif, POSIXt = POSIXt, UTC = UTC,\n    rownames = rownames, keep_vec_names = keep_vec_names,\n    json_verbatim = TRUE, ...)\n}\nhtmlwidgets巧妙地利用了属性，可以将rows设置为x对象的TOJSON_ARGS属性，从而实现row-wise处理。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # serialise data.frames to wide (not long as default)\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n\nReplace Serialiser\n也可以为x对象添加TOJSON_FUNC属性值，直接替换serialiser函数。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # forward options using x\n  x = list(\n    data = data\n  )\n\n  # replace serialiser\n  attr(x, 'TOJSON_FUNC') &lt;- gio_serialiser\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId\n  )\n}\n\n# serialiser\ngio_serialiser &lt;- function(x){\n  jsonify::to_json(x, unbox = TRUE)\n}\n\n\nModify the Data\n我们也可以直接修改data数据类型。\nx = list(\n  data = apply(data, 1, as.list)\n)\n\n\nPros and Cons\n上述每种方法都有其优缺点。最好的方法可能是仅在需要的地方修改默认序列化器（Modify Serialiser），这是本书其余部分使用的方法。完全替换序列化器（Replace Serialiser）应该是不必要的，只有在你非常熟悉序列化并真正看到需要它时才这样做。此外，HTMLWidgets 的序列化器扩展了 jsonlite, 允许转换 JavaScript 代码，这将在后面派上用场。在 JavaScript 中转换 data （Using JavaScript）有一个缺点，HTMLWidgets.dataframeToD3 不能应用于整个 x 对象，它只会作用于包含column-wise data (x.data) 的子集，这往往会导致代码笨拙，因为在不同地方使用该函数。",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/07 The Full Monty.html#on-print-method",
    "href": "Books/Js4R/07 The Full Monty.html#on-print-method",
    "title": "07 The Full Monty",
    "section": "On Print Method",
    "text": "On Print Method\ngio.js提供了一些themes，我们可以为其x对象添加style`属性。\n// gio.js\nrenderValue: function(x) {\n\n  var controller = new GIO.Controller(el);\n  controller.addData(x.data);\n\n  controller.setStyle(x.style); // set style\n\n  controller.init();\n\n}\n此时，我们除了前面讲到的修改R/gio.R文件中函数的data对象，还可以直接为x对象添加style。使用print()我们可以清楚地看到数据结构。\n\ng &lt;- gio(arcs) # nothing renders\ng # visualisation renders\n\n\n\n\n\n\nprint(g$x)\n#&gt; $data\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n#&gt; \n#&gt; attr(,\"TOJSON_ARGS\")\n#&gt; attr(,\"TOJSON_ARGS\")$dataframe\n#&gt; [1] \"rows\"\n\n在R/gio.R文件中，创建添加属性的函数：\n#' @export\ngio_style &lt;- function(g, style = \"magic\"){\n  g$x$style &lt;- style\n  return(g)\n}\ng1 &lt;- gio(arcs)\ng2 &lt;- gio_style(g1, \"juicyCake\")\n\ng2\nhtmlwidgets系列包也可以被magrittr包支持，使用usethis::use_pipe()可以方便的实现管道符操作。\n\nlibrary(magrittr)\n\ngio(arcs) %&gt;%\n  gio_style(\"juicyCake\")",
    "crumbs": [
      "07 The Full Monty"
    ]
  },
  {
    "objectID": "Books/Js4R/00 Preface.html#总结",
    "href": "Books/Js4R/00 Preface.html#总结",
    "title": "00 Preface",
    "section": "总结",
    "text": "总结\n\nmyWidget()函数中包含的htmlwidgets::createWidget会：\n\n自动创建element，默认是div，可以通过myWidget_html()函数进行修改。\n解析x对象的属性，如TOJSON_ARGS, TOJSON_FUNC，配置数据转换方式。\n\nhtmlwidgets::createWidget创建的x对象，可以直接在外部进行赋值。如gio$x$style &lt;- \"juicyCake\"。\nusethis::use_pipe()可以实现管道符操作。\n实现crosstalk支持的步骤：\n\nR脚本改造为能接收共享数据对象，获取数据的data，group，key信息，添加crosstalk依赖库。\n根据JS依赖库获取key信息，然后JS脚本使用sel_handle.set发送key信息\nJS脚本使用sel_handle.on监听事件发送改变后，获取key信息。",
    "crumbs": [
      "00 Preface"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html",
    "href": "Books/Js4R/08 Advanced Topics.html",
    "title": "08 Advanced Topics",
    "section": "",
    "text": "本章在gio包的基础上，主要讨论下面几点：",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#shared-variables",
    "href": "Books/Js4R/08 Advanced Topics.html#shared-variables",
    "title": "08 Advanced Topics",
    "section": "Shared Variables",
    "text": "Shared Variables\n在此之前，需要先了解如何共享变量。以gio包为例，将controller变量定义在’factory函数内，renderValue函数外时，controller变量就可以被定义在factory中的函数访问，例如resize`函数。\nHTMLWidgets.widget({\n\n  name: 'gio',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n    var controller;\n\n    return {\n\n      renderValue: function(x) {\n\n        controller = new GIO.Controller(el); // declared outside\n\n        // add data\n        controller.addData(x.data);\n\n        // define style\n        controller.setStyle(x.style);\n\n        // render\n        controller.init();\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#sizing",
    "href": "Books/Js4R/08 Advanced Topics.html#sizing",
    "title": "08 Advanced Topics",
    "section": "Sizing",
    "text": "Sizing\nwidget的大小有两种调控方式：一种是绝对大小——px，另一种是相对（窗口）占比——x%，为了适配不同设备，通常宽度使用百分比设置，高度自适应。\ngio包中的gio()函数有width和height参数，分别调控widget的宽度和高度，其中width参数默认为400px，高度自适应。\narcs &lt;- jsonlite::fromJSON(\n  '[\n    {\n      \"e\": \"CN\",\n      \"i\": \"US\",\n      \"v\": 3300000\n    },\n    {\n      \"e\": \"CN\",\n      \"i\": \"RU\",\n      \"v\": 10000\n    }\n  ]'\n)\n\ngio(arcs)\n\n你可以试着改变宽度：\ngio(arcs, width = 500) # 500 pixels wide\ngio(arcs, width = \"100%\") # fits width\n这种调控方式适用于使用者，下面是针对开发者设置默认大小的方法。\n\nSizing Policy\n在htmlwidgets::createWidget()函数中，添加sizingPolicy参数，设置widget的默认大小和填充；参数值由htmlwidgets::sizingPolicy()函数配置。不同的配置可以适配不同的使用环境，如：RStudio viewer，Web browser，R markdown等。\n# create widget\nhtmlwidgets::createWidget(\n  name = 'gio',\n  x,\n  width = width,\n  height = height,\n  package = 'gio',\n  elementId = elementId,\n  sizingPolicy = htmlwidgets::sizingPolicy(\n    defaultWidth = \"100%\",\n    padding = 0,\n    browser.fill = TRUE\n  )\n)\n\n\n\nResizing\n前面我们讲过gio.js中的renderValue函数，当controller变量共享后，我们可以在resize函数中，对widget的大小进行重新渲染。gio.js由于底层自动调整widget大小，所以调整大小的函数resizeUpdate没有参数。\n...\nresize: function(width, height) {\n  controller.resizeUpdate();\n}\n...\n\n此处控制widget大小的函数由JS库决定，例如gio.js库是resizeUpdate，plotly.js库是relayout，highcharts.js库是setSize，charts.js库是resize。\n// plotly.js\nPlotly.relayout('chartid', {width: width, height: height});\n// highcharts.js\nchart.setSize(width, height);\n// charts.js\nchart.resize();",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#pre-render-hooks-and-security",
    "href": "Books/Js4R/08 Advanced Topics.html#pre-render-hooks-and-security",
    "title": "08 Advanced Topics",
    "section": "Pre Render Hooks and Security",
    "text": "Pre Render Hooks and Security\nhtmlwidgets::createWidget()函数通过参数preRenderHook接受一个函数，用来在生成widget前执行预处理。该函数接受一个完整的widget对象，输出一个修改过后的widget对象。这种操作不是很常见，但有时十分有用。\n例如，gio()函数的输入数据除了必要的e,v,i列外，如果存在其他列导致无法正确生成widget（实际无影响）时，我们需要确保输入数据的格式正确。\n# add a variable that should not be shared\narcs$secret_id &lt;- 1:2\n定义一个render_gio()函数，对输入数据进行格式控制。\n# preRenderHook function\nrender_gio &lt;- function(g){\n  # only keep relevant variables\n  g$x$data &lt;- g$x$data[,c(\"e\", \"v\", \"i\")]\n  return(g)\n}\n\n# create widget\nhtmlwidgets::createWidget(\n  name = 'gio',\n  x,\n  width = width,\n  height = height,\n  package = 'gio',\n  elementId = elementId,\n  sizingPolicy = htmlwidgets::sizingPolicy(\n    defaultWidth = \"100%\",\n    padding = 0,\n    browser.fill = TRUE\n  ),\n  preRenderHook = render_gio # pass renderer\n)",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#javascript-code",
    "href": "Books/Js4R/08 Advanced Topics.html#javascript-code",
    "title": "08 Advanced Topics",
    "section": "JavaScript Code",
    "text": "JavaScript Code\nJavaScript 代码无法通过JSON数据进行传递，需要特殊函数htmlwidgets::JS()进行转换。该函数为JavaScript代码字符串添加JS_EVAL属性，使其在被浏览器评估时可以被视作JavaScript代码。\n\n# serialised as string\njsonlite::toJSON(\"var x = 3;\")\n#&gt; [\"var x = 3;\"]\nhtmlwidgets::JS(\"var x = 3;\")\n#&gt; [1] \"var x = 3;\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"JS_EVAL\"",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#prepend-and-append-content",
    "href": "Books/Js4R/08 Advanced Topics.html#prepend-and-append-content",
    "title": "08 Advanced Topics",
    "section": "Prepend and Append Content",
    "text": "Prepend and Append Content\n使用htmlwidgets::prependContent()和htmlwidgets::appendContent()函数，可以在widget的前面或结尾添加额外的HTML内容（shiny，htmltools tags，a list of those）。注意：这两个函数在shiny中不起作用。\n#' @export\ngio_title &lt;- function(g, title){\n  title &lt;- htmltools::h3(title)\n  htmlwidgets::prependContent(g, title)\n}\ngio(arcs) %&gt;%\n  gio_title(\"Gio.js htmlwidget!\")",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#dependencies",
    "href": "Books/Js4R/08 Advanced Topics.html#dependencies",
    "title": "08 Advanced Topics",
    "section": "Dependencies",
    "text": "Dependencies\n前面讲到在inst/htmlwidgets/gio.yaml中添加JS库依赖，但这种方法适合添加通用型库，如果某些库仅是某些功能需要，则可以使用htmltools::htmlDependency()函数为widget对象单独添加依赖（dependencies）。如果全部使用第一种方法，会导致widget特别大，影响widget的加载速度，某些依赖库甚至可以只将某些使用的函数单独打包，减少加载时的大小。\n下面我们使用JavaScript性能监控器stats.js库，为gio包添加展示诸如渲染帧率 (FPS) 或渲染可视化所需的毫秒数等信息。\ndir.create(\"htmlwidgets/stats\")\nurl &lt;- paste0(\n  \"https://raw.githubusercontent.com/mrdoob/\",\n  \"stats.js/master/build/stats.min.js\"\n)\ndownload.file(url, destfile = \"htmlwidgets/stats/stats.min.js\")\ngio.js对stats.js的使用方法见这里。\n// enable stats\ncontroller.enableStats();\n参数dependencies由htmlwidgets::createWidget()生成，可以在函数内为widget添加该参数值，也可以直接在外部添加。\n\n通过system.file()获取stats.js的文件路径。\nhtmltools::htmlDependency()创建依赖项。\n将依赖项追加到widget对象的dependencies参数中。\n为x对象添加启动项。\n返回widget对象。\n\n#' @export\ngio_stats &lt;- function(g){\n\n  # create dependency\n  path &lt;- system.file(\"htmlwidgets/stats\", package = \"gio\")\n  dep &lt;- htmltools::htmlDependency(\n    name = \"stats\",\n    version = \"17\",\n    src = c(file = path),\n    script = \"stats.min.js\"\n  )\n\n  # append dependency to gio.js\n  g$dependencies &lt;- append(g$dependencies, list(dep))\n\n  # add stats variable\n  g$x$stats &lt;- TRUE\n\n  return(g)\n}\n同时修改inst/htmlwidgets/gio.js，将启动stat的代码添加到controller.init()之前。\n// gio.js\nif(x.stats)\n  controller.enableStats();\n\ncontroller.init();\n允许下面代码，可以看到左上角的实时信息。\n\n# create gio object\narcs %&gt;%\n  gio() %&gt;%\n  gio_stats()\n\n\n\n\n\n可以将上面两种方法类比于R包DESCRIPTION文件中的Imports和Suggests。",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#compatibility",
    "href": "Books/Js4R/08 Advanced Topics.html#compatibility",
    "title": "08 Advanced Topics",
    "section": "Compatibility",
    "text": "Compatibility\nhtmlwidgets::getDependency()函数可以提取widget R包中的依赖项，方便不同widget之间进行兼容，避免冲突。提取到的依赖项中第一个是htmlwidgets，最后一个是gio。\n\n# get dependencies of the gio package\nhtmlwidgets::getDependency(\"gio\")\n#&gt; [[1]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"htmlwidgets\"\n#&gt;  $ version   : chr \"1.6.4\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"www\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"htmlwidgets.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"htmlwidgets\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[2]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"three\"\n#&gt;  $ version   : chr \"110\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets/three\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"three.min.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[3]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"gio\"\n#&gt;  $ version   : chr \"2\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets/gio\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"gio.min.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi TRUE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"\n#&gt; \n#&gt; [[4]]\n#&gt; List of 10\n#&gt;  $ name      : chr \"gio-binding\"\n#&gt;  $ version   : chr \"0.1.0\"\n#&gt;  $ src       :List of 1\n#&gt;   ..$ file: chr \"htmlwidgets\"\n#&gt;  $ meta      : NULL\n#&gt;  $ script    : chr \"gio.js\"\n#&gt;  $ stylesheet: NULL\n#&gt;  $ head      : NULL\n#&gt;  $ attachment: NULL\n#&gt;  $ package   : chr \"gio\"\n#&gt;  $ all_files : logi FALSE\n#&gt;  - attr(*, \"class\")= chr \"html_dependency\"",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#unit-tests",
    "href": "Books/Js4R/08 Advanced Topics.html#unit-tests",
    "title": "08 Advanced Topics",
    "section": "Unit Tests",
    "text": "Unit Tests\n使用devtools::install()安装好gio包后，可以使用testthat包进行单元测试。\nlibrary(gio)\nlibrary(testthat)\n\ntest_that(\"gio has correct data\", {\n  g &lt;- gio(arcs)\n\n  # internally stored as data.frame\n  expect_is(g$x$data, \"data.frame\")\n\n  # gio does not work without data\n  expect_error(gio())\n})",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/08 Advanced Topics.html#performances",
    "href": "Books/Js4R/08 Advanced Topics.html#performances",
    "title": "08 Advanced Topics",
    "section": "Performances",
    "text": "Performances\n使用widget R包时，数据的传输过程为：\n\n加载到R中\nR将数据转换为JOSN格式\nJSON数据嵌入到HTML中\nJS解析JSON数据\n\n当数据较小时，不会影响浏览器的响应速度，但是当数据较大时，会拖慢浏览器的响应速度。可以使用额外的技术加快数据加载过程。例如下面的AJAX技术。\n# this would placed in the shiny UI\nload_json_from_ui &lt;- function(path_to_json){\n  script &lt;- paste0(\"\n    $.ajax({\n        url: '\", path_to_json, \"',\n        dataType: 'json',\n        async: true,\n        success: function(data){\n          console.log(data);\n          window.globalData = data;\n        }\n      });\"\n    )\n  shiny::tags$script(\n    script\n  )\n}",
    "crumbs": [
      "08 Advanced Topics"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html",
    "href": "Books/Js4R/09 Linking Widgets.html",
    "title": "09 Linking Widgets",
    "section": "",
    "text": "crosstalk包可以实现widget包之间数据共享，从而进行联动。例如选择图中的点，表格自动过滤出选择的点的相关数据。更多关于crosstalk见官网。",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-examples",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-examples",
    "title": "09 Linking Widgets",
    "section": "Crosstalk Examples",
    "text": "Crosstalk Examples\nR包plotly和DT支持crosstalk，可以创建一个共享数据的散点图与表格，表格中的数据根据选择的点自动过滤显示。共享数据由crosstalk::SharedData()创建，是一个R6类对象。下面的bscols()函数用来布局排列两个widget。\n\nlibrary(DT)\nlibrary(plotly)\nlibrary(crosstalk)\n\nshared &lt;- SharedData$new(cars)\n\nbscols(\n  plot_ly(shared, x = ~speed, y = ~dist),\n  datatable(shared, width = \"100%\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在shiny中使用crosstalk也十分方便，因为它可以接受reactive表达式创建共享数据。\nlibrary(DT)\nlibrary(shiny)\nlibrary(plotly)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  selectInput(\n    \"specie\", \"Specie\",\n    choices = c(\"setosa\", \"versicolor\", \"virginica\")\n  ),\n  fluidRow(\n    column(6, DTOutput(\"table\")),\n    column(6, plotlyOutput(\"plot\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  reactive_data &lt;- reactive({\n    iris[iris$Species == input$specie, ]\n  })\n\n  sd &lt;- SharedData$new(reactive_data)\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n\n  output$plot &lt;- renderPlotly({\n    plot_ly(sd, x = ~Sepal.Length, y = ~Sepal.Width)\n  })\n}\n\nshinyApp(ui, server)\nSharedData对象的data方法有参数withSelection，当为TRUE时，数据会添加一列selected_，值为TRUE或FALSE，表示该行是否被选中。\nlibrary(DT)\nlibrary(shiny)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(4, uiOutput(\"text\")),\n    column(8, DTOutput(\"table\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  sd &lt;- SharedData$new(cars)\n\n  output$text &lt;- renderUI({\n    # get selected rows\n    n_selected &lt;- sd$data(withSelection = TRUE) %&gt;%\n      dplyr::filter(selected_ == TRUE) %&gt;%\n      nrow()\n\n    h3(n_selected, \"selected items\")\n  })\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n}\n\nshinyApp(ui, server)\n\nSharedData对象也有selection方法，可以主动过滤选中的行。\nlibrary(DT)\nlibrary(shiny)\nlibrary(crosstalk)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(4, actionButton(\"random\", \"Select a random row\")),\n    column(8, DTOutput(\"table\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  sd &lt;- SharedData$new(cars)\n\n  output$table &lt;- renderDT(\n    {\n      datatable(sd)\n    },\n    server = FALSE\n  )\n\n  selected &lt;- c()\n  observeEvent(input$random, {\n    smp &lt;- c(1:50)[!1:50 %in% selected]\n    selected &lt;&lt;- append(selected, sample(smp, 1))\n    sd$selection(selected)\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-requirements",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-requirements",
    "title": "09 Linking Widgets",
    "section": "Crosstalk Requirements",
    "text": "Crosstalk Requirements\ncrosstalk包适用于长数据格式，即每行是一个特征，数据的交互是对行进行筛选。直白地讲，它支持散点图似的特征数据，不支持直方图似的总结数据。",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#how-it-works",
    "href": "Books/Js4R/09 Linking Widgets.html#how-it-works",
    "title": "09 Linking Widgets",
    "section": "How it Works",
    "text": "How it Works\ncrosstalk包实现widgets之间数据共享的底层逻辑是JavaScript。事实上，无论在Rstudio的Viewer中，shiny中，还是Rmarkdown中，crosstalk包都可以适用。\n\n\n\n\n\nflowchart LR\n    subgraph i1[R]\n        direction LR\n        A[DataFrame]\n        B[Shared Dataset]\n        A --&gt;B\n    end\n    subgraph i2[JavaScript]\n        direction LR\n        C[Widget1]\n        D[Widget2]\n        C &lt;--&gt; D\n    end\n    i1 --&gt;i2\n    style i1 fill:#FFF\n    style i2 fill:#FFF\n\n\n\n\n\n\n\nKeys\nSharedData$new()在创建共享数据时，会为数据中的每一行添加键（key）。如果dataframe有行名，使用行名作为键，否则自动创建行数索引作为键。你可以将创建过程想象为添加了key列，但实际上这一列并不存在。key可以重复。\n\nsd_cars &lt;- SharedData$new(cars[1:2, ])\n\n\n共享数据中的key你可以使用key方法获取，也可以在创建时指定key。\n\nsd_cars$key()\n#&gt; [1] \"1\" \"2\"\n\n\n# assign keys\ndf &lt;- data.frame(x = runif(5))\nsd &lt;- SharedData$new(df, key = letters[1:5])\nsd$key()\n#&gt; [1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n\n\nCommunication Lines\n在某种意义上，虽然crosstalk建立了通信线路来传输键值，但各自开发的组件必须处理发送到其他组件的键值以及如何处理接收到的键值（这些键值是在其他组件中被选择或过滤的）。即，有两种这样的通信线路：一种用于筛选要显示的数据点的行键值，另一种用于选择（crosstalk称为“链接刷选”）以突出显示特定数据点（使其他数据点淡出）。\n在JavaScript中，一个组件会接收所选和过滤的数据点的键值，并且当观察到过滤或选择时，必须将这些选定或过滤的键值“发送”给其他组件。因此，crosstalk可以实现在多个组件之间共享数据并实现交互式可视化分析的功能。\n\n\nGroups\nSharedData$new()在创建共享数据时，会给数据添加group属性，用来共享key。\n\n下例中，虽然创建了两个SharedData对象，但它们都共享了同一组key。\n\nshared_cars &lt;- SharedData$new(mtcars, group = \"cars\")\nshared_cars_head &lt;- SharedData$new(head(mtcars), group = \"cars\")",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#crosstalk-with-gio",
    "href": "Books/Js4R/09 Linking Widgets.html#crosstalk-with-gio",
    "title": "09 Linking Widgets",
    "section": "Crosstalk with Gio",
    "text": "Crosstalk with Gio\n考虑到gio.js使用的数据格式略有不同：每一行是一条边，整个数据是一个网络，前端更新某个节点时，会带出不同的相连节点，也即选中某个节点实际会返回多行值。我们需要提醒使用者：创建共享数据时，指定数据中的e列或i列作为key，使用其他列作为key也可以，但是会增加额外的步骤，使机制更加复杂。\n\n#  keys = target\nshared_arcs &lt;- crosstalk::SharedData$new(arcs, key = arcs$e)\n# keys = source\nshared_arcs &lt;- crosstalk::SharedData$new(arcs, key = arcs$i)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#r-code",
    "href": "Books/Js4R/09 Linking Widgets.html#r-code",
    "title": "09 Linking Widgets",
    "section": "R code",
    "text": "R code\n为了适配crosstalk，R/gio.R文件中的函数gio()需要修改为能使用由crosstalk::SharedData$new()创建的共享数据对象。该对象是R6类，有三个属性，可以用三个函数分别提取属性内容。\n\norigData：原始数据\ngroupName：所属组\nkey：分配给每一行的key\n\n\nclass(shared_arcs)\n#&gt; [1] \"SharedData\" \"R6\"\n\n# original data\nshared_arcs$origData()\n#&gt;    e  i       v\n#&gt; 1 CN US 3300000\n#&gt; 2 CN RU   10000\n# groupName\nshared_arcs$groupName()\n#&gt; [1] \"SharedDataaa3d2a04\"\n# keys\nshared_arcs$key()\n#&gt; [1] \"US\" \"RU\"\n\n每个构件都必须使用origData和groupName方法，key方法可能不适用于每个构件，但如果可视化库包含 key/id 系统，它将非常有用。gio.js没有这样的系统，所以我们不使用key方法。group的信息需要传递给x对象，以便在需要时可以被JavaScript端访问；同时还需要用crosstalkLibs获取crosstalk所需的JavaScript依赖库。\ngio &lt;- function(data, width = NULL, height = NULL,\n  elementId = NULL) {\n\n  # defaults to NULL\n  group &lt;- NULL\n  deps &lt;- NULL\n\n  # uses crosstalk\n  if (crosstalk::is.SharedData(data)) {\n    group &lt;- data$groupName()\n    data &lt;- data$origData()\n    deps &lt;- crosstalk::crosstalkLibs()\n  }\n\n  # forward options using x\n  x = list(\n    data = data,\n    style = \"default\",\n    crosstalk = list(group = group) # pass group\n  )\n\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId,\n    sizingPolicy = htmlwidgets::sizingPolicy(\n      padding = 0,\n      browser.fill = TRUE,\n      defaultWidth = \"100%\"\n    ),\n    preRenderHook = render_gio,\n    # add crosstalk dependency\n    dependencies = deps\n  )\n}",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#javascript-code",
    "href": "Books/Js4R/09 Linking Widgets.html#javascript-code",
    "title": "09 Linking Widgets",
    "section": "JavaScript Code",
    "text": "JavaScript Code\ninst/htmlwidgets/gio.js中需要在factory函数中添加key的选择处理器。\nvar sel_handle = new crosstalk.SelectionHandle();\n接着在renderValue函数中为处理器添加group信息（上述R code处理后结果）。\n一定要注意的是：我们不仅需要将key信息发送到其他组件中，还需要接收其他组件传入的key信息。\n\nSend Selected Keys\n为了将选择的key信息发送出去，我们首先要获取被客户选择的key信息（callback）。获取方式因不同的JS库而不同，JS库通常都会提供callback函数或者触发事件来获取key信息。gio.js获取key信息方式如下，通过定义callback函数，可以返回：选中的国家及其关联的国家。\n// define callback function\nfunction callback (selectedCountry, relatedCountries) {\n  console.log(selectedCountry);\n  // console.log(relatedCountries);\n}\n\n// use callback function\ncontroller.onCountryPicked(callback);\n{name: \"LIBYA\", lat: 25, lon: 17, center: n, ISOCode: \"LY\"}\n因为我们要将选中的key信息发送给其他组件，所以需要修改callback函数；考虑到crosstalk创建的共享数据使用的key最好是ISOcode，所以直接返回JSON对象的ISOcode字段。注意sel_handle.set需要的输入是null或array，selectedCountry.ISOCode必须用[]包裹起来。\nfunction callback (selectedCountry) {\n  sel_handle.set([selectedCountry.ISOCode]);\n}\n\ncontroller.onCountryPicked(callback);\n\n\nSet Selected Keys\n除了要发送key信息，组件也需要接收其他组件发送的key信息。使用sel_handle.on()来监听其他组件发送的key信息。\n// placed in factory function\nsel_handle.on(\"change\", function(e) {\n  console.log(e);\n});\n返回的e包含下面信息：\n\noldValue： 之前选中的key\nsender：变更key的组件\nvalue： 当前选中的key\n\n{\n  oldValue: [],\n  sender: n {\n    _eventRelay: e,\n    _emitter: t,\n    _group: \"SharedDatac7682f87\",\n    _var: r,\n    _varOnChangeSub: \"sub1\",\n    …\n  },\n  value: [\"AE\"]\n}\n当监听到变更时，可以将变更的key传递给controller.switchCountry()进行变更处理。通常需要清除之前的key，但gio.js始终都需要一个key，所以此处不作处理。\n// placed in factory function\nsel_handle.on(\"change\", function(e) {\n\n  // selection comes from another widget\n  if (e.sender !== sel_handle) {\n    // clear the selection\n    // not possible with gio.js\n  }\n  controller.switchCountry(e.value[0]);\n});",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/09 Linking Widgets.html#using-crosstalk-with-gio",
    "href": "Books/Js4R/09 Linking Widgets.html#using-crosstalk-with-gio",
    "title": "09 Linking Widgets",
    "section": "Using Crosstalk with Gio",
    "text": "Using Crosstalk with Gio\n现在，gio包已经支持crosstalk了，下面是两个例子。\n\nlibrary(DT)\nlibrary(gio)\nlibrary(crosstalk)\n\n# url &lt;- paste0(\n#   \"https://raw.githubusercontent.com/JohnCoene/\",\n#   \"javascript-for-r/master/data/countries.json\"\n# )\nurl &lt;- \"countries.json\"\narcs &lt;- jsonlite::fromJSON(url)\n\n# Wrap data frame in SharedData\n# key is importing country\nsd &lt;- SharedData$new(arcs, key = arcs$i)\n\nbscols(\n  gio(sd),\n  datatable(sd, width = \"100%\", selection = \"single\")\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用group参数，将数据中的边与节点进行关联。\n\n\nlibrary(gio)\nlibrary(plotly)\nlibrary(crosstalk)\n\n# url &lt;- paste0(\n#   \"https://raw.githubusercontent.com/JohnCoene/\",\n#   \"javascript-for-r/master/data/countries.json\"\n# )\nurl &lt;- \"countries.json\"\narcs &lt;- jsonlite::fromJSON(url)\n\n# Wrap data frame in SharedData\nedges_sd &lt;- SharedData$new(\n  arcs,\n  key = arcs$i, group = \"sharedGroup\"\n)\n\n# create nodes\niso2c &lt;- unique(arcs$i)\nnodes &lt;- data.frame(\n  country = iso2c,\n  y = rnorm(length(iso2c))\n)\nnodes_sd &lt;- SharedData$new(\n  nodes,\n  key = nodes$country,\n  group = \"sharedGroup\"\n)\n\nbscols(\n  plot_ly(data = nodes_sd, type = \"bar\", x = ~country, y = ~y) %&gt;%\n    config(displayModeBar = FALSE),\n  gio(edges_sd)\n)",
    "crumbs": [
      "09 Linking Widgets"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html",
    "href": "Books/Js4R/10 Final Revisions.html",
    "title": "10 Final Revisions",
    "section": "",
    "text": "本章我们将完善gio包中面向使用者的API。",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#htmlwidgets-and-data",
    "href": "Books/Js4R/10 Final Revisions.html#htmlwidgets-and-data",
    "title": "10 Final Revisions",
    "section": "Htmlwidgets and Data",
    "text": "Htmlwidgets and Data\n仔细观察前面R/gio.R的gio函数，我们会发现：如果面向使用者，gio函数的‘要求’过于严格了，必须每一行是一条边，而且有三列，列名必须是e，i，v。与编写其他R包类型，我们需要优化gio函数参数，使其更加鲁棒。一种方法是使用类似ggplot2::aes()函数的非标准性评估，如下示例。\ngio &lt;- function(data, source, target, value, ...,\n  width = NULL, height = NULL, elementId = NULL) {\n\n  # defaults to NULL\n  group &lt;- NULL\n\n  if (crosstalk::is.SharedData(data)) {\n    group &lt;- data$groupName()\n    data &lt;- data$origData()\n  }\n\n  # non-standard evaluation\n  data &lt;- dplyr::select(\n    data,\n    i = {{ source }},\n    e = {{ target }},\n    v = {{ value }}\n  )\n\n  # forward options using x\n  x = list(\n    configs = list(...),\n    data = data,\n    style = \"default\",\n    crosstalk = list(group = group)\n  )\n\n  attr(x, 'TOJSON_ARGS') &lt;- list(dataframe = \"rows\")\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'gio',\n    x,\n    width = width,\n    height = height,\n    package = 'gio',\n    elementId = elementId,\n    sizingPolicy = htmlwidgets::sizingPolicy(\n      padding = 0,\n      browser.fill = TRUE,\n      defaultWidth = \"100%\"\n    ),\n    preRenderHook = render_gio,\n    dependencies = crosstalk::crosstalkLibs()\n  )\n}\n改造过的函数使用起来会更加上手：参数名含义直接明了，第一个参数提供数据，后面三个参数提供对应列。\n# mock up data\ncountries &lt;- c(\"US\", \"BE\", \"FR\", \"DE\")\ndf &lt;- data.frame(\n  from = countries,\n  to = rev(countries),\n  traded = runif(4)\n)\n\n# use gio\ngio(df, source = from, target = to, value = traded)",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#plethora-of-options",
    "href": "Books/Js4R/10 Final Revisions.html#plethora-of-options",
    "title": "10 Final Revisions",
    "section": "Plethora of Options",
    "text": "Plethora of Options\ngio.js有许多配置项参数，如：\nvar configs = {\n  control: {\n    stats: false,\n    disableUnmentioned: false,\n    lightenMentioned: false,\n    inOnly: false,\n    outOnly: false,\n    initCountry: \"CN\",\n    halo: true\n  },\n  color: {\n    surface: 0xFFFFFF,\n    selected: null,\n    in: 0x154492,\n    out: 0xDD380C,\n    halo: 0xFFFFFF,\n    background: null\n  },\n  brightness: {\n    ocean: 0.5,\n    mentioned: 0.5,\n    related: 0.5\n  }\n}\n\ncontroller = new Gio.controller(el, configs);\n不仅gio.js，JS库通常都会有丰富的配置项参数，我们不可能一一通过具体参数呈现，此时可以考虑...；如上例中的额外参数...，以list的格式传递给了x对象。\n在inst/htmlwidgets/gio.js中，可以将解析到的参数配置传递给controller。\n// use x.configs\ncontroller = new GIO.controller(el, x.configs);\n\ngio(\n  df, from, to, traded,\n  control = list(initCountry = \"US\"),\n  color = list(selected = \"#ff4d4d\")\n)",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#interface-design",
    "href": "Books/Js4R/10 Final Revisions.html#interface-design",
    "title": "10 Final Revisions",
    "section": "Interface Design",
    "text": "Interface Design\n\n始终记住你为客户开发的使用界面。\n你可以额外配置底层JS依赖库的选项，使其更加适配自己的风格。\n学习借鉴其他优秀R包的API风格，但也不要奉为金科玉律。",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Books/Js4R/10 Final Revisions.html#exercises",
    "href": "Books/Js4R/10 Final Revisions.html#exercises",
    "title": "10 Final Revisions",
    "section": "Exercises",
    "text": "Exercises\n学习下面的js库，练习创建一个简单的可视化应用。\n\nchart.js\ncytoscape.js\nToast UI charts\namcharts",
    "crumbs": [
      "10 Final Revisions"
    ]
  },
  {
    "objectID": "Blog/相关性计算.html",
    "href": "Blog/相关性计算.html",
    "title": "相关性计算",
    "section": "",
    "text": "近日，就相关性及其显著性的计算发生了一些讨论，现记录总结如下。"
  },
  {
    "objectID": "Blog/相关性计算.html#计算相关性及显著性",
    "href": "Blog/相关性计算.html#计算相关性及显著性",
    "title": "相关性计算",
    "section": "计算相关性及显著性",
    "text": "计算相关性及显著性\n共分为四步：\n\nstats::cor()计算相关性r。\n计算自由度n。\n构建正态分布统计量t。\n计算相关性显著性p。\n\n# x is matrix\n# 代码源于 psych::corr.test\nr &lt;- cor(x, use = use, method = method)\nn &lt;- t(!is.na(x)) %*% (!is.na(x))\nt &lt;- (r * sqrt(n - 2)) / sqrt(1 - r^2)\np &lt;- -2 * expm1(pt(abs(t), (n - 2), log.p = TRUE))\nse &lt;- sqrt((1 - r * r) / (n - 2))"
  },
  {
    "objectID": "Blog/相关性计算.html#cor函数参数use",
    "href": "Blog/相关性计算.html#cor函数参数use",
    "title": "相关性计算",
    "section": "cor函数参数use",
    "text": "cor函数参数use\n在上面四个步骤中，use参数往往会被忽略，但是它及其重要。use参数用来处理输入数据中的NA值，是大型数据处理时的主要限速步骤。\nuse参数的取值有：\n\n\"everything\": 忽略NA值，数据中的NA值导致相关性为NA值。\n\"all.obs\": 数据中有NA值时报错，只计算有完整数据对之间的相关性。\n\"complete.obs\": 允许数据中有NA值，计算前会整体地删除有NA值的行，删除后无法计算相关性时报错。\n\"na.or.complete\": 允许数据中有NA值，计算前会整体地删除有NA值的行，删除后无法计算相关性时输出NA值。\n\"pairwise.complete.obs\": 允许数据中有NA值，计算前会按变量单独地删除有NA值的行，删除后无法计算相关性时输出NA值。\n\n\nx &lt;- c(1, 2, NA, NA, NA)\ny &lt;- c(NA, 2, 5, 6, 6)\nz &lt;- c(NA, NA, 4, 7, 8)\n\ndat &lt;- data.frame(x, y, z)\n\ncor(dat, use = \"everything\")\n#&gt;    x  y  z\n#&gt; x  1 NA NA\n#&gt; y NA  1 NA\n#&gt; z NA NA  1\ncor(dat, use = \"all.obs\")\n#&gt; Error in cor(dat, use = \"all.obs\"): missing observations in cov/cor\ncor(dat, use = \"complete.obs\")\n#&gt; Error in cor(dat, use = \"complete.obs\"): no complete element pairs\ncor(dat, use = \"na.or.complete\")\n#&gt;    x  y  z\n#&gt; x NA NA NA\n#&gt; y NA NA NA\n#&gt; z NA NA NA\ncor(dat, use = \"pairwise.complete.obs\")\n#&gt;    x         y         z\n#&gt; x  1        NA        NA\n#&gt; y NA 1.0000000 0.9707253\n#&gt; z NA 0.9707253 1.0000000"
  },
  {
    "objectID": "Blog/相关性计算.html#显著性计算",
    "href": "Blog/相关性计算.html#显著性计算",
    "title": "相关性计算",
    "section": "显著性计算",
    "text": "显著性计算\n显著性的计算基于pt函数，该函数依据数据构建的统计量和自由度，计算该数据点出现的概率。上面的代码使用了对数化操作，能够提高计算的精度。\n考虑到use = \"pairwise\"时，每对相关性数据的自由度会不同，所以上面的代码采取了矩阵的计算方法。生成每对相关性数据的自由度和统计量。\n虽然当use = \"everything\"时，每对数据点之间自由度相同，可以使用标量进行计算，但是实际上矩阵 * 标量 = 矩阵，矩阵 * 矩阵 = 矩阵，并不会造成计算浪费。"
  },
  {
    "objectID": "Blog/相关性计算.html#测试",
    "href": "Blog/相关性计算.html#测试",
    "title": "相关性计算",
    "section": "测试",
    "text": "测试\n\n# 生成一个100行，10000列的随机矩阵，用来测试相关性\nx &lt;- matrix(rnorm(100 * 10000), nrow = 100)\n\nsystem.time({\n  r &lt;- cor(x, use = \"pairwise\", method = \"pearson\")\n})\n#&gt;    user  system elapsed \n#&gt;  40.554   0.774  42.857\nsystem.time({\n  r &lt;- cor(x, use = \"everything\", method = \"pearson\")\n})\n#&gt;    user  system elapsed \n#&gt;   7.001   0.698   7.057\nsystem.time({\n  n &lt;- t(!is.na(x)) %*% (!is.na(x))\n})\n#&gt;    user  system elapsed \n#&gt;   1.853   2.383   0.188\nsystem.time({\n  t &lt;- (r * sqrt(n - 2)) / sqrt(1 - r^2)\n})\n#&gt;    user  system elapsed \n#&gt;   1.054   1.131   2.003\nsystem.time({\n  p &lt;- -2 * expm1(pt(abs(t), (n - 2), log.p = TRUE))\n})\n#&gt;    user  system elapsed \n#&gt;  15.832   1.617  15.996\nsystem.time({\n  p &lt;- -2 * expm1(pt(abs(t), (dim(x)[1] - 2), log.p = TRUE))\n})\n#&gt;    user  system elapsed \n#&gt;  15.632   1.111  15.522"
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html",
    "href": "Books/Advanced R(2e)/7 Environments.html",
    "title": "7 Environments",
    "section": "",
    "text": "环境(enviroment, Env)是赋予作用域(scoping)能力的数据结构。本章会详细地介绍环境的数据结构，来提高对于作用域的理解。\n\n\n\n7.2节介绍环境的基本属性及如何创建一个自己的环境。\n7.3节通过一个模板函数，介绍与环境进行交互的方法。\n7.4节介绍4种特殊环境：R包环境，函数环境，函数执行换行，命名空间。\n7.5节介绍调用环境（caller）。\n7.6节简单讨论如何使用环境这一数据结构来解决一些特定问题。\n\n\n\n\n本章将使用 rlang 中的函数来处理环境。\n\nlibrary(rlang)\n\nrlang中的env_*()函数被设计用来在工作流中使用。所有的函数都接收一个环境作为参数，大多数会返回一个环境。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#introduction",
    "href": "Books/Advanced R(2e)/7 Environments.html#introduction",
    "title": "7 Environments",
    "section": "",
    "text": "环境(enviroment, Env)是赋予作用域(scoping)能力的数据结构。本章会详细地介绍环境的数据结构，来提高对于作用域的理解。\n\n\n\n7.2节介绍环境的基本属性及如何创建一个自己的环境。\n7.3节通过一个模板函数，介绍与环境进行交互的方法。\n7.4节介绍4种特殊环境：R包环境，函数环境，函数执行换行，命名空间。\n7.5节介绍调用环境（caller）。\n7.6节简单讨论如何使用环境这一数据结构来解决一些特定问题。\n\n\n\n\n本章将使用 rlang 中的函数来处理环境。\n\nlibrary(rlang)\n\nrlang中的env_*()函数被设计用来在工作流中使用。所有的函数都接收一个环境作为参数，大多数会返回一个环境。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#environment-basics",
    "href": "Books/Advanced R(2e)/7 Environments.html#environment-basics",
    "title": "7 Environments",
    "section": "Environment basics",
    "text": "Environment basics\n环境与有name属性的list很相似，但是有4点差异：\n\n要求name唯一。\nname不会被排序，即无法使用顺序来提取环境中的变量。\n赋值NULL时，环境会更改变量值，而不是删除变量。\n被修改时不会在内存中复制。\n\n\nBasics\n使用rlang::env()创建一个环境，与list类似，接收一个键值对集合。base::new.env()函数也可以创建环境，但是不能直接传递键值对集合，需要使用$&lt;-赋值。\n\ne1 &lt;- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\n\ne2 &lt;- new.env()\ne2$a &lt;- FALSE\ne2$b &lt;- \"a\"\ne2$c &lt;- 2.3\ne2$d &lt;- 1:3\n\nidentical(e1, e2)\n#&gt; [1] FALSE\n\n\n环境具有引用语义：与大多数R对象不同，当你修改环境时，你是在原地修改它们，而不是创建副本。一个重要的含义是，环境可以自我包含。\n\ne1$d &lt;- e1\n\n\n在终端中直接运行环境仅会显示内存地址，使用env_print()可以打印更多环境信息，也可以使用env_names()直接输出目前环境中绑定过的变量名。\n\ne1\n#&gt; &lt;environment: 0x0000029420284e80&gt;\nenv_print(e1)\n#&gt; &lt;environment: 0x0000029420284e80&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;lgl&gt;\n#&gt; • b: &lt;chr&gt;\n#&gt; • c: &lt;dbl&gt;\n#&gt; • d: &lt;env&gt;\nenv_names(e1)\n#&gt; [1] \"a\" \"b\" \"c\" \"d\"\n\n\n\nImportant environments\n这里介绍两个特殊环境，更多特殊的环境会在之后详细讲到：\n\n全局环境：就是当前交互终端的环境，global_env()或globalenv()获取。\n当前环境：当前执行代码的环境，current_env()或environment()获取，如果在终端中执行，那么等于全局环境。\n\n使用identical()判断两个环境是否相等，不能使用==，因为环境不是atomic或list类型。\n\nidentical(global_env(), current_env())\n#&gt; [1] TRUE\n\nglobal_env() == current_env()\n#&gt; Error in global_env() == current_env(): comparison (==) is possible only for atomic and list types\n\n\n\nParents\n使用env()创建环境时，提供一个没有name的参数即可设定环境的父环境。使用env_parent()或parent.env可以查看父环境。\n\ne2a &lt;- env(d = 4, e = 5)\ne2b &lt;- env(e2a, a = 1, b = 2, c = 3)\nenv_parent(e2b)\n#&gt; &lt;environment: 0x00000294205985c0&gt;\nparent.env(e2b)\n#&gt; &lt;environment: 0x00000294205985c0&gt;\nenv_parent(e2a)\n#&gt; &lt;environment: R_GlobalEnv&gt;\nparent.env(e2a)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n每个环境都有父环境，除了空环境（empty environment）。使用env_parents()可以查看所有父环境，空环境是根环境。\n\ne2c &lt;- env(empty_env(), d = 4, e = 5)\ne2d &lt;- env(e2c, a = 1, b = 2, c = 3)\nenv_parents(e2b)\n#&gt; [[1]]   &lt;env: 0x00000294205985c0&gt;\n#&gt; [[2]] $ &lt;env: global&gt;\nenv_parents(e2d)\n#&gt; [[1]]   &lt;env: 0x000002942134d898&gt;\n#&gt; [[2]] $ &lt;env: empty&gt;\n\n\nenv_parents()通常只返回到全局环境。设置last = empty_env()可以返回所有父环境。\n\nenv_parents(e2b, last = empty_env())\n#&gt;  [[1]]   &lt;env: 0x00000294205985c0&gt;\n#&gt;  [[2]] $ &lt;env: global&gt;\n#&gt;  [[3]] $ &lt;env: package:rlang&gt;\n#&gt;  [[4]] $ &lt;env: package:stats&gt;\n#&gt;  [[5]] $ &lt;env: package:graphics&gt;\n#&gt;  [[6]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[7]] $ &lt;env: package:datasets&gt;\n#&gt;  [[8]] $ &lt;env: renv:shims&gt;\n#&gt;  [[9]] $ &lt;env: package:utils&gt;\n#&gt; [[10]] $ &lt;env: package:methods&gt;\n#&gt; [[11]] $ &lt;env: Autoloads&gt;\n#&gt; [[12]] $ &lt;env: package:base&gt;\n#&gt; [[13]] $ &lt;env: empty&gt;\n\n\n\nSuper assignment, &lt;&lt;-\n常规赋值&lt;-会在当前环境中创建变量。超赋值&lt;&lt;-从不会在当前环境中创建变量，只是会修改变量，当前环境中没有就依次在父环境中搜索，直到全局环境。如果全局环境中也没有这个变量，就会在全局环境中创建这个变量。\n\nx &lt;- 0\nf &lt;- function() {\n  x &lt;&lt;- 1\n}\nf()\nx\n#&gt; [1] 1\n\n\n\nGetting and setting\n获取环境中的变量方法有$，[[，env_get()。\n\ne3 &lt;- env(x = 1, y = 2)\ne3$x\n#&gt; [1] 1\ne3$z &lt;- 3\ne3[[\"z\"]]\n#&gt; [1] 3\nenv_get(e3, \"z\")\n#&gt; [1] 3\n\n需要注意的是：[[不适用于数字索引，也不可以使用[。\n\ne3[[1]]\n#&gt; Error in e3[[1]]: wrong arguments for subsetting an environment\n\ne3[c(\"x\", \"y\")]\n#&gt; Error in e3[c(\"x\", \"y\")]: object of type 'environment' is not subsettable\n\n变量不存在时，$，[[会返回NULL，但NULL在环境中有实际意义。 env_get()会返回错误，env_get()设置参数default后，可以给定默认值而不报错。\n\ne3$xyz\n#&gt; NULL\n\nenv_get(e3, \"xyz\")\n#&gt; Error in `env_get()`:\n#&gt; ! Can't find `xyz` in environment.\n\nenv_get(e3, \"xyz\", default = NA)\n#&gt; [1] NA\n\nrlang包还提供两种额外的设定变量值的方法：\n\nenv_poke()：只设置一个变量。\nenv_bind()：设置多个变量。\n\n\nenv_poke(e3, \"a\", 100)\ne3$a\n#&gt; [1] 100\n\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#&gt; [1] \"x\" \"y\" \"z\" \"a\" \"b\"\n\n与list不同，当设置变量值为NULL时，并不会移除这个变量，而是实际有一个变量指向了NULL。env_has()可以用来检测环境中是否存在某个变量。env_unbind()会真实地解绑一个变量。\n\ne3$a &lt;- NULL\nenv_has(e3, \"a\")\n#&gt;    a \n#&gt; TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#&gt;     a \n#&gt; FALSE\n\n需要注意地是：env_unbind()不会删除变量，只是解绑变量与值的关系，删除变量是gc()的任务。在R base中存在功能与上述类似的函数：get()，assign()，exists()，rm()，这些函数被设计用来在当前环境中工作，其他环境中会略显不足。\n\n\nAdvanced bindings\nenv_bind()函数有两个变体：\n\nenv_bind_lazy()可以创建延迟绑定。在首次绑定前会先运行导致延迟的代码，然后再绑定。延迟绑定主要应用于R包中的autoload()，预先将数据集加载到内存中。\n\n\nenv_bind_lazy(current_env(), b = {\n  Sys.sleep(1)\n  1\n})\n\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;    0.00    0.00    1.01\nsystem.time(print(b))\n#&gt; [1] 1\n#&gt;    user  system elapsed \n#&gt;       0       0       0\n\n\nenv_bind_active()可以创建实时绑定，每次重新绑定值。\n\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#&gt; [1] 0.08075014\nz1\n#&gt; [1] 0.834333\n\n更多见?delayedAssign()和?makeActiveBinding()。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#recursing-over-environments",
    "href": "Books/Advanced R(2e)/7 Environments.html#recursing-over-environments",
    "title": "7 Environments",
    "section": "Recursing over environments",
    "text": "Recursing over environments\n由于每个环境都会有一个父环境，可以利用这一特点，递归遍历环境，执行某些操作。下面是一个用来递归找到变量函数——where()的实现。\n\nwhere &lt;- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\n\n\n首先判断是否是empty_env()，如果是则返回“找不到变量”，如果不是\n则判断当前环境是否包含这个变量，如果有则返回当前环境，如果没有\n则递归查询父环境。\n\n\nwhere(\"yyy\")\n#&gt; Error: Can't find yyy\n\nx &lt;- 5\nwhere(\"x\")\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\nwhere(\"mean\")\n#&gt; &lt;environment: base&gt;\n\n用一幅图来展示上面的逻辑，想象下面两个环境：\n\ne4a &lt;- env(empty_env(), a = 1, b = 2)\ne4a\n#&gt; &lt;environment: 0x000002942019e810&gt;\ne4b &lt;- env(e4a, x = 10, a = 11)\ne4b\n#&gt; &lt;environment: 0x0000029420136f10&gt;\n\n\n\nwhere(\"a\", e4b)的结果是e4b。\nwhere(\"b\", e4b)的结果是e4a。\nwhere(\"c\", e4b)的结果是error。\n\n\nwhere(\"a\", e4b)\n#&gt; &lt;environment: 0x0000029420136f10&gt;\nwhere(\"b\", e4b)\n#&gt; &lt;environment: 0x000002942019e810&gt;\nwhere(\"c\", e4b)\n#&gt; Error: Can't find c\n\n总结这种递归查询环境的逻辑如下：\nf &lt;- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # base case\n  } else if (success) {\n    # success case\n  } else {\n    # recursive case\n    f(..., env = env_parent(env))\n  }\n}\n\nIteration versus recursion\n使用while循环改写上面的函数：\nf2 &lt;- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env &lt;- env_parent(env)\n  }\n\n  # base case\n}",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#special-environments",
    "href": "Books/Advanced R(2e)/7 Environments.html#special-environments",
    "title": "7 Environments",
    "section": "Special environments",
    "text": "Special environments\n许多环境是由R自行创建，例如：包环境，函数环境等，本节介绍四种特殊的环境——包环境，函数环境，函数运行环境，命名空间。\n\nPackage environments and the search path\n每次使用library()或require()时，都会将包环境变成全局环境的父环境，最先加载的包环境是后加载包环境的父环境。\n\n\n这些环境的关系也被称作搜索路径。你可以使用base::search()或rlang::search_envs()查看搜索路径。搜索路径的最后两个环境是固定的——Autoloads和base。\n\nsearch()\n#&gt;  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#&gt;  [4] \"package:graphics\"  \"package:grDevices\" \"package:datasets\" \n#&gt;  [7] \"renv:shims\"        \"package:utils\"     \"package:methods\"  \n#&gt; [10] \"Autoloads\"         \"package:base\"\n\nsearch_envs()\n#&gt;  [[1]] $ &lt;env: global&gt;\n#&gt;  [[2]] $ &lt;env: package:rlang&gt;\n#&gt;  [[3]] $ &lt;env: package:stats&gt;\n#&gt;  [[4]] $ &lt;env: package:graphics&gt;\n#&gt;  [[5]] $ &lt;env: package:grDevices&gt;\n#&gt;  [[6]] $ &lt;env: package:datasets&gt;\n#&gt;  [[7]] $ &lt;env: renv:shims&gt;\n#&gt;  [[8]] $ &lt;env: package:utils&gt;\n#&gt;  [[9]] $ &lt;env: package:methods&gt;\n#&gt; [[10]] $ &lt;env: Autoloads&gt;\n#&gt; [[11]] $ &lt;env: package:base&gt;\n\n\n\nThe function environment\n函数在被创建时，会自动绑定当前环境，这个环境被称作函数环境。函数与函数环境一起构成了“闭包”。\n使用rlang::fn_env()或base::environment()可以查看函数环境。\n\ny &lt;- 1\nf &lt;- function(x) x + y\nfn_env(f)\n#&gt; &lt;environment: R_GlobalEnv&gt;\nenvironment(f)\n#&gt; &lt;environment: R_GlobalEnv&gt;\n\n\n上面的例子中，函数f()的函数环境是当前环境，其绑定的变量f在当前环境中。但实际上，这两种情况的环境并不总是相同。例如下面的例子，函数g()的函数环境是当前环境，但其绑定的变量g在环境e中。这两种的区别在于，前者定义了函数g如何寻找参数变量，后者定义了如何寻找函数g。（将e环境视作包环境，是不是更容易理解？）\n\ne &lt;- env()\ne$g &lt;- function(x) x\n\n\n\n\nExecution environments\n运行下面的函数，第一次，第二次，第n次的结果会怎样？\n\ng &lt;- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a &lt;- 1\n  } else {\n    a &lt;- a + 1\n  }\n  a\n}\n\n\ng(10)\n#&gt; [1] 1\ng(10)\n#&gt; [1] 1\n\n结果如上所示，每次的运行结果都相同。这是因为函数的执行环境在每次运行结束后，都会被清除，然后重新创建一个。它的父环境是函数环境。\n下面是一个各个环境之间关系的示意图：上面灰色方框表示执行环境，淡黄色框表示函数，右侧灰色框表示函数环境。\n\nh &lt;- function(x) {\n  # 1.\n  a &lt;- 2 # 2.\n  x + a\n}\ny &lt;- h(1) # 3.\n\n\n有些方法可以将执行环境保存下来。\n第一种就是直接返回：\n\nh2 &lt;- function(x) {\n  a &lt;- x * 2\n  current_env()\n}\n\ne &lt;- h2(x = 10)\nenv_print(e)\n#&gt; &lt;environment: 0x000002942538a8f0&gt;\n#&gt; Parent: &lt;environment: global&gt;\n#&gt; Bindings:\n#&gt; • a: &lt;dbl&gt;\n#&gt; • x: &lt;dbl&gt;\n\n另一种是将执行环境绑定到某个对象上，例如函数，成为函数环境：\n\nplus &lt;- function(x) {\n  function(y) x + y\n}\n\nplus_one &lt;- plus(1)\nplus_one\n#&gt; function (y) \n#&gt; x + y\n#&gt; &lt;environment: 0x0000029425fa24a8&gt;\n\n\n\nplus_one(2)\n#&gt; [1] 3\n\n\n\n\nNamespaces\n命名空间规定了R包中的函数如何正确找到自己引用的函数。而不会因为前面加载的R包导致引用错误。\n例如下面的sd()函数：通过命名空间namespace指定var()函数来自于stats包。\n\nsd\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x00000294265a8b90&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nR包中的函数都绑定一对环境——R包环境与命名空间。\n\nR包环境：针对使用者（user），告诉使用者如何引用函数。\n命名空间：针对R包自己，告诉R包中的函数如何引用其他函数。\n\n命名空间中的函数名集合包含R包环境中的，那些存在命名空间，但不存在R包环境中的函数，就是R包未导出的函数。\n\n前面说过，每个环境都有一个父环境。同样，每个命名空间环境都有一套相同的父环境：\n\n都有一个imports环境，定义了所有被R包使用的函数。R包开发者可以通过NAMESPACE文件来定义这个环境。\nimports环境的父环境是base包的命名空间。\nbase包的命名空间的父环境是全局环境R_GlobalEnv。\n\n\n最终父环境是全局环境，这一规则由于历史原因存在。按道理将不应该存在这一规则，因为这会导致在命名空间中不存在某个函数时，R会自动搜索全局环境。鉴于此，R CMD check会检查这种行为，并警告。\n将上述所有环境整合到一起，得到：\n\n函数和命名空间环境之间的绑定，是在加载R包时，因为创建了函数，触发创建函数环境导致的。也就是说，R包中函数的函数环境就是命名空间。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#call-stacks",
    "href": "Books/Advanced R(2e)/7 Environments.html#call-stacks",
    "title": "7 Environments",
    "section": "Call stacks",
    "text": "Call stacks\n最后一个特殊的环境是调用环境，可以通过rlang::caller_env()或base::parent.frame()查看。所谓调用环境就是调用函数的环境，如果你在函数A中调用函数B，那么B的调用环境就是函数A的函数环境。\n\ncaller_env()\n#&gt; &lt;environment: 0x000002942693e4e0&gt;\nparent.frame()\n#&gt; &lt;environment: 0x0000029426978ac0&gt;\n\n\nSimple call stacks\n函数之间的调用，会形成调用栈。下面是一个简单的函数调用栈。\n\nf &lt;- function(x) {\n  g(x = 2)\n}\ng &lt;- function(x) {\n  h(x = 3)\n}\nh &lt;- function(x) {\n  stop()\n}\n\n使用traceback()可以查看调用栈。\n\nf(x = 1)\n#&gt; Error in h(x = 3):\ntraceback()\n#&gt; No traceback available\n\n除了搭配stop() + traceback()，也可以使用lobstr::cst()直接查看调用栈。二者不同点在于栈的顺序相反。\n\nh &lt;- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#&gt;     ▆\n#&gt;  1. └─global f(x = 1)\n#&gt;  2.   └─global g(x = 2)\n#&gt;  3.     └─global h(x = 3)\n#&gt;  4.       └─lobstr::cst()\n\n\n\nLazy evaluation\n当函数的参数是函数返回值时，会触发延迟评估。调用栈会首先显示外层的调用，再显示内层的调用。\n\na &lt;- function(x) b(x)\nb &lt;- function(x) d(x)\nd &lt;- function(x) x\n\na(f())\n#&gt;     ▆\n#&gt;  1. ├─global a(f())\n#&gt;  2. │ └─global b(x)\n#&gt;  3. │   └─global d(x)\n#&gt;  4. └─global f()\n#&gt;  5.   └─global g(x = 2)\n#&gt;  6.     └─global h(x = 3)\n#&gt;  7.       └─lobstr::cst()\n\n\n\nFrames\n调用栈的每一层都被称为frame，是一种极其重要的内部数据结构，R代码只能访问其中部分数据，篡改frame会导致R崩溃。\n每个frame都三个关键点：\n\nexpr：调用的函数表达式，即在终端打印出的信息。\nenv：通常是函数表达式的执行环境。有两个例外：全局环境的frame是全局环境，eval()函数中的环境是任意的。\nparent：调用栈的栈（图中灰色线）。\n\n\n除此，frame还有退出机制on.exit(),return()等细节。\n\n\nDynamic scope\n在调用栈中检索变量的行为被称为动态作用域（dynamic scope）。动态作用域主要用于开发有助于交互式数据分析的函数，这是第 20 章讨论的主题之一。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/7 Environments.html#as-data-structures",
    "href": "Books/Advanced R(2e)/7 Environments.html#as-data-structures",
    "title": "7 Environments",
    "section": "As data structures",
    "text": "As data structures\n环境的数据结构可以作为一种参考语义，帮助解决下面三个常见的问题：\n\n避免大型数据的复制：在环境中，你永远也不会意外地创建副本。但是直接使用环境十分地不方便，推荐在第14章中讲到地R6类。\n管理R包的状态：创建一个额外的环境，在环境中记录状态。\n\n\nmy_env &lt;- new.env(parent = emptyenv())\nmy_env$a &lt;- 1\n\nget_a &lt;- function() {\n  my_env$a\n}\nset_a &lt;- function(value) {\n  old &lt;- my_env$a\n  my_env$a &lt;- value\n  invisible(old)\n}\n\n\n哈希映射 ：环境的数据结构就是一种哈希映射，可以缩短检索时间。",
    "crumbs": [
      "7 Environments"
    ]
  },
  {
    "objectID": "Blog/绘制点脊图.html",
    "href": "Blog/绘制点脊图.html",
    "title": "绘制点脊图",
    "section": "",
    "text": "最近在绘制气泡图时，发现点太密集了，想再绘制一个核密度图，来展示数据的分布。\n最先考虑的方案是：将geom_density()和geom_point()合并，创建一个新的geom。由于没有创建过自定义的geom，AI生成的结果不易修改，最终放弃。\n最后想到了ggridges包中可以分组单独绘制密度图，稍加修改得到最总的绘制结果。\n\nlibrary(ggplot2)\nlibrary(ggridges)\n\nset.seed(123)\ndf &lt;- data.frame(\n  category = factor(rep(LETTERS[1:3], each = 100)),\n  value = c(rnorm(100, 0), rnorm(100, 1), rnorm(100, 2))\n)\n\n# 调整 density_ridges 的 scale 参数，并设置点的位置\nggplot(df, aes(x = value, y = category)) +\n  geom_density_ridges(\n    aes(fill = category),\n    scale = 0.4, # 控制密度图的高度（较小值会使密度图更扁平）\n    rel_min_height = 0.01 # 设置最小高度以避免尾部过长\n  ) +\n  geom_point(aes(color = category), size = 5, position = position_nudge(y = -0.2))\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html",
    "href": "Books/Advanced R(2e)/8 Conditions.html",
    "title": "8 Conditions",
    "section": "",
    "text": "情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。\nR 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。\n\n\n\n8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。\n8.3 节介绍最简单的情况处理工具：像try()和suppressMessages()这样的函数，它们会吞噬情况信息并阻止其达到顶层。\n8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的tryCatch()和用于其他一切的withCallingHandlers()。\n8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。\n8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。\n\n\n\n\n本章使用rlang包中的状态信号与处理函数。\n\nlibrary(rlang)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#introduction",
    "href": "Books/Advanced R(2e)/8 Conditions.html#introduction",
    "title": "8 Conditions",
    "section": "",
    "text": "情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。\nR 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。\n\n\n\n8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。\n8.3 节介绍最简单的情况处理工具：像try()和suppressMessages()这样的函数，它们会吞噬情况信息并阻止其达到顶层。\n8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的tryCatch()和用于其他一切的withCallingHandlers()。\n8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。\n8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。\n\n\n\n\n本章使用rlang包中的状态信号与处理函数。\n\nlibrary(rlang)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#signalling-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#signalling-conditions",
    "title": "8 Conditions",
    "section": "Signalling conditions",
    "text": "Signalling conditions\nR 提供了三种情况信号：errors，warnings，messages。\n\nerror：最严重，表示函数无法继续执行，必须终止。\nwarning：次之，表示函数内部某些是错的，但是不影响函数运行。\nmessage：仅用于显示函数内某些动作的状态。\n\n情况系统的信息通常是瞩目的，例如加粗，红色等。\n\nstop(\"This is what an error looks like\")\n#&gt; Error: This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n#&gt; Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n#&gt; This is what a message looks like\n\n\nErrors\nbase R 通过stop()函数抛出错误信息。\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() stop(\"This is an error!\")\n\nf()\n#&gt; Error in h(): This is an error!\n\nstop()函数有参数.call，控制是否进行调用栈朔源（traceback()也可以）。\n\nh &lt;- function() stop(\"This is an error!\", call. = FALSE)\nf()\n#&gt; Error: This is an error!\n\nrlang 包中的abort()与stop()等价，但其功能更加全面，后面我们会继续介绍它。\n\nh &lt;- function() abort(\"This is an error!\")\nf()\n#&gt; Error in `h()`:\n#&gt; ! This is an error!\n\n错误信息最好可以指出哪里处了问题，引导用户改进。但是编写好的错误信息很困难，因为错误通常发生在用户对函数有一个有缺陷的心理模型时。作为开发人员，很难想象用户会如何错误地思考你的函数，因此很难编写一条能够引导用户走向正确方向的信息。\n\n\nWarnings\n警告信息比错误信息弱，它表示程序某些地方出错，但不影响程序正常运行。函数内可以有多条警告信息。\n\nfw &lt;- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\n\n与错误信息不同，警告信息默认在程序运行中缓存，结束后显示。\n\nfw()\n#&gt; 1\n#&gt; Warning in fw(): W1\n#&gt; 2\n#&gt; Warning in fw(): W2\n#&gt; 3\n#&gt; Warning in fw(): W3\n\noptions()可以设置警告信息的行为。\n\noptions(warn = 0)：默认设置。\noptions(warn = 1)：警告信息会立即显示。\noptions(warn = 0)：警告信息视作错误信息。\n\nwarning()函数同样有call.参数，建议设置为FALSE。rlang 中也有类似函数rlang::warn()。\nbase R 中的有些警告信息，作者认为改写为报错信息会给更好。例如：\n\nformals(1)\n#&gt; Warning in formals(fun): argument is not a function\n#&gt; NULL\n\nfile.remove(\"this-file-doesn't-exist\")\n#&gt; Warning in file.remove(\"this-file-doesn't-exist\"): cannot remove file\n#&gt; 'this-file-doesn't-exist', reason 'No such file or directory'\n#&gt; [1] FALSE\n\nlag(1:3, k = 1.5)\n#&gt; Warning in lag.default(1:3, k = 1.5): 'k' is not an integer\n#&gt; [1] 1 2 3\n#&gt; attr(,\"tsp\")\n#&gt; [1] -1  1  1\n\nas.numeric(c(\"18\", \"30\", \"50+\", \"345,678\"))\n#&gt; Warning: NAs introduced by coercion\n#&gt; [1] 18 30 NA NA\n\n有两种情况，使用警告信息会更好：\n\n当你升级了某个函数，但是不推荐使用它时，可以打印一个版本警告信息。\n当你确定可以通过警告信息提醒使用者正确使用函数时。\n\n\n\nMessages\n提示信息由message()函数生成，函数没有call.参数，生成的提示信息会实时打印在控制台。恰到好处的提示信息可以告诉使用者，你的程序运行到了哪里，此刻的运行状态是什么。\n\nfm &lt;- function() {\n  cat(\"1\\n\")\n  message(\"M1\")\n  cat(\"2\\n\")\n  message(\"M2\")\n  cat(\"3\\n\")\n  message(\"M3\")\n}\n\nfm()\n#&gt; 1\n#&gt; M1\n#&gt; 2\n#&gt; M2\n#&gt; 3\n#&gt; M3\n\n下面是一些使用提示信息的情况：\n\n当函数的默认参数值需要一些计算时，你需要告诉使用者计算的情况。例如ggplot中的binwidth参数，如果用户没有指定参数，ggplot会根据数据集自动计算一个合适的参数值。\n当函数调用了其他必要且耗时的函数时，你需要告诉使用者，你的程序正在做什么。\n当函数运行耗时特别长时，你需要提供一个进度条。\n为R包添加加载后的提示信息（使用packageStartupMessage()）。\n\n每个函数都应当有一个quiet = TRUE参数，用来禁用提示信息。\ncat()函数与messages()函数类似，但是cat()函数面向使用者，而messages()函数面向开发者。\n\ncat(\"Hi!\\n\")\n#&gt; Hi!\n\nmessage(\"Hi!\")\n#&gt; Hi!",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#ignoring-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#ignoring-conditions",
    "title": "8 Conditions",
    "section": "Ignoring conditions",
    "text": "Ignoring conditions\nbase R 中忽略三种信息的方法：\n\ntry()：忽略所有错误信息。\nsuppressWarnings()：忽略所有警告信息。\nsuppressMessages()：忽略所有提示信息。\n\n这三种方法的共同缺点是，无法忽略单一某条信息，而保证其他信息通过，它们的作用是全局的。\n\ntry()\n通常函数报错会停止运行，try() 函数可以忽略错误信息，让函数继续执行。\n\nf1 &lt;- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n#&gt; Error in log(x): non-numeric argument to mathematical function\n\nf2 &lt;- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n#&gt; Error in log(x) : non-numeric argument to mathematical function\n#&gt; [1] 10\n\n为了实现根据运行情况（成功或失败）返回不同的值时，不建议将try()的结果直接赋值给变量，而是事先定义变量，然后在try()内部进行赋值。除了try()函数，也可以使用更高级的tryCatch()函数。\n\n# 不推荐\ndefault &lt;- try(read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n#&gt; Warning in file(file, \"rt\"): cannot open file 'possibly-bad-input.csv': No\n#&gt; such file or directory\n# 推荐\ndefault &lt;- NULL\ntry(default &lt;- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\n#&gt; Warning in file(file, \"rt\"): cannot open file 'possibly-bad-input.csv': No\n#&gt; such file or directory\n\n\n\nsuppress*\n\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n#&gt; [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n#&gt; [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n#&gt; You can still see me\n#&gt; [1] 3",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#handling-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#handling-conditions",
    "title": "8 Conditions",
    "section": "Handling conditions",
    "text": "Handling conditions\n每种情况都有默认行为：错误信息终止程序运行，警告信息在程序运行结束后打印，提示信息即时打印。情况处理系统允许我们暂时压制或补充这些默认行为。\nbase R 提供了两个函数 tryCatch() 和 withCallingHandlers() 来处理情况。前者在情况触发时进入到退出函数（exiting handlers），适合处理错误情况；后者在情况触发时会接着运行（calling handlers），适合处理警告和提示情况。\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_run_while_handlers_are_active\n)\n\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_run_while_handlers_are_active\n)\n\nCondition objects\n每种情况触发时，都会创建一个不被我们看到的condition对象，使用rlang::catch_cnd()函数可以查看此对象。\n\n# cnd &lt;- stop(\"An error\") # 也可以，但是会显示报错信息\ncnd &lt;- catch_cnd(stop(\"An error\"))\nstr(cnd)\n#&gt; List of 2\n#&gt;  $ message: chr \"An error\"\n#&gt;  $ call   : language force(expr)\n#&gt;  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\nconditionMessage(cnd)\n#&gt; [1] \"An error\"\nconditionCall(cnd)\n#&gt; force(expr)\n\ncondition对象包含两个元素：\n\nmessage：长度为1的字符串，用来展示信息。可以使用conditionMessage()函数查看。\ncall：触发情况的函数调用，如果参数call. = FALSE则为NULL。可以使用conditionCall()函数查看。\n\n自定义的condition对象也可以包含其他元素。\n该对象同时具有class属性，表示对象属于S3类。\n\n\nExiting handlers\ntryCatch()函数通常用在错误情况处理中，能够覆盖默认的错误行为。例如下面的函数在错误时返回NA。\n\nf3 &lt;- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n#&gt; [1] NA\n\n如果情况没有被触发或不符合定义的condition对象，则会正常运行。\n\ntryCatch(\n  error = function(cnd) 10,\n  1 + 1\n)\n#&gt; [1] 2\n\ntryCatch(\n  error = function(cnd) 10,\n  {\n    message(\"Hi!\")\n    1 + 1\n  }\n)\n#&gt; Hi!\n#&gt; [1] 2\n\ntryCatch()定义的handler称作 exiting handler，因为在情况触发后，程序不会再运行触发情况的代码。\n\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n#&gt; [1] \"There\"\n\n注意：定义的handler是一个函数，它的运行环境与外面代码的运行环境不用。\nhandler函数只接受一个参数——condition对象，可以提取对象中的信息，这对后续介绍的自定义condition对象十分有用。\n\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n#&gt; [1] \"--This is an error--\"\n\n\nfinally\ntryCatch()函数还有一个finally参数，接受一个代码块。其功能类似于on.exit()，无论情况是否触发，都会运行这段代码，通常用来清理缓存，删除临时文件或关闭链接等。\npath &lt;- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)\n\n\n\nCalling handlers\nwithCallingHandlers()函数通常用来处理警告或提示情况。与tryCatch()不同，代码触发情况后，会执行handler函数，待handler函数运行结束后接着运行。这好像中间插入了一段运行代码。\n下面是tryCatch()和withCallingHandlers()的比较：\n\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"),\n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"),\n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#&gt; Caught a message!\n#&gt; Someone there?\n#&gt; Caught a message!\n#&gt; Why, yes!\n\nhandler函数按顺序执行，不必担心内部情况被捕捉，造成死循环。\n\nwithCallingHandlers(\n  message = function(cnd) message(\"Second message\"),\n  message(\"First message\")\n)\n#&gt; Second message\n#&gt; First message\n\n但是要注意：如果有多个handler函数，某些handler函数的情况可能会被其他handler函数捕获，要考虑handler函数的顺序。\n\nwithCallingHandlers( # (1)\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers( # (2)\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#&gt; b\n#&gt; a\n#&gt; b\n#&gt; c\n\n\nmuffle\nwithCallingHandlers()中的handler函数也会返回值，但是与tryCatch()不同，它的返回值没有被使用，calling handler 函数只发挥了它的副作用。其中一个重要副作用就是屏蔽信息。\n当情况处理函数发生嵌套时，会自动触发父级handler函数。\n\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n#&gt; Hello\n\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\n可以使用rlang::cnd_muffle()来屏蔽信息。\n\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1\n#&gt; Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n#&gt; Level 1",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#call-stacks",
    "href": "Books/Advanced R(2e)/8 Conditions.html#call-stacks",
    "title": "8 Conditions",
    "section": "Call stacks",
    "text": "Call stacks\nexiting handler 函数与 calling handler 函数的调用栈不同。\n\nf &lt;- function() g()\ng &lt;- function() h()\nh &lt;- function() message(\"!\")\n\ncalling handler 是在函数f()的调用栈中被调用\n\nwithCallingHandlers(\n  f(),\n  message = function(cnd) {\n    lobstr::cst()\n    cnd_muffle(cnd)\n  }\n)\n#&gt;      ▆\n#&gt;   1. ├─base::withCallingHandlers(...)\n#&gt;   2. ├─global f()\n#&gt;   3. │ └─global g()\n#&gt;   4. │   └─global h()\n#&gt;   5. │     └─base::message(\"!\")\n#&gt;   6. │       ├─base::withRestarts(...)\n#&gt;   7. │       │ └─base (local) withOneRestart(expr, restarts[[1L]])\n#&gt;   8. │       │   └─base (local) doWithOneRestart(return(expr), restart)\n#&gt;   9. │       └─base::signalCondition(cond)\n#&gt;  10. └─global `&lt;fn&gt;`(`&lt;smplMssg&gt;`)\n#&gt;  11.   └─lobstr::cst()\n\nexiting handler 是在函数tryCatch()的调用栈中被调用\n\ntryCatch(\n  f(),\n  message = function(cnd) lobstr::cst()\n)\n#&gt;     ▆\n#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#&gt;  2.   └─base (local) tryCatchList(expr, classes, parentenv, handlers)\n#&gt;  3.     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#&gt;  4.       └─value[[3L]](cond)\n#&gt;  5.         └─lobstr::cst()\n\n\ncatch_cnd(stop(\"An error\"))\n#&gt; &lt;simpleError in force(expr): An error&gt;\ncatch_cnd(abort(\"An error\"))\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! An error\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#custom-conditions",
    "href": "Books/Advanced R(2e)/8 Conditions.html#custom-conditions",
    "title": "8 Conditions",
    "section": "Custom conditions",
    "text": "Custom conditions\nbase R 内置的condition对象包含的信息有限——message和call。rlang包提供了额外的函数——abort(),warn(),inform(),singal()，帮助自定义condition对象。它们的使用方法和base R 中的一样，例如：rlang::abort()通过参数class添加额外的类和附加信息。\n\nabort(\n  class = \"error_not_found\",\n  message = \"Path `blah.csv` not found\",\n  path = \"blah.csv\"\n)\n#&gt; Error:\n#&gt; ! Path `blah.csv` not found\n\n\nMotivation\n下面以base::log()函数为例，阐述自定义condition对象的优势。\n当参数不符合标准时，log()会返回一个错误。\n\nlog(letters)\n#&gt; Error in log(letters): non-numeric argument to mathematical function\nlog(1:10, base = letters)\n#&gt; Error in log(1:10, base = letters): non-numeric argument to mathematical function\n\n上面的报错信息不是很友好，因为它没有具体指出那个参数错误，原因是什么。我们可以进行下面的修改：\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\n\n\nmy_log(letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `x` must be a numeric vector; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `my_log()`:\n#&gt; ! `base` must be a numeric vector; not character.\n\n现在的报错信息就显得用户友好了，但是对于开发者来说不够友好，所有关键信息都被储存在了报错信息中，我们无法函数式地编写这类报错。\n\n\nSignalling\n为了实现上述功能，我们先自定义一个abort()函数：函数通过glue::glue()将附加信息拼接到错误信息中，然后传递到abort()函数中。注意我们定义了一个新condition类型——error_bad_argument。\n\nabort_bad_argument &lt;- function(arg, must, not = NULL) {\n  msg &lt;- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not &lt;- typeof(not)\n    msg &lt;- glue::glue(\"{msg}; not {not}.\")\n  }\n\n  abort(\"error_bad_argument\",\n    message = msg,\n    arg = arg,\n    must = must,\n    not = not\n  )\n}\n\n不基于rlang包，也可以实现上面的功能：\n\nstop_custom &lt;- function(.subclass, message, call = NULL, ...) {\n  err &lt;- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr &lt;- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\n#&gt; [1] \"error_new\" \"error\"     \"condition\"\nerr$x\n#&gt; [1] 10\n\n现在我们可以重新改写my_log()：\n\nmy_log &lt;- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\n\n\nmy_log(letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `x` must be numeric; not character.\nmy_log(1:10, base = letters)\n#&gt; Error in `abort_bad_argument()`:\n#&gt; ! `base` must be numeric; not character.\n\n\n\nHandling\n自定义的condition类十分利于编程。\n我们可以使用testthat中的函数来检测这个类包含的内容是否符合预期：\n\nlibrary(testthat)\n#&gt; \n#&gt; Attaching package: 'testthat'\n#&gt; The following objects are masked from 'package:rlang':\n#&gt; \n#&gt;     is_false, is_null, is_true\n\nerr &lt;- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\n\n自定义的类也可以用在handler函数中：\n\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n#&gt; [1] \"bad_argument\"\n\n需要注意的是，因为自定义的类属于子类，所以无法完美的进行类判断。handler函数的顺序会直接影响类的判断结果。\n\ntryCatch(\n  error = function(cnd) \"other error\",\n  error_bad_argument = function(cnd) \"bad_argument\",\n  my_log(\"a\")\n)\n#&gt; [1] \"other error\"",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/8 Conditions.html#applications",
    "href": "Books/Advanced R(2e)/8 Conditions.html#applications",
    "title": "8 Conditions",
    "section": "Applications",
    "text": "Applications\n本节介绍一些使用tryCatch()和withCallingHandlers()的常见模式。\n\nFailure value\ntryCatch()的errorhandler函数返回默认值。\n\nfail_with &lt;- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n#&gt; [1] 2.302585\nfail_with(log(\"x\"), NA_real_)\n#&gt; [1] NA\n\n创建base::try()的类似函数try2()。\n\ntry2 &lt;- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg &lt;- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n#&gt; [1] 1\ntry2(stop(\"Hi\"))\n#&gt; Error: Hi\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n#&gt; [1] \"Hi\"\n#&gt; attr(,\"class\")\n#&gt; [1] \"try-error\"\n\n\n\nSuccess and failure values\n将上面的模式再进一步改写为：成功返回一个值，失败返回另一个值。\nfoo &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\n也可以改写为检测是否成功：\ndoes_error &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\n还可以捕获condtion对象，类似于rlang::catch_cnd()：\ncatch_cnd &lt;- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd,\n    {\n      expr\n      NULL\n    }\n  )\n}\n利用这一模式，我们可以创建一个try()变体，同时返回错误对象和结果：\n\nsafety &lt;- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n#&gt; List of 2\n#&gt;  $ result: num 11\n#&gt;  $ error : NULL\nstr(safety(stop(\"Error!\")))\n#&gt; List of 2\n#&gt;  $ result: NULL\n#&gt;  $ error :List of 2\n#&gt;   ..$ message: chr \"Error!\"\n#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#&gt;   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\n\n上面的safety()函数类似于purrr::safely()，我们将在11章中讨论它。\n\n\nResignal\n前面讲到可以通过options(warn = 2)将警告转为错误。但这种做法是全局修改，我们可以构造下面的函数，单独将警告转为错误。\n\nwarning2error &lt;- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\n\n\nwarning2error({\n  x &lt;- 2^4\n  warn(\"Hello\")\n})\n#&gt; Error:\n#&gt; ! Hello\n\n这个函数也可以用来查找那些经常出现但有不知道来源的信息，更多信息见22章。\n\n\nRecord\n修改handler函数，实现记录每条信息。\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n\n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; c\n\n如果想捕获错误信息，需要将withCallingHandlers()置于tryCatch()中。\n\ncatch_cnds &lt;- function(expr) {\n  conds &lt;- list()\n  add_cond &lt;- function(cnd) {\n    conds &lt;&lt;- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n\n  tryCatch(\n    error = function(cnd) {\n      conds &lt;&lt;- append(conds, list(cnd))\n    },\n    withCallingHandlers(\n      message = add_cond,\n      warning = add_cond,\n      expr\n    )\n  )\n\n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  abort(\"C\")\n})\n#&gt; [[1]]\n#&gt; &lt;message/rlang_message&gt;\n#&gt; Message:\n#&gt; a\n#&gt; \n#&gt; [[2]]\n#&gt; &lt;warning/rlang_warning&gt;\n#&gt; Warning:\n#&gt; b\n#&gt; \n#&gt; [[3]]\n#&gt; &lt;error/rlang_error&gt;\n#&gt; Error:\n#&gt; ! C\n#&gt; ---\n#&gt; Backtrace:\n#&gt; ▆\n\n这种模式同时也是evaluate包的主要思想，该包用于knitr中。\n\n\nNo default behaviour\n使用rlang::signal()函数可以创建不基于message,warning,error的condition类。\n\nlog &lt;- function(message, level = c(\"info\", \"error\", \"fatal\")) {\n  level &lt;- match.arg(level)\n  signal(message, \"log\", level = level)\n}\n\n因为没有默认的handler函数，log()函数不会打印任何信息。\n\nlog(\"This code was run\")\n\n搭配withCallingHandlers()函数，可以定义一个log的handler函数。\n\nrecord_log &lt;- function(expr, path = stdout()) {\n  withCallingHandlers(\n    log = function(cnd) {\n      cat(\n        \"[\", cnd$level, \"] \", cnd$message, \"\\n\",\n        sep = \"\",\n        file = path, append = TRUE\n      )\n    },\n    expr\n  )\n}\n\nrecord_log(log(\"Hello\"))\n#&gt; [info] Hello\n\n也可以创建一个不显示某个日志级别信息的handler函数。\n\nignore_log_levels &lt;- function(expr, levels) {\n  withCallingHandlers(\n    log = function(cnd) {\n      if (cnd$level %in% levels) {\n        cnd_muffle(cnd)\n      }\n    },\n    expr\n  )\n}\n\nrecord_log(ignore_log_levels(log(\"Hello\"), \"info\"))\n\n如果你手动创建了一个condition对象，并且通过signalCondition()触发，rlang::cnd_muffle()将不会工作。需要搭配withRestarts()。\nwithRestarts(signalCondition(cond), muffle = function() NULL)",
    "crumbs": [
      "8 Conditions"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html",
    "href": "Books/Advanced R(2e)/Functional programming.html",
    "title": "Introduction",
    "section": "",
    "text": "R 在本质上是一种泛函（functional）语言，呈现出一种以函数为中心的问题解决风格。下面我简要概述泛函语言的技术定义，重点讲解泛函编程风格，这对于日常的数据分析十分有用。\n泛函编程风格倾向于创建能够单独运行，便于自动优化或并行化的函数。它的传统缺点，如性能较差和有时不可预测的内存使用，近年来已经大大减少，可以作为面向对象编程的一种补充。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html#functional-programming-languages",
    "href": "Books/Advanced R(2e)/Functional programming.html#functional-programming-languages",
    "title": "Introduction",
    "section": "Functional programming languages",
    "text": "Functional programming languages\n每种编程语言都有函数，那么是什么使一种编程语言具有泛函呢？原因有很多，但有两个比较重要：\n\nfirst-class functions\n所谓第一类函数即是具有其他数据结构特点的函数。在R中，它可以：被赋值给其他变量，储存在list中，传递到其他函数中，被其他函数创建，甚至被函数返回。\n\n\npure function\n纯函数需要满足两个条件：\n\n输入决定输出：只要输入一样，输出就一样。反例：runif(),read.csv(),Sys.time()。\n没有副作用：比如改变全局变量，写入磁盘，在屏幕上显示。反例：print(),write.csv(),&lt;-。\n\n严格将，R 并不是一种泛函编程语言，因为它并不要求你的函数是纯函数。但是当你在编写泛函风格的代码时，你应当尽可能书写纯函数。通常，极端的纯函数或非纯函数更容易理解和改写。",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "Books/Advanced R(2e)/Functional programming.html#functional-style",
    "href": "Books/Advanced R(2e)/Functional programming.html#functional-style",
    "title": "Introduction",
    "section": "Functional style",
    "text": "Functional style\n通俗的讲，泛函编程风格就是讲大问题分割为小问题，每个小问题编写一个函数去解决。解决小问题的函数是简单明了且能独立运行的，你需要做的是按照不同需求组合这些函数。\n接下来的三个章节分别讨论了三种泛函编程技巧：\n\n第9章（functional）：使用泛函编程改写for循环，如lapply()等函数。\n第10章（function factories）：输入向量，输出函数。\n第11章（function operators）：输入函数，输出函数。\n\n\n\n\n\n\n\n\nTip\n\n\n\n注意：图片中的Vector，它可以是任何数据结构，因为R中的所有数据结构都是基于Vector构建的。",
    "crumbs": [
      "Introduction"
    ]
  }
]