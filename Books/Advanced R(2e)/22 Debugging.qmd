---
title: "22 Debugging"
date: "2025-08-23"
date-modified: "2025-08-23"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

当R代码运行时抛出错误，你会怎样处理？你会使用什么工具来检测和解决？本章就上面两点，先介绍通用的错误处理方法，然后介绍一些特殊的工具。

注意：在编写新函数时，你不应该使用这些工具。如果你发现自己经常在新代码中使用这些工具，请重新考虑你的方法。与其试图一次性编写一个大函数，不如交互式地分段编写。如果从小处着手，你可以快速确定为什么某些事情不能正常工作，而不需要复杂的调试工具。

### Outline

-   22.2节：介绍找到和解决bug的通用策略。
-   22.3节：介绍`traceback()`，锁定错误的调用栈。
-   22.4节：介绍中断函数执行，并交互探索具体发生的事件。
-   22.5节：讨论非交互状态下的调试。
-   22.6节：讨论一些偶尔也需要调试的非错误问题。

## Overall approach

::: callout-tip
Finding your bug is a process of confirming the many things that you believe are true — until you find one which is not true.

—Norm Matloff
:::

找到问题的根本原因总是具有挑战性。大多数bug都很微妙且难以发现，因为如果它们很明显，你一开始就会避开它们。一个好的策略会有所帮助。以下是我发现有用的四步流程概述：

1.  **Google!**

    无论何时看到错误消息，都可以先在浏览器上搜索它（现在用AI啦）。如果你幸运的话，你会发现这是一个已知解决方案中常见的错误。在搜索时，通过删除任何与你的问题特定的变量名称或值来提高匹配成功的概率。

    可以使用“errorist”和“searcher”包自动执行这个过程，参阅它们的网站以了解更多详细信息。

2.  **Make it repeatable**

    为了找到错误的根本原因，你需要在考虑和拒绝假设时多次执行代码。为了使迭代尽可能快速，值得进行一些前期投资，使问题既容易又快速地重现。

    首先创建一个可重复的示例 (参见 1.7 节)。接下来，通过删除代码和简化数据来使示例最小化。在这个过程中，你可能会发现一些不会触发错误的输入。请记住这些输入：它们将有助于诊断根本原因。

    如果你正在使用自动化测试，这也是创建自动化测试用例的好时机。如果你现有的测试覆盖率较低，可以趁机添加一些附近的测试，以确保保留现有的良好行为。这样可以降低创建新 bug 的可能性。

3.  **Figure out where it is**

    如果你幸运的话，下一节中的一个工具将帮助你快速识别导致 bug 的代码行。然而，通常情况下，你需要对问题进行更多的思考。采用科学的方法是一个很好的主意。生成假设，设计实验来测试它们，并记录你的结果。这可能看起来是很多工作，但系统的方法最终会节省你的时间。我经常浪费大量时间依靠直觉来解决 bug (“哦，这一定是一个差一错误，所以我就在这里减去 1”), 而实际上我采用系统的方法会更好。

    如果这个方法失败了，你可能需要向其他人寻求帮助。如果你遵循了上一步，你就会有一个容易与他人分享的小例子。这会让其他人更容易看到问题，也更有可能帮助你找到解决方案。

4.  **Fix it and test it**

    一旦你发现了 bug, 你需要弄清楚如何修复它，并检查修复是否真的有效。同样，有自动化测试非常有用。这不仅有助于确保你确实修复了 bug, 还有助于确保你在过程中没有引入任何新的 bug。在没有自动化测试的情况下，请确保仔细记录正确的输出，并检查之前失败的输入。

## Locating errors

一旦你使错误可重复，下一步就是找出它的来源。在这个过程中，最重要的工具是`traceback()`, 它向你显示导致错误的调用序列 (也称为调用栈，见 7.5 节)。

下面是一个简单的例子。你可以看到 `f()` 调用 `g()` 调用 `h()` 调用 `i()`, 后者检查其参数是否为数值：

```{r}
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) {
  if (!is.numeric(d)) {
    stop("`d` must be numeric", call. = FALSE)
  }
  d + 10
}

f("a")
```

当你在Rstudio中运行`f("a")`时，你会看到：

![](images/rstudio-error.png)

错误信息的右侧出现两个选项：“Show Traceback”和“Rerun with Debug”，如果你点击“Show Traceback”，你可以看到：

![](images/rstudio-traceback.png)

如果你没有使用Rstudio，你可以使用`traceback()`来查看这些信息。

```{r}
traceback()
```

::: callout-note
注意：如果你使用`source()`加载的函数，调用`traceback()`后会显示错误的具体未知，`filename.r#linenumber`。
:::

### Lazy evaluation

`traceback()`的一个缺点是始终线性展示调用栈，如果调用过程包含大量的惰性评估，就会显得混乱。例如，在`f()`内惰性评估`j()`产生的调用栈：

```{r}
j <- function() k()
k <- function() stop("Oops!", call. = FALSE)
f(j())
```

```{r}
traceback()
```

可以使用`rlang::abort()`来替代`stop()`，使用`rlang::last_trace()`来替换`traceback()`。

```{r}
k <- function() rlang::abort("Oops!")
f(j())
rlang::last_trace()
```

## Interactive debugger

对于找到并修复错误，有时错误的位置信息已经足够；但通常需要更多信息，最简单的方法是使用交互式调试器，它允许暂停函数的执行，并交互式地探索其状态。

如果你正在使用RStudio, 进入交互式调试器最简单的方式是通过RStudio的“Rerun with Debug” 工具，它会重新运行创建错误的命令，暂停发生错误的执行。否则，你需要在暂停的地方插入一个`browser()`调用，然后重新运行该函数。例如，可以在`g()`中插入一个`browser()`调用：

```{r}
g <- function(b) {
  browser()
  h(b)
}
f(10)
```

`browser()`是一个常规函数，你可以使用`if`语句包裹它：

```{r}
g <- function(b) {
  if (b < 0) {
    browser()
  }
  h(b)
}
```

`browser()`会在终端生成`Browse[1]>`样式的提示，表示你正在`browser()`启动的环境中交互。如果你在Rstudio中点击“Rerun with Debug”，会在环境栏中显示当前环境中的对象，在traceback栏中显示调用栈。

### `browser()` commands

除了可以运行常规R代码外，`browser()`提供了一些特殊的命令，可以直接在终端运行它们的缩写或在Rstudio中工具栏：

![](images/debug-toolbar.png)

-   Next, `n`：运行函数下一步. 如果你有一个变量名是 `n`，你需要运行`print(n)`来展示值。

-   Step into, ![](https://adv-r.hadley.nz/screenshots/step-into.png){width="25" height="18"} or `s`：功能类似next，但是如果下一步运行的是函数，会跳入到该函数中进行交互。

-   Finish, ![](https://adv-r.hadley.nz/screenshots/finish-loop.png){width="25" height="18"} or `f`：结束当前循环或函数。

-   Continue, `c`：如果你已经修复了错误状态，并想要检查函数是否正常运行，运行它，会离开交互式调试，继续正常执行函数。

-   Stop, `Q`：停止调试，终止函数，然后返回全局工作空间。一旦你确定了问题所在，并且准备好修复它并重新加载代码，就可以使用这个方法。

还有两个稍微不那么有用且在工具栏中不可用的命令：

-   Enter：重复之前的命令。该功能极易激活，使用`options(browserNLdisabled = TRUE)`可以将其关闭。

-   `where`：打印活动调用的堆栈跟踪 (相当于Rstudio交互式 的traceback) 。

### Alternatives

有三种替代`browser()`的方法：在Rstudio中设置断点、`options(error = recover)`、`debug()`。

#### Breakpoints

在Rstudio中，你可以点击左侧代码行或者使用`Shift + F9`来设置断点。设置断点相当于你在这行代码中插入了`browser()`。这样，你可以直观地看到插入的断点，也可以无需在源码中插入`browser()`来调试。但它有两个小缺点：

-   有极少的情况下，断点会失效。阅读[breakpoint troubleshooting](http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting)了解更多信息。

-   目前Rstudio不支持在条件情况中设置断点。

#### `recover()`

设置`options(error = recover)`后，报错时会自动进入交互式调试。设置`options(error = NULL)`即可恢复默认行为。

```{r}
options(error = recover)
f("x")
```

#### `debug()`

另一种方法是调用一个能插入`browser()`的函数：

-   `debug()`插入`browser()`到函数`f`的开头，`undebug()`移除，`debugonce()`仅在下一次调用函数时触发，再次调用消失。

-   `utils::setBreakpoint()`与`debug()`类似，除函数名外，还可以接受行数、文件名找到恰当的函数。

这两个函数都是`trace()`的特殊情况，它在现有函数中的任意位置插入任意代码。当调试没有源代码的代码时，`trace()`偶尔会很有用。要从函数中移除“trace”，可以使用`untrace()`。每个函数只能执行一个“trace”, 但这一个“trace”可以调用多个函数。

#### Call stack

不幸地是，[`traceback()`](https://rdrr.io/r/base/traceback.html), [`browser()`](https://rdrr.io/r/base/browser.html) & `where`, and [`recover()`](https://rdrr.io/r/utils/recover.html) 产生的调用栈并不一致。下表是对上面`f("a")`调用栈的总结。

| [`traceback()`](https://rdrr.io/r/base/traceback.html) | `where` | [`recover()`](https://rdrr.io/r/utils/recover.html) | rlang functions |
|:---|:---|:---|:---|
| `5: stop("...")` |  |  |  |
| `4: i(c)` | `where 1: i(c)` | `1: f()` | `1. └─global::f(10)` |
| `3: h(b)` | `where 2: h(b)` | `2: g(a)` | `2. └─global::g(a)` |
| `2: g(a)` | `where 3: g(a)` | `3: h(b)` | `3. └─global::h(b)` |
| `1: f("a")` | `where 4: f("a")` | `4: i("a")` | `4. └─global::i("a")` |

在RStudio展示的调用顺序与[`traceback()`](https://rdrr.io/r/base/traceback.html)一致；“rlang”函数产生的调用顺序与[`recover()`](https://rdrr.io/r/utils/recover.html)一致。

### Compiled code

编译代码 (如 C 或 C++)也可以使用交互式调试器 (gdb 或 lldb) 。遗憾的是，这超出了本书的范围，但有一些资源你可能会发现很有用。

-   <http://r-pkgs.had.co.nz/src.html#src-debugging>

-   <https://github.com/wch/r-debug/blob/master/debugging-r.md>

-   <http://kevinushey.github.io/blog/2015/04/05/debugging-with-valgrind/>

-   <https://www.jimhester.com/2018/08/22/debugging-rstudio/>

## Non-interactive debugging

