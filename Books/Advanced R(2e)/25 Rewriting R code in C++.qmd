---
title: "25 Rewriting R code in C++"
date: "2025-08-30"
date-modified: "2025-08-30"

format:
  html:
    code-link: true

fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

有时，即便你找出来代码的运行瓶颈，同时做了所有可以在R中做的优化，运行依然很慢。这仅仅是因为R本身就是慢（🤦‍）。本章介绍如何使用“Rcpp”包实现用C++重写关键函数来提升性能。

“Rcpp”包提供了干净可及的API来实现C++与R之间的链接，同时隔离R本身的复杂的C的API。虽然它也可以用来些C或Fortran代码，但相较C++稍显痛苦。

C++可以用来解析下面典型的瓶颈：

-   无法轻易向量化的循环，因为后续迭代依赖于先前的迭代。

-   递归函数，或者涉及调用函数数百万次的问题。在C++中调用函数的开销比在R中低得多。

-   需要使用R没有提供的高级数据结构和算法的问题。通过标准模板库（STL），C++高效地实现了许多重要的数据结构，从有序映射到双端队列。

本章的目的是仅讨论C++和“Rcpp”的那些绝对必要的方面，以帮助消除代码中的瓶颈。我们不会在面向对象编程或模板等高级功能上花费太多时间，因为重点是编写小型、自包含的函数，而不是大型程序。C++的工作知识是有用的，但不是必不可少的。许多优秀的教程和参考资料可以免费获得，包括http://www.learncpp.com/和https://en.cppreference.com/w/cpp。对于更高级的主题，Scott Meyers的“Effective C++”系列是一个受欢迎的选择。

### Outline

-   25.2节：介绍如何将简单的R函数转换为等价的C++函数，并以此介绍C++与R的不同之处。
-   25.2.5小节：介绍如何使用`sourceCpp()`函数加载C++代码。
-   25.3节：介绍如何修改“Rcpp”中的属性，和一些其他重要的类。
-   25.4节：介绍如何在C++中处理R的缺失值。
-   25.5节：介绍如何使用标准模板库中的一些重要数据结构和算法。
-   25.6节：介绍两个使用“Rcpp”极大提升性能的例子。
-   25.7节：介绍如何将C++代码添加到R包中。
-   25.8节：介绍更多有关“Rcpp”的资源。

### Prerequisites

```{r}
library(Rcpp)
```

我们需要一个C++的编译环境：

-   Windows：安装[Rtools](http://cran.r-project.org/bin/windows/Rtools/)。
-   Mac：安装Xcode。
-   Linux：`sudo apt-get install r-base-dev`

## Getting started with C++

`cppFunction()`允许直接在R中编写C++代码：

```{r}
cppFunction(
  "
  int add(int x, int y, int z) {
    int sum = x + y + z;
    return sum;
  }
  "
)
# add works like a regular R function
add
add(1, 2, 3)
```

运行这段代码时，“Rcpp”会编译C++代码，并将R函数`add`与C++函数`add`关联起来。关联过程的大量底层细节被“Rcpp”自行处理了。下面我们以不同的例子，由浅入深地介绍C++的语法。

### No inputs, scalar output

让我们以一个非常简单的函数开始——没有任何参数，总是返回整数1：

```r
one <- function() 1L
```

等价的C++函数：

```cpp
int one() {
  return 1;
}
```

使用`cppFunction()`实现在R中使用这个C++函数：

```{r}
cppFunction(
  "
  int one() {
    return 1;
  }
  "
)
```

上面的示例展示了R与C++之间的一些主要区别：

-   创建函数的语法与调用函数的语法类似；不像在R中那样使用赋值来创建函数。
-   必须声明函数返回结果的类型。
-   标量（scalar）与向量（vector）不同。R中的数字、整数、字符、逻辑向量的对应符号是：`NumericVector`、`IntegerVector`、`CharacterVector`、`LogicalVector`。标量的对应符号是：`double`、`int`、`String`、`bool`。
-   必须有清晰的`return`声明来返回值。
-   每个声明必须以分号`;`结束。

### Scalar input, scalar output

第二个例子是`sign()`函数的标量版本，接受一个标量输入，当输入为正数时返回1，为0时返回0，为负数时返回-1：

```r
signR <- function(x) {
  if (x > 0) {
    1
  } else if (x == 0) {
    0
  } else {
    -1
  }
}

cppFunction(
  "
  int signC(int x) {
    if (x > 0) {
      return 1;
    } else if (x == 0) {
      return 0;
    } else {
      return -1;
    }
  }
 "
)
```

C++版的函数中：

-   函数的输入与输出一样，也需要声明类型。
-   `if`语句的语法一样，退出可以使用`break`，但是跳过需要使用`continue`而非`next` 。

### Vector input, scalar output

R与C++有一个显著的不同是在for循环的资源消耗上，C++更低。例如，在for循环中执行`sum`函数：

R版本：

```{r}
sumR <- function(x) {
  total <- 0
  for (i in seq_along(x)) {
    total <- total + x[i]
  }
  total
}
```

C++版本：

```{r}
cppFunction(
  "
  double sumC(NumericVector x) {
    int n = x.size();
    double total = 0;
    for(int i = 0; i < n; ++i) {
      total += x[i];
    }
    return total;
  }
  "
)
```

C++版与R版本在结构上很相似，但：

-   获取向量长度，C++通过`.size()`方法完成。C++通过`.`来调用方法。

-   `for`的声明语法不一样：`for(init; check; increment)`。额外设置变量`i`，判断`i`与`n`的比较。

-   C++中位置索引的起始是0。

-   使用`=`赋值，而不是`<-`。

-   C++提供原位修改运算符：`total += x[i]`。除此还有`-=`、`*=`、`/=`。

```{r}
x <- runif(1e3)
bench::mark(
  sum(x),
  sumC(x),
  sumR(x)
)[1:6]
```

### Vector input, vector output

下面我们创建一个计算单个值与向量的欧几里得距离：

R版本：

```{r}
pdistR <- function(x, ys) {
  sqrt((x - ys)^2)
}
```

在R中，我们没有在函数中定义`x`是标量，而是在文档中明确说明这一点。在C++版本中，则必须明确说明类型：

```{r}
cppFunction(
  "
  NumericVector pdistC(double x, NumericVector ys) {
    int n = ys.size();
    NumericVector out(n);

    for(int i = 0; i < n; ++i) {
      out[i] = sqrt(pow(ys[i] - x, 2.0));
    }

    return out;
  }
  "
)
```

这个C++函数引入了一些新概念：

-   创建一个长度为`n`的数字向量需要构造器：`NumericVector out(n)`。拷贝一个需要：`NumericVector zs = clone(ys)`。

-   使用`pow()`而非`^`计算幂。

```{r}
y <- runif(1e6)
bench::mark(
  pdistR(0.5, y),
  pdistC(0.5, y)
)[1:6]
```

上面的结果显示，C++并没有比R快多少，节约的时间与开发C++函数的时间相比不值一提。而且C++运行快速的真正原因是它只是用了零时标量`ys[i] -x`，而R使用了临时向量`x - ys`，额外分配的内存会占用大量时间。

### Using sourceCpp

在实际开发中，我们往往需要使用`sourceCpp()`来单独加载C++脚本。在使用支持C++的IDE编写脚本可以提供语法高亮，自动补齐，语法检查等功能。

独立的C++脚本需要加载`.cpp`插件：

```cpp
#include <Rcpp.h>
using namespace Rcpp;
```

同时每个函数前需要声明`// [[Rcpp::export]]`才可以被R调用。

你也可以在C++注释块中插入R代码，在测试时，会被执行并在R终端输出结果（因为`source(echo = TRUE)`）：

```cpp
/*** R
# This is R code
*/
```

运行`sourceCpp("path/to/file.cpp")`会创建对应的R函数，并加载到当前环境。需要注意：这些函数无法被保存在`.Rdata`文件中，每次启动R都需要重新创建。

例如，运行`sourceCpp()`加载下面的脚本，会创建一个名为`meanC`的函数，并加载到当前环境：

```cpp
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double meanC(NumericVector x) {
  int n = x.size();
  double total = 0;

  for(int i = 0; i < n; ++i) {
    total += x[i];
  }
  return total / n;
}

/*** R
x <- runif(1e5)
bench::mark(
  mean(x),
  meanC(x)
)
*/
```

在Rmarkdown中，可以设置`{r, engine = "Rcpp"}`进行编译，所以后续的C++函数定义都单独放在一个代码块中，此时不能添加注释了哦。

## Other classes