---
title: "25 Rewriting R code in C++"
date: "2025-08-30"
date-modified: "2025-08-30"

format:
  html:
    code-link: true

fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

有时，即便你找出来代码的运行瓶颈，同时做了所有可以在R中做的优化，运行依然很慢。这仅仅是因为R本身就是慢（🤦‍）。本章介绍如何使用“Rcpp”包实现用C++重写关键函数来提升性能。

“Rcpp”包提供了干净可及的API来实现C++与R之间的链接，同时隔离R本身的复杂的C的API。虽然它也可以用来些C或Fortran代码，但相较C++稍显痛苦。

C++可以用来解析下面典型的瓶颈：

-   无法轻易向量化的循环，因为后续迭代依赖于先前的迭代。

-   递归函数，或者涉及调用函数数百万次的问题。在C++中调用函数的开销比在R中低得多。

-   需要使用R没有提供的高级数据结构和算法的问题。通过标准模板库（STL），C++高效地实现了许多重要的数据结构，从有序映射到双端队列。

本章的目的是仅讨论C++和“Rcpp”的那些绝对必要的方面，以帮助消除代码中的瓶颈。我们不会在面向对象编程或模板等高级功能上花费太多时间，因为重点是编写小型、自包含的函数，而不是大型程序。C++的工作知识是有用的，但不是必不可少的。许多优秀的教程和参考资料可以免费获得，包括http://www.learncpp.com/和https://en.cppreference.com/w/cpp。对于更高级的主题，Scott Meyers的“Effective C++”系列是一个受欢迎的选择。

### Outline

-   25.2节：介绍如何将简单的R函数转换为等价的C++函数，并以此介绍C++与R的不同之处。
-   25.2.5小节：介绍如何使用`sourceCpp()`函数加载C++代码。
-   25.3节：介绍如何修改“Rcpp”中的属性，和一些其他重要的类。
-   25.4节：介绍如何在C++中处理R的缺失值。
-   25.5节：介绍如何使用标准模板库中的一些重要数据结构和算法。
-   25.6节：介绍两个使用“Rcpp”极大提升性能的例子。
-   25.7节：介绍如何将C++代码添加到R包中。
-   25.8节：介绍更多有关“Rcpp”的资源。

### Prerequisites

```{r}
library(Rcpp)
```

我们需要一个C++的编译环境：

-   Windows：安装[Rtools](http://cran.r-project.org/bin/windows/Rtools/)。
-   Mac：安装Xcode。
-   Linux：`sudo apt-get install r-base-dev`

## Getting started with C++

`cppFunction()`允许直接在R中编写C++代码：

```{r}
cppFunction(
  "
  int add(int x, int y, int z) {
    int sum = x + y + z;
    return sum;
  }
  "
)
# add works like a regular R function
add
add(1, 2, 3)
```

运行这段代码时，“Rcpp”会编译C++代码，并将R函数`add`与C++函数`add`关联起来。关联过程的大量底层细节被“Rcpp”自行处理了。下面我们由浅入深地介绍如何将简单地R函数转换为C++函数。

### No inputs, scalar output

让我们以一个非常简单的函数开始——没有任何参数，总是返回整数1：

```r
one <- function() 1L
```

等价的C++函数：

```c
int one() {
  return 1;
}
```

使用`cppFunction()`实现在R中使用这个C++函数：

```{r}
cppFunction(
  "
  int one() {
    return 1;
  }
  "
)
```

上面的示例展示了R与C++之间的一些主要区别：

-   创建函数的语法与调用函数的语法类似；不像在R中那样使用赋值来创建函数。
-   必须声明函数返回结果的类型。
-   标量（scalar）与向量（vector）不同。R中的数字、整数、字符、逻辑向量的对应符号是：`NumericVector`、`IntegerVector`、`CharacterVector`、`LogicalVector`。标量的对应符号是：`double`、`int`、`String`、`bool`。
-   必须有清晰的`return`声明来返回值。
-   每个声明必须以分号`;`结束。

### Scalar input, scalar output

第二个例子是`sign()`函数的标量版本，接受一个标量输入，当输入为正数时返回1，为0时返回0，为负数时返回-1：

```r
signR <- function(x) {
  if (x > 0) {
    1
  } else if (x == 0) {
    0
  } else {
    -1
  }
}

cppFunction(
  "
  int signC(int x) {
    if (x > 0) {
      return 1;
    } else if (x == 0) {
      return 0;
    } else {
      return -1;
    }
  }
 "
)
```

C++版的函数中：

-   函数的输入与输出一样，也需要声明类型。
-   `if`语句的语法一样，退出可以使用`break`，但是跳过需要使用`continue`而非`next` 。
-   `return`语句必须放在函数的末尾。

### Vector input, scalar output

第三个例子是`sign()`函数的向量版本，接受一个向量输入，返回一个向量输出，向量中的每个元素都对应输入向量的元素。


