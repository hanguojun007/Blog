---
title: "8 Conditions.qmd"
author: "大番薯本薯"
date: "2025-07-05"
date-modified: "2025-07-05"

format: "html"
fig-width: 4
fig-height: 4
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n:6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  error: true
  warning: true
---

## Introduction

情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。

R 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。

### Outline

-   8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。
-   8.3 节介绍最简单的情况处理工具：像`try()`和`suppressMessages()`这样的函数，它们会吞噬情况信息并阻止其达到顶层。
-   8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的`tryCatch()`和用于其他一切的`withCallingHandlers()`。
-   8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。
-   8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。

### Prerequisites

本章使用rlang包中的状态信号与处理函数。

```{r}
library(rlang)
```

## Signalling conditions

R 提供了三种情况信号：errors，warnings，messages。

-   error：最严重，表示函数无法继续执行，必须终止。
-   warning：次之，表示函数内部某些是错的，但是不影响函数运行。
-   message：仅用于显示函数内某些动作的状态。

情况系统的信息通常是瞩目的，例如加粗，红色等。

```{r}
stop("This is what an error looks like")

warning("This is what a warning looks like")

message("This is what a message looks like")
```

### Errors

base R 通过`stop()`函数抛出错误信息。

```{r}
f <- function() g()
g <- function() h()
h <- function() stop("This is an error!")

f()
```

`stop()`函数有参数`.call`，控制是否进行调用栈朔源（`traceback()`也可以）。

```{r}
h <- function() stop("This is an error!", call. = FALSE)
f()
```

rlang 包中的`abort()`与`stop()`等价，但其功能更加全面，后面我们会继续介绍它。

```{r}
h <- function() abort("This is an error!")
f()
```

错误信息最好可以指出哪里处了问题，引导用户改进。但是编写好的错误信息很困难，因为错误通常发生在用户对函数有一个有缺陷的心理模型时。作为开发人员，很难想象用户会如何错误地思考你的函数，因此很难编写一条能够引导用户走向正确方向的信息。

### Warnings

警告信息比错误信息弱，它表示程序某些地方出错，但不影响程序正常运行。函数内可以有多条警告信息。

```{r}
fw <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warning("W3")
}
```

与错误信息不同，警告信息默认在程序运行中缓存，结束后显示。

```{r}
fw()
```

`options()`可以设置警告信息的行为。

-   `options(warn = 0)`：默认设置。
-   `options(warn = 1)`：警告信息会立即显示。
-   `options(warn = 0)`：警告信息视作错误信息。

`warning()`函数同样有`call.`参数，建议设置为`FALSE`。rlang 中也有类似函数`rlang::warn()`。

base R 中的有些警告信息，作者认为改写为报错信息会给更好。例如：

```{r}
formals(1)

file.remove("this-file-doesn't-exist")

lag(1:3, k = 1.5)

as.numeric(c("18", "30", "50+", "345,678"))
```

有两种情况，使用警告信息会更好：

-   当你升级了某个函数，但是不推荐使用它时，可以打印一个版本警告信息。

-   当你确定可以通过警告信息提醒使用者正确使用函数时。

### Messages

提示信息由`message()`函数生成，函数没有`call.`参数，生成的提示信息会实时打印在控制台。恰到好处的提示信息可以告诉使用者，你的程序运行到了哪里，此刻的运行状态是什么。

```{r}
fm <- function() {
  cat("1\n")
  message("M1")
  cat("2\n")
  message("M2")
  cat("3\n")
  message("M3")
}

fm()
```

下面是一些使用提示信息的情况：

-   当函数的默认参数值需要一些计算时，你需要告诉使用者计算的情况。例如ggplot中的`binwidth`参数，如果用户没有指定参数，ggplot会根据数据集自动计算一个合适的参数值。

-   当函数调用了其他必要且耗时的函数时，你需要告诉使用者，你的程序正在做什么。

-   当函数运行耗时特别长时，你需要提供一个进度条。

-   为R包添加加载后的提示信息（使用`packageStartupMessage()`）。

每个函数都应当有一个`quiet = TRUE`参数，用来禁用提示信息。

`cat()`函数与`messages()`函数类似，但是`cat()`函数面向使用者，而`messages()`函数面向开发者。

```{r}
cat("Hi!\n")

message("Hi!")
```

## Ignoring conditions

base R 中忽略三种信息的方法：

-   `try()`：忽略所有错误信息。
-   `suppressWarnings()`：忽略所有警告信息。
-   `suppressMessages()`：忽略所有提示信息。

这三种方法的共同缺点是，无法忽略单一某条信息，而保证其他信息通过，它们的作用是全局的。

### try()

通常函数报错会停止运行，`try()` 函数可以忽略错误信息，让函数继续执行。

```{r}
f1 <- function(x) {
  log(x)
  10
}
f1("x")

f2 <- function(x) {
  try(log(x))
  10
}
f2("a")
```

为了实现根据运行情况（成功或失败）返回不同的值时，不建议将`try()`的结果直接赋值给变量，而是事先定义变量，然后在`try()`内部进行赋值。除了`try()`函数，也可以使用更高级的`tryCatch()`函数。

```{r}
# 不推荐
default <- try(read.csv("possibly-bad-input.csv"), silent = TRUE)
# 推荐
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
```

### suppress*

```{r}
suppressWarnings({
  warning("Uhoh!")
  warning("Another warning")
  1
})

suppressMessages({
  message("Hello there")
  2
})

suppressWarnings({
  message("You can still see me")
  3
})
```

## Handling conditions

每种情况都有默认行为：错误信息终止程序运行，警告信息在程序运行结束后打印，提示信息即时打印。情况处理系统允许我们暂时压制或补充这些默认行为。

base R 提供了两个函数 `tryCatch()` 和 `withCallingHandlers()` 来处理情况。前者在情况触发时进入到退出函数（exiting handlers），适合处理错误情况；后者在情况触发时会接着运行（calling handlers），适合处理警告和提示情况。

```r
tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning is signalled
  },
  message = function(cnd) {
    # code to run when message is signalled
  },
  code_to_run_while_handlers_are_active
)
```

### Condition objects

每种情况触发时，都会创建一个不被我们看到的`condition`对象，使用`rlang::catch_cnd()`函数可以查看此对象。

```{r}
# cnd <- stop("An error") # 也可以，但是会显示报错信息
cnd <- catch_cnd(stop("An error"))
str(cnd)

conditionMessage(cnd)
conditionCall(cnd)
```

`condition`对象包含两个元素：

-   `message`：长度为1的字符串，用来展示信息。可以使用`conditionMessage()`函数查看。
-   `call`：触发情况的函数调用，如果参数`call. = FALSE`则为`NULL`。可以使用`conditionCall()`函数查看。

自定义的`condition`对象也可以包含其他元素。

该对象同时具有`class`属性，表示对象属于`S3`类。

### Exiting handlers

`tryCatch()`函数通常用在错误情况处理中，能够覆盖默认的错误行为。例如下面的函数在错误时返回`NA`。

```{r}
f3 <- function(x) {
  tryCatch(
    error = function(cnd) NA,
    log(x)
  )
}

f3("x")
```

如果情况没有被触发或不符合定义的`condition`对象，则会正常运行。

```{r}
tryCatch(
  error = function(cnd) 10,
  1 + 1
)

tryCatch(
  error = function(cnd) 10,
  {
    message("Hi!")
    1 + 1
  }
)
```

`tryCatch()`定义的handler称作 **exiting** handler，因为在情况触发后，程序不会再运行触发情况的代码。

```{r}
tryCatch(
  message = function(cnd) "There",
  {
    message("Here")
    stop("This code is never run!")
  }
)
```

注意：定义的handler是一个函数，它的运行环境与外面代码的运行环境不用。

handler函数只接受一个参数——`condition`对象，可以提取对象中的信息，这对后续介绍的自定义`condition`对象十分有用。

```{r}
tryCatch(
  error = function(cnd) {
    paste0("--", conditionMessage(cnd), "--")
  },
  stop("This is an error")
)
```

#### finally

`tryCatch()`函数还有一个`finally`参数，接受一个代码块。其功能类似于`on.exit()`，无论情况是否触发，都会运行这段代码，通常用来清理缓存，删除临时文件或关闭链接等。

```r
path <- tempfile()
tryCatch(
  {
    writeLines("Hi!", path)
    # ...
  },
  finally = {
    # always run
    unlink(path)
  }
)
```

### Calling handlers

`withCallingHandlers()`函数通常用来处理警告或提示情况。与`tryCatch()`不同，代码触发情况后，会执行handler函数，待handler函数运行结束后接着运行。这好像中间插入了一段运行代码。

下面是`tryCatch()`和`withCallingHandlers()`的比较：

```{r}
tryCatch(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)

withCallingHandlers(
  message = function(cnd) cat("Caught a message!\n"),
  {
    message("Someone there?")
    message("Why, yes!")
  }
)
```

handler函数按顺序执行，不必担心内部情况被捕捉，造成死循环。但是要注意：如果有多个handler函数，某些handler函数的情况可能会被其他handler函数捕获，要考虑handler函数的顺序。

```{r}
withCallingHandlers(
  message = function(cnd) message("Second message"),
  message("First message")
)
```

#### muffle

`withCallingHandlers()`中的handler函数也会返回值，但是与`tryCatch()`不同，它的返回值没有被使用，**calling** handler 函数只发挥了它的副作用。其中一个重要副作用就是屏蔽信息。

当情况处理函数发生嵌套时，会自动触发父级handler函数。

```{r}
# Bubbles all the way up to default handler which generates the message
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)

# Bubbles up to tryCatch
tryCatch(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)
```

可以使用`rlang::cnd_muffle()`来屏蔽信息。

```{r}
# Muffles the default handler which prints the messages
withCallingHandlers(
  message = function(cnd) {
    cat("Level 2\n")
    cnd_muffle(cnd)
  },
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    message("Hello")
  )
)

# Muffles level 2 handler and the default handler
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) {
      cat("Level 1\n")
      cnd_muffle(cnd)
    },
    message("Hello")
  )
)
```

## Call stacks