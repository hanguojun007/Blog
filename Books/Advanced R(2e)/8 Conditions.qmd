---
title: "8 Conditions.qmd"
author: "大番薯本薯"
date: "2025-07-05"
date-modified: "2025-07-05"
format: "html"
fig-width: 4
fig-height: 4
fig-align: center
execute:
  error: true
  warning: true
---
```{r}
#| echo: false

source("_common.R")
```

## Introduction

情况系统（Condition System）包含两部分，一方面是函数内部根据不同情况生成不同等级的信息，另一方面是函数使用者根据返回的信息进行不同的处理。

R 提供了一个基于 Common Lisp 思想的非常强大的情况系统。本章介绍 R 情况系统的主要思想，以及一些实用工具，这些工具将使你的代码更加健壮。

### Outline

-   8.2 节介绍了情况系统的基本工具，并讨论了何时适合使用每种工具。
-   8.3 节介绍最简单的情况处理工具：像`try()`和`suppressMessages()`这样的函数，它们会吞噬情况信息并阻止其达到顶层。
-   8.4 节介绍了情况对象，以及两个基本的情况处理工具：用于错误情况的`tryCatch()`和用于其他一切的`withCallingHandlers()`。
-   8.5 节展示了如何扩展内置情况对象，以存储情况处理程序可用于做出更明智决策的有用数据。
-   8.6 节以一系列基于前面章节中提到的低级工具的实际应用程序作为本章的结尾。

### Prerequisites

本章使用rlang包中的状态信号与处理函数。

```{r}
library(rlang)
```

## Signalling conditions

R 提供了三种情况信号：errors，warnings，messages。

-   error：最严重，表示函数无法继续执行，必须终止。
-   warning：次之，表示函数内部某些是错的，但是不影响函数运行。
-   message：仅用于显示函数内某些动作的状态。

情况系统的信息通常是瞩目的，例如加粗，红色等。

```{r}
stop("This is what an error looks like")

warning("This is what a warning looks like")

message("This is what a message looks like")
```

### Errors

base R 通过`stop()`函数抛出错误信息。

```{r}
f <- function() g()
g <- function() h()
h <- function() stop("This is an error!")

f()
```

`stop()`函数有参数`.call`，控制是否进行调用栈朔源（`traceback()`也可以）。

```{r}
h <- function() stop("This is an error!", call. = FALSE)
f()
```

rlang 包中的`abort()`与`stop()`等价，但其功能更加全面，后面我们会继续介绍它。

```{r}
h <- function() abort("This is an error!")
f()
```

错误信息最好可以指出哪里处了问题，引导用户改进。但是编写好的错误信息很困难，因为错误通常发生在用户对函数有一个有缺陷的心理模型时。作为开发人员，很难想象用户会如何错误地思考你的函数，因此很难编写一条能够引导用户走向正确方向的信息。

### Warnings

警告信息比错误信息弱，它表示程序某些地方出错，但不影响程序正常运行。函数内可以有多条警告信息。

```{r}
fw <- function() {
  cat("1\n")
  warning("W1")
  cat("2\n")
  warning("W2")
  cat("3\n")
  warning("W3")
}
```

与错误信息不同，警告信息默认在程序运行中缓存，结束后显示。

```{r}
fw()
```

`options()`可以设置警告信息的行为。

-   `options(warn = 0)`：默认设置。
-   `options(warn = 1)`：警告信息会立即显示。
-   `options(warn = 0)`：警告信息视作错误信息。

`warning()`函数同样有`call.`参数，建议设置为`FALSE`。rlang 中也有类似函数`rlang::warn()`。

base R 中的有些警告信息，作者认为改写为报错信息会给更好。例如：

```{r}
formals(1)

file.remove("this-file-doesn't-exist")

lag(1:3, k = 1.5)

as.numeric(c("18", "30", "50+", "345,678"))
```

有两种情况，使用警告信息会更好：

-   当你升级了某个函数，但是不推荐使用它时，可以打印一个版本警告信息。

-   当你确定可以通过警告信息提醒使用者正确使用函数时。

### Messages

提示信息由`message()`函数生成，函数没有`call.`参数，生成的提示信息会实时打印在控制台。恰到好处的提示信息可以告诉使用者，你的程序运行到了哪里，此刻的运行状态是什么。

```{r}
fm <- function() {
  cat("1\n")
  message("M1")
  cat("2\n")
  message("M2")
  cat("3\n")
  message("M3")
}

fm()
```

下面是一些使用提示信息的情况：

-   当函数的默认参数值需要一些计算时，你需要告诉使用者计算的情况。例如ggplot中的`binwidth`参数，如果用户没有指定参数，ggplot会根据数据集自动计算一个合适的参数值。

-   当函数调用了其他必要且耗时的函数时，你需要告诉使用者，你的程序正在做什么。

-   当函数运行耗时特别长时，你需要提供一个进度条。

-   为R包添加加载后的提示信息（使用`packageStartupMessage()`）。

每个函数都应当有一个`quiet = TRUE`参数，用来禁用提示信息。

`cat()`函数与`messages()`函数类似，但是`cat()`函数面向使用者，而`messages()`函数面向开发者。

```{r}
cat("Hi!\n")

message("Hi!")
```

## Ignoring conditions

base R 中忽略三种信息的方法：

-   `try()`：忽略所有错误信息。
-   `suppressWarnings()`：忽略所有警告信息。
-   `suppressMessages()`：忽略所有提示信息。

这三种方法的共同缺点是，无法忽略单一某条信息，而保证其他信息通过，它们的作用是全局的。

### try()

通常函数报错会停止运行，`try()` 函数可以忽略错误信息，让函数继续执行。

```{r}
f1 <- function(x) {
  log(x)
  10
}
f1("x")

f2 <- function(x) {
  try(log(x))
  10
}
f2("a")
```

为了实现根据运行情况（成功或失败）返回不同的值时，不建议将`try()`的结果直接赋值给变量，而是事先定义变量，然后在`try()`内部进行赋值。除了`try()`函数，也可以使用更高级的`tryCatch()`函数。

```{r}
# 不推荐
default <- try(read.csv("possibly-bad-input.csv"), silent = TRUE)
# 推荐
default <- NULL
try(default <- read.csv("possibly-bad-input.csv"), silent = TRUE)
```

### suppress*

```{r}
suppressWarnings({
  warning("Uhoh!")
  warning("Another warning")
  1
})

suppressMessages({
  message("Hello there")
  2
})

suppressWarnings({
  message("You can still see me")
  3
})
```

## Handling conditions

每种情况都有默认行为：错误信息终止程序运行，警告信息在程序运行结束后打印，提示信息即时打印。情况处理系统允许我们暂时压制或补充这些默认行为。

base R 提供了两个函数 `tryCatch()` 和 `withCallingHandlers()` 来处理情况。前者适合处理错误情况，后者适合处理警告和提示情况。

```r
tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning is signalled
  },
  message = function(cnd) {
    # code to run when message is signalled
  },
  code_to_run_while_handlers_are_active
)
```

### Condition objects

