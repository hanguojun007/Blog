---
title: "19 Quasiquotation"
date: "2025-08-11"
date-modified: "2025-08-14"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

准引用（**quasiquotation**）包括两部分——引用和解引用，引用就是我们上章介绍过的捕获“表达式”，解引用相当于“评估”“表达式”。但是要注意，**解引用函数只在引用函数内有效**，它的目的是“评估”要捕获的“表达式”中的部分元素。准引用使得组合“函数创建者的函数”与“函数使用者的函数”更加容易。

准引用是组成tidy-evaluation的三大基石之一（quosures和data-mask将在下章介绍），在tidy-evaluation中，所有支持引用的函数都支持解引用。

### Outline

-   19.2节：通过一个示例函数——`cement()`介绍为什么使用准引用。
-   19.3节：介绍引用函数。
-   19.4节：介绍解引用函数。
-   19.5节：讨论base R中类似的“解引用”。
-   19.6节：介绍使用`!!!`的另外两种情况。
-   19.7节：介绍一些示例。

### Prerequisites

需要熟悉第17，18章的内容。

```{r}
library(rlang)
library(purrr)
```

### Related work

引用函数与Lisp语言中的宏紧密相关。宏通常在编译时运行，这在R中不存在，并且它的输出也是AST结构。引用函数与更为深奥的Lisp **fexprs**关系更为密切，后者是默认引用所有参数的函数。当在其他编程语言中寻找相关工作时，了解这些术语是有用的。

## Motivation

我们将从一个具体的例子开始，激发准引用的使用需求。假设你要创建一个类似`paste()`的函数：

```{r}
paste("Good", "morning", "Hadley")
paste("Good", "afternoon", "Alice")
```

如果你厌倦了每次都输入引号“"”，那么你可以创建下面的函数（后续会详细介绍如何使用）：

```{r}
cement <- function(...) {
  args <- ensyms(...)
  paste(purrr::map(args, as_string), collapse = " ")
}

cement(Good, morning, Hadley)
cement(Good, afternoon, Alice)
```

上面的函数使得我们无需在每个字符两边添加引号，但它有个问题是：当我们使用变量指代字符时，它无法识别变量。`paste()`函数则可以正常识别

```{r}
name <- "Hadley"
time <- "morning"

cement(Good, time, name)
paste("Good", time, name)
```

我们可以使用特殊的解引符号`!!`处理上面这种情况：

```{r}
cement(Good, !!time, !!name)
```

::: callout-note
上面的示例可能具有误导性。前面我们讲到过，常量的“表达式”就是常量，所以`"Hadley"`等价于`expr("Hadley")`，`!!`始终作用的是一个“表达式”，并且它会被传入到`ensyms()`中，也即**解引函数始终在引用函数内生效**。

引用函数`ensyms()`的返回值是一个表达式，我们可以对他进行“评估”或`as_string()`，但这些都已经不属于准引用的范畴了。
:::

### Vocabulary

“引用”与“评估”参数之间的不同是重要的：

-   一个被评估的参数遵循R的常规评估规则。
-   一个被引用的参数被保存为表达式，遵循自定义的处理规则。

上面的`paste()`的参数被评估，`cement()`的参数被引用。

如果你不确定一个参数是被评估还是被引用，你可以在函数外面的环境中允许这个参数，如果报错，那么这个参数被引用。例如：

```{r}
# works
library(MASS)

# fails
MASS
```

## Quoting

准引用的第一个部分是引用——捕获表达式但不进行评估。引用相关的函数通常是成对出现，因为要考虑直接引用和间接引用（函数中的惰性评估）。本节首先介绍“rlang”中的引用函数，然后介绍base R中的。

### Capturing expressions

捕获表达式的函数有四个：

|   | 单个引用 | 多个引用 |
|------------------------|------------------------|------------------------|
| 交互场景 | [`expr()`](https://rlang.r-lib.org/reference/expr.html) | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| 函数场景 | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

在交互场景下，`expr()`和`exprs()`都直接捕获它们的参数，前者捕获单个参数，后者捕获多个参数。

```{r}
expr(x + y)
expr(1 / 2 / 3)

exprs(x = x^2, y = y^3, z = z^4)
# shorthand for
# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))
```

在函数场景下，因为惰性评估的原因，需要使用额外的函数`enexpr()`和`enexprs()`。

```{r}
# expr 直接捕获参数
f1 <- function(x) expr(x)
f1(a + b + c)

# exprs 捕获函数的参数评估后的结果
f2 <- function(x) enexpr(x)
f2(a + b + c)
```

捕获特殊参数`...`的结果只能使用`enexprs()`。

```{r}
f <- function(...) enexprs(...)
f(x = 1, y = 10 * z)
```

### Capturing symbols

`ensym()`和`ensyms()`函数是`enexpr()`和`enexprs()`的变体，专门用于捕获符号或将字符串转换为符号，输入不符合时会报错。

```{r}
f <- function(...) ensyms(...)
f(x)
f("x")
```

### With base R

上述讲到的函数在base R中都有对应的等价函数，它们之间的主要不同是base R中的函数不支持解引用。

| base R | rlang |
|:----------------------------------:|:----------------------------------:|
| [`quote()`](https://rdrr.io/r/base/substitute.html) | [`expr()`](https://rlang.r-lib.org/reference/expr.html) |
| [`alist()`](https://rdrr.io/r/base/list.html) | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| [`substitute()`](https://rdrr.io/r/base/substitute.html) | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| `as.list(substitute(...()))` | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

```{r}
quote(x + y)

alist(x = 1, y = x + 2)

f3 <- function(x) substitute(x)
f3(x + y)

f <- function(...) as.list(substitute(...()))
f(x = 1, y = 10 * z)
```

除此之外，base R中还有两个重要的引用函数：

-   `bquote()`：提供了有限的准引用形式，将在19.5节中讨论。
-   `~`：能够捕获环境的引用函数，将在20.3.4中讨论。

### Substitution

`substitute()`函数除了执行“引用”的功能外，还执行“替换”的功能。

```{r}
f4 <- function(x) substitute(x * 2)
f4(a + b + c)
```

如果你在交互场景中使用它的“替换”功能时，推荐添加第二个参数来指定哪些是要替换的。

```{r}
substitute(x * y * z, list(x = 10, y = quote(a + b)))
```

### Summary

在使用引用功能时，你始终要注意两点：

-   要引用的对象是固定（交互场景）还是不固定的（函数场景）。

-   要引用单个还是多个。

|   | Developer | User |
|------------------------|------------------------|------------------------|
| One | [`expr()`](https://rlang.r-lib.org/reference/expr.html) | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| Many | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

|   | Developer | User |
|------------------------|------------------------|------------------------|
| One | [`quote()`](https://rdrr.io/r/base/substitute.html) | [`substitute()`](https://rdrr.io/r/base/substitute.html) |
| Many | [`alist()`](https://rdrr.io/r/base/list.html) | `as.list(substitute(...()))` |

## Unquoting

解引用允你许选择性地评估“表达式”中的部分内容，其余仍然被引用。这样，你可以使用一个AST模板去生成其他AST。base R需要使用另外的技术来实现，我们将在19.5中介绍。

与解引用类似的是`eval()`函数（20章），但他们是不同的，解引用在引用函数内使用——`expr(!!x)`，评估实在函数外使用——`eval(expr(x))`，它们最终的结果也可能不同。

### Unquoting one argument

`!!`会“评估”一个“表达式”，并返回的值插入到整体的“表达式”中：

```{r}
x <- expr(-1)
expr(f(!!x, y))
```

下面是`!!`运行的底层逻辑示例图：

![](images/bang-bang.png)

`!!`当然也可以作用于符号或常量：

```{r}
a <- sym("y")
b <- 1
expr(f(!!a, !!b))
```

![](images/bang-bang-symbol.png)

`!!`作用于返回“表达式”的函数：

```{r}
mean_rm <- function(var) {
  var <- ensym(var)
  expr(mean(!!var, na.rm = TRUE))
}
expr(!!mean_rm(x) + !!mean_rm(y))
```

`!!`会保留操作符的优先级：

```{r}
x1 <- expr(x + 1)
x2 <- expr(x + 2)

expr(!!x1 / !!x2)
```

![](images/bang-bang-infix.png)

如果我们只是简单地将表达式的文本粘贴在一起，我们最终会得到`x + 1 / x + 2`，这是完全不同的AST:

![](images/infix-bad.png)

### Unquoting a function

通常`!!`用来解引用参数，但是`!!`也可以用来解引用函数。需要注意的是`expr(!!f(x))`解引用的是`f(x)`，需要使用额外的括号表示解引函数——`expr((!!f)(x))`。

```{r}
f <- expr(foo)
expr((!!f)(x, y))
```

函数`f`来自于包的写法也可以：

```{r}
f <- expr(pkg::foo)
expr((!!f)(x, y))
```

![](images/fun.png)

上面的代码也可以使用`rlang::call2()`改写：

```{r}
f <- expr(pkg::foo)
call2(f, expr(x), expr(y))
```

### Unquoting a missing argument

在极少数情况下，我们需要解引用缺失值参数（missing argument），但直接解引用会失效：

```{r}
arg <- missing_arg()
expr(foo(!!arg, !!arg))
```

我们需要使用`rlang::maybe_missing()`来处理缺失值参数：

```{r}
expr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))
```

### Unquoting in special forms

某些函数的infix形式的解引用会失败，例如`$`：它必须始终跟随变量名称，而不是其他表达式，强制使用会报错：

```{r}
x <- expr(x)
expr(df$!!x)
```

需要将函数转变为prefix形式：

```{r}
x <- expr(x)
expr(`$`(df, !!x))
```

### Unquoting many arguments

`!!`是一对一地解引用，`!!!`是一对多的解引用。可以是“表达式”列表或带name属性的向量和列表。

```{r}
xs <- exprs(1, a, -b)
expr(f(!!!xs, y))

# Or with names
ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
```

![](images/bang-bang-bang.png)

`!!!`也可以应用在`call2()`中：

```{r}
call2("f", !!!xs, expr(y))
```

### The polite fiction of `!!`

`!!`和`!!!`与R中的类似`+`,`-`,`!`等运算符不同，在R的视角里，`!!`就是运行了两次的`!`：

```{r}
!!TRUE
!!!TRUE
```

`!!`和`!!!`必须在准引用函数中才能变得类似`+`,`-`,`!`等运算符。在准引用函数外使用，会被视为`!`作用于“表达式”，导致报错：

```{r}
x <- quote(variable)
!!x
```

但是因为`!`可以作用于数字，所以有时会产生错误的结果：

```{r}
df <- data.frame(x = 1:5)
y <- 100
with(df, x + !!y)
```

### Non-standard ASTs

在解引用时，可能会轻易地创建出非标准的AST，例如解引用的对象不是“表达式”时。这些非标准AST是有效的，偶尔也很有用，但它们的正确使用超出了本书的范围。然而，了解它们很重要，因为它们可能会被解析，从而以误导性的方式被打印出来。

例如，如果你内联更复杂的对象，它们的属性就不会打印出来。这可能会导致输出混乱：

```{r}
x1 <- expr(class(!!data.frame(x = 10)))
x1
eval(x1)
```

有两个工具可以消除这种混乱：`rlang::expr_print()`和`lobstr::ast()`:

```{r}
expr_print(x1)
lobstr::ast(!!x1)
```

另外一种插入整数语句造成地混乱：

```{r}
x2 <- expr(f(!!c(1L, 2L, 3L, 4L, 5L)))
x2
expr_print(x2)
lobstr::ast(!!x2)
```

也可以创建由于运算符优先级而无法从代码中生成的常规AST。在这种情况下，R将打印AST中不存在的括号：

```{r}
x3 <- expr(1 + !!expr(2 + 3))
x3

lobstr::ast(!!x3)
```

## Non-quoting

base R中的`bquote()`函数支持准引用，使用`.()`来解引用。

```{r}
xyz <- bquote(x + y + z)
bquote(-.(xyz) / 2)
```

但`bquote()`函数在base R中并没有被广泛使用，也没有对R的书写方式产生任何轻微的影响。主要有三个原因：

-   它无法将创作者的函数和使用者的函数组合在一起，只适合自己使用。
-   它不支持解引用多个表达式。
-   它不支持提供的环境及在环境中处理代码。

base R中具有引用参数功能的函数使用的其他技术路径（不是`bquote()`），在需要“解引用”时，它们选择性地关闭引用功能，不是真正的“解引用”，这里称之为**非引用**。

引用与非引用在base R中有四种基本形式：

-   成对出现的引用和非引用函数。例如，`$`有两个参数，第二个参数引用的。把`mtcars$cyl`写成prefix型式`` `$`(mtcars, cyl) ``，就会很容易发现它的引用特性。更直接的对比是非引用函数`[[`：

```{r}
x <- list(var = 1, y = 2)
var <- "y"

x$var
x[[var]]
```

base R中还有三个与`$`紧密相关的函数：`subset()`、`transform()`和`with()`。它们被视为仅适用于交互场景使用的`$`包装，因此都具有相同的非引用替代函数：`[<-`/`assign()`、`::`/`getExportedValue()`。

-   成对出现的引用和非引用参数。例如，`rm()`函数允许在`...`中使用引用参数或在`list`中提供非引用参数。同样的还有`data()`,`save()`等。

```{r}
x <- 1
rm(x)

y <- 2
vars <- c("y", "vars")
rm(list = vars)
```

-   通过某个参数控制另外一个参数是否是引用的。例如，`library()`函数的`character.only`参数控制`package`参数是否是引用的。同样的还有`demo()`,`detach()`,`example()`,`require()`。

```{r}
library(MASS)

pkg <- "MASS"
library(pkg, character.only = TRUE)
```

-   进行尝试，如果评估失败尝试引用。例如，`help()`函数的第一个参数要求是非引用的字符串，如果评估失败会尝试引用参数。同样的还有`ls()`,`page()`,`match.fun()`。

```{r}
# Shows help for var
help(var)

var <- "mean"
# Shows help for mean
help(var)

var <- 10
# Shows help for var
help(var)
```

base R中另一类重要的引用函数是建模和绘图函数，它们遵循所谓的[**标准非标准评估规则**](http://developer.r-project.org/nonstandard-eval.pdf)。例如，`lm()`函数的`formula`参数，绘图函数`plot()`中的映射类参数`col`,`cex`,`pch`等等。

```{r}
palette(RColorBrewer::brewer.pal(3, "Set1"))
plot(
  Sepal.Length ~ Petal.Length,
  data = iris,
  col = Species,
  pch = 20,
  cex = 2
)
```

## `...`(dot-dot-dot)

本节介绍两种常见的使用`!!!`和`:=`的场景。

-   使用`!!!`解引用参数，释放到`...`中。考虑下面的数据框列表，如果要按行合并它们，你可以直接使用`rbind(dfs$a, dfs$b)`，但如果list中包含多个数据框呢，或者数量未知呢？

```{r}
dfs <- list(
  a = data.frame(x = 1, y = 2),
  b = data.frame(x = 3, y = 4)
)
```

可以使用`!!!`直接解引用参数，释放到`...`中。

```{r}
dplyr::bind_rows(!!!dfs)
```

在这种情况下使用时，`!!!`的行为在Ruby、Go、PHP和Julia中被称为“splatting”。它与Python中的`*args(star-args)`和`*kwarg(star-star-kwargs)`密切相关，这些行为有时被称为参数解包。

-   如何自定义符号的名字。例如，你想创建一个单列的数据框，并且它的列名由变量`var`决定，你可以使用`setNames(data.frame(val), var)`，但这样并不“优雅”。

```{r}
var <- "x"
val <- c(4, 3, 9)
```

可以使用`:=`可以在`=`的左边解引用参数：

```{r}
tibble::tibble(!!var := val)
```

因为R不支持使用“表达式”作为参数名称，所以使用了新的操作符`:=`：

```{r}
tibble::tibble(!!var = val)
```

作者称支持这些无需引用参数工具的函数，都有**tidy dots**。创建具有**tidy dots**的函数只需要使用`list2()`。

### Examples

下面是一个设置属性函数的例子，它允许我们灵活的设置属性。

```{r}
set_attr <- function(.x, ...) {
  attr <- rlang::list2(...)
  attributes(.x) <- attr
  .x
}

attrs <- list(x = 1, y = 2)
attr_name <- "z"

1:10 %>%
  set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
  str()
```

### `exec()`

如果你想再没有**tidy-dots**的函数中使用`!!!`和`:=`，你可以使用`exec()`。它的使用方法与`call2()`类似，但`call2()`返回“表达式”，而`exec()`直接评估了“表达式”。

使用`!!!`解析参数列表：

```{r}
# Directly
exec("mean", x = 1:10, na.rm = TRUE, trim = 0.1)

# Indirectly
args <- list(x = 1:10, na.rm = TRUE, trim = 0.1)
exec("mean", !!!args)

# Mixed
params <- list(na.rm = TRUE, trim = 0.1)
exec("mean", x = 1:10, !!!params)
```

使用`:=`解析不固定参数：

```{r}
arg_name <- "na.rm"
arg_val <- TRUE
exec("mean", 1:10, !!arg_name := arg_val)
```

`exec()`也可以和泛函配合使用：

```{r}
x <- c(runif(10), NA)
funs <- c("mean", "median", "sd")

purrr::map_dbl(funs, exec, x, na.rm = TRUE)
```

### `dots_list()`

`list2()`提供了一个方便的功能：它会自动忽略最后一个空参数。这意味你可以在诸如`tibble::tibble()`这样的函数中不必理会最后一个元素后的逗号。

```{r}
# Can easily move x to first entry:
tibble::tibble(
  y = 1:5,
  z = 3:-1,
  x = 5:1,
) %>%
  dplyr::mutate(
    a = 1:5,
    b = 5:1,
    c = 1:5,
  )

# Need to remove comma from z and add comma to x
data.frame(
  y = 1:5,
  z = 3:-1,
  x = 5:1
)
```

`list2()`函数是对`rlang::dots_list()`函数的封装，设置了一些常用设置为默认值。你可以直接使用`dots_list()`函数进行个性化的设置。

-   `.ignore_empty`参数控制忽略哪些参数。默认情况下，设置`ignore_empty = "trailing"`会忽略最后一个空参数，这会导致上述行为，但你可以选择忽略所有缺失的参数（`"all"`），或者不忽略任何缺失的参数（`"none"`）。

-   `.homonyms`参数控制同名参数的处理。

```{r}
str(dots_list(x = 1, x = 2))
str(dots_list(x = 1, x = 2, .homonyms = "first"))
str(dots_list(x = 1, x = 2, .homonyms = "last"))
str(dots_list(x = 1, x = 2, .homonyms = "error"))
```

-   如果存在未被忽略的空参数，`.preserve_empty`控制如何处理它们。默认情况下会抛出一个错误；设置`.preserve_empty = TRUE`则会返回缺失符号。如果使用`dots_list()`生成函数调用，这将很有用。

### With base R

base R 提供了一个瑞士军刀般的函数——`do.call()`。该函数接受两个参数，首个参数`what`接受一个函数名，第二个参数`args`接受一个参数列表。例如，`do.call("f", list(x, y ,z))`等价于`f(x, y, z)`。

-   `do.call()`解决`rbind()`多个数据框：

```{r}
do.call("rbind", dfs)
```

-   `do.call()`解决变量名的问题：

```{r}
args <- list(val)
names(args) <- var

do.call("data.frame", args)
```

一些base R中的函数（`interaction()`, `expand.grid()`, `options()`, `par()`）使用了一种技巧去规避使用`do.call()`：如果`...`中的第一个参数是列表，则直接使用这个列表，跳过`...`中的剩余参数。

```r
f <- function(...) {
  dots <- list(...)
  if (length(dots) == 1 && is.list(dots[[1]])) {
    dots <- dots[[1]]
  }

  # Do something
  ...
}
```

`RCurl::getURL()`函数采取了另外一种技巧：同时处理`...`和`.dots`。

```r
f <- function(..., .dots) {
  dots <- c(list(...), .dots)
  # Do something
}
```

## Case studies

为了使准引用的概念具体化，本节包含一些用它来解决实际问题的小案例，这些案例还使用了`purrr`。

### `lobstr::ast()`

准引用使得`lobstr::ast()`的输入可以是一个“表达式”。

```{r}
z <- expr(foo(x, y))
lobstr::ast(z)

lobstr::ast(!!z)
```

### Map-reduce to generate code

准引用赋予了我们强大的“生成”代码的能力，尤其是与`purrr::map()`及`purrr::reduce()`结合使用时。例如，假设你有一个由以下系数指定的线性模型，你需要将其转换为一个函数式——`10 + (x1 * 5) + (x2 * -4)`。

```{r}
intercept <- 10
coefs <- c(x1 = 5, x2 = -4)
```

你可以遵循以下步骤构建函数式：

-   首先使用`rlang::syms()`将名称`x1`,`x2`转换为符号列表。

```{r}
coef_sym <- syms(names(coefs))
coef_sym
```

-   然后使用`rlang::expr()`和`purrr::map2()`将系数与对应的未知数组合。

```{r}
summands <- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))
summands
```

-   最后使用`purrr::reduce()`将所有项组合成一个表达式。

```{r}
reduce(c(intercept, summands), ~ expr(!!.x + !!.y))
```

### Slicing an array

base R中缺少一个根据给定维度和索引从数组中提取切片的函数。例如，编写函数`slice(x, 2, 1)`即`x[, 1, ]`，实现沿着第二个维度提取第一个切片。这是一个略具挑战性的问题，因为它要处理缺失的参数。

我们采取的策略是首先默认全都是缺失的参数，然后根据提供的维度和索引，替换缺失的参数。

```{r}
indices <- rep(list(missing_arg()), 3)
expr(x[!!!indices])

indices[[2]] <- 1
expr(x[!!!indices])
```

我们可以进一步优化为一个函数：

```{r}
slice <- function(x, along, index) {
  stopifnot(length(along) == 1)
  stopifnot(length(index) == 1)

  nd <- length(dim(x))
  indices <- rep(list(missing_arg()), nd)
  indices[[along]] <- index

  expr(x[!!!indices])
}

x <- array(sample(30), c(5, 2, 3))
slice(x, 1, 3)
slice(x, 2, 2)
slice(x, 3, 1)
```

一个真实的`slice()`函数会在第20章中介绍。

### Creating functions

另外一个有用的应用是使用`rlang::new_function()`“手动”创建函数，创建函数的三要素——参数，主题，环境。

```{r}
new_function(
  exprs(x = , y = ),
  expr({
    x + y
  })
)
```

注意：`exprs()`中的空参数产生没有默认值的函数参数。

`new_function()`一个用法是作为函数工厂的替代，例如之前讲到的幂函数：

```{r}
power <- function(exponent) {
  new_function(
    exprs(x = ),
    expr({
      x^!!exponent
    }),
    caller_env()
  )
}
power(0.5)
```

`new_function()`的另一个用法是用于类似`graphics::curve()`这样的函数，它能够绘制数学表达式，而无需创建函数。

```{r}
curve(sin(exp(4 * x)), n = 1000)
```

在这段代码中，`x`是一个代词：它不表示单一的具体值，而是一个在图形范围内变化的占位符。实现`curve()`的一种方法是将该表达式转换为一个带有单个参数`x`的函数，然后调用该函数。

```{r}
curve2 <- function(expr, xlim = c(0, 1), n = 100) {
  expr <- enexpr(expr)
  f <- new_function(exprs(x = ), expr)

  x <- seq(xlim[1], xlim[2], length = n)
  y <- f(x)

  plot(x, y, type = "l", ylab = expr_text(expr))
}
curve2(sin(exp(4 * x)), n = 1000)

f <- new_function(exprs(x = ), expr(sin(exp(4 * x))))

```

像`curve()`这样使用包含代词的表达式的函数被称为指代函数（**anaphoric functions**）。
