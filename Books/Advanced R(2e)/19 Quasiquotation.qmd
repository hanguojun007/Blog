---
title: "19 Quasiquotation"
date: "2025-08-11"
date-modified: "2025-08-12"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

准引用（**quasiquotation**）包括两部分——引用和解引用，引用就是我们上章介绍过的捕获“表达式”，解引用相当于“评估”“表达式”。但是要注意，**解引用函数只在引用函数内有效**，它的目的是“评估”要捕获的“表达式”中的部分元素。准引用使得组合“函数创建者的函数”与“函数使用者的函数”更加容易。

准引用是组成tidy-evaluation的三大基石之一（quosures和data-mask将在下章介绍），在tidy-evaluation中，所有支持引用的函数都支持解引用。

### Outline

-   19.2节：通过一个示例函数——`cement()`介绍为什么使用准引用。
-   19.3节：介绍引用函数。
-   19.4节：介绍解引用函数。
-   19.5节：讨论base R中类似的“解引用”。
-   19.6节：介绍使用`!!!`的另外两种情况。
-   19.7节：介绍一些示例。
-   19.8节：介绍准引用的历史。

### Prerequisites

需要熟悉第17，18章的内容。

```{r}
library(rlang)
library(purrr)
```

### Related work

引用函数与Lisp语言中的宏紧密相关。宏通常在编译时运行，这在R中不存在，并且它的输出也是AST结构。引用函数与更为深奥的Lisp **fexprs**关系更为密切，后者是默认引用所有参数的函数。当在其他编程语言中寻找相关工作时，了解这些术语是有用的。

## Motivation

我们将从一个具体的例子开始，激发准引用的使用需求。假设你要创建一个类似`paste()`的函数：

```{r}
paste("Good", "morning", "Hadley")
paste("Good", "afternoon", "Alice")
```

如果你厌倦了每次都输入引号“"”，那么你可以创建下面的函数（后续会详细介绍如何使用）：

```{r}
cement <- function(...) {
  args <- ensyms(...)
  paste(purrr::map(args, as_string), collapse = " ")
}

cement(Good, morning, Hadley)
cement(Good, afternoon, Alice)
```

上面的函数使得我们无需在每个字符两边添加引号，但它有个问题是：当我们使用变量指代字符时，它无法识别变量。`paste()`函数则可以正常识别

```{r}
name <- "Hadley"
time <- "morning"

cement(Good, time, name)
paste("Good", time, name)
```

我们可以使用特殊的解引符号`!!`处理上面这种情况：

```{r}
cement(Good, !!time, !!name)
```

::: callout-note
上面的示例可能具有误导性。前面我们讲到过，常量的“表达式”就是常量，所以`"Hadley"`等价于`expr("Hadley")`，`!!`始终作用的是一个“表达式”，并且它会被传入到`ensyms()`中，也即**解引函数始终在引用函数内生效**。

引用函数`ensyms()`的返回值是一个表达式，我们可以对他进行“评估”或`as_string()`，但这些都已经不属于准引用的范畴了。
:::

### Vocabulary

“引用”与“评估”参数之间的不同是重要的：

-   一个被评估的参数遵循R的常规评估规则。
-   一个被引用的参数被保存为表达式，遵循自定义的处理规则。

上面的`paste()`的参数被评估，`cement()`的参数被引用。

如果你不确定一个参数是被评估还是被引用，你可以在函数外面的环境中允许这个参数，如果报错，那么这个参数被引用。例如：

```{r}
# works
library(MASS)

# fails
MASS
```

## Quoting

准引用的第一个部分是引用——捕获表达式但不进行评估。引用相关的函数通常是成对出现，因为要考虑直接引用和间接引用（函数中的惰性评估）。本节首先介绍“rlang”中的引用函数，然后介绍base R中的。

### Capturing expressions

捕获表达式的函数有四个：

|   | 单个引用 | 多个引用 |
|------------------------|------------------------|------------------------|
| 交互场景 | [`expr()`](https://rlang.r-lib.org/reference/expr.html) | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| 函数场景 | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

在交互场景下，`expr()`和`exprs()`都直接捕获它们的参数，前者捕获单个参数，后者捕获多个参数。

```{r}
expr(x + y)
expr(1 / 2 / 3)

exprs(x = x^2, y = y^3, z = z^4)
# shorthand for
# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))
```

在函数场景下，因为惰性评估的原因，需要使用额外的函数`enexpr()`和`enexprs()`。

```{r}
# expr 直接捕获参数
f1 <- function(x) expr(x)
f1(a + b + c)

# exprs 捕获函数的参数评估后的结果
f2 <- function(x) enexpr(x)
f2(a + b + c)
```

捕获特殊参数`...`的结果只能使用`enexprs()`。

```{r}
f <- function(...) enexprs(...)
f(x = 1, y = 10 * z)
```

### Capturing symbols

`ensym()`和`ensyms()`函数是`enexpr()`和`enexprs()`的变体，专门用于捕获符号或将字符串转换为符号，输入不符合时会报错。

```{r}
f <- function(...) ensyms(...)
f(x)
f("x")
```

### With base R

上述讲到的函数在base R中都有对应的等价函数，它们之间的主要不同是base R中的函数不支持解引用。

| base R | rlang |
|:----------------------------------:|:----------------------------------:|
| [`quote()`](https://rdrr.io/r/base/substitute.html) | [`expr()`](https://rlang.r-lib.org/reference/expr.html) |
| [`alist()`](https://rdrr.io/r/base/list.html) | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| [`substitute()`](https://rdrr.io/r/base/substitute.html) | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| `as.list(substitute(...()))` | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

```{r}
quote(x + y)

alist(x = 1, y = x + 2)

f3 <- function(x) substitute(x)
f3(x + y)

f <- function(...) as.list(substitute(...()))
f(x = 1, y = 10 * z)
```

除此之外，base R中还有两个重要的引用函数：

-   `bquote()`：提供了有限的准引用形式，将在19.5节中讨论。
-   `~`：能够捕获环境的引用函数，将在20.3.4中讨论。

### Substitution

`substitute()`函数除了执行“引用”的功能外，还执行“替换”的功能。

```{r}
f4 <- function(x) substitute(x * 2)
f4(a + b + c)
```

如果你在交互场景中使用它的“替换”功能时，推荐添加第二个参数来指定哪些是要替换的。

```{r}
substitute(x * y * z, list(x = 10, y = quote(a + b)))
```

### Summary

在使用引用功能时，你始终要注意两点：

-   要引用的对象是固定（交互场景）还是不固定的（函数场景）。

-   要引用单个还是多个。

|   | Developer | User |
|----|----|----|
| One | [`expr()`](https://rlang.r-lib.org/reference/expr.html) | [`enexpr()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |
| Many | [`exprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) | [`enexprs()`](https://rlang.r-lib.org/reference/defusing-advanced.html) |

|   | Developer | User |
|----|----|----|
| One | [`quote()`](https://rdrr.io/r/base/substitute.html) | [`substitute()`](https://rdrr.io/r/base/substitute.html) |
| Many | [`alist()`](https://rdrr.io/r/base/list.html) | `as.list(substitute(...()))` |

## Unquoting

解引用允你许选择性地评估“表达式”中的部分内容，其余仍然被引用。这样，你可以使用一个AST模板去生成其他AST。base R需要使用另外的技术来实现，我们将在19.5中介绍。

与解引用类似的是`eval()`函数（20章），但他们是不同的，解引用在引用函数内使用——`expr(!!x)`，评估实在函数外使用——`eval(expr(x))`，它们最终的结果也可能不同。

### Unquoting one argument

`!!`会“评估”一个“表达式”，并返回的值插入到整体的“表达式”中：

```{r}
x <- expr(-1)
expr(f(!!x, y))
```

下面是`!!`运行的底层逻辑示例图：

![](images/bang-bang.png)

`!!`当然也可以作用于符号或常量：

```{r}
a <- sym("y")
b <- 1
expr(f(!!a, !!b))
```

![](images/bang-bang-symbol.png)

`!!`作用于返回“表达式”的函数：

```{r}
mean_rm <- function(var) {
  var <- ensym(var)
  expr(mean(!!var, na.rm = TRUE))
}
expr(!!mean_rm(x) + !!mean_rm(y))
```

`!!`会保留操作符的优先级：

```{r}
x1 <- expr(x + 1)
x2 <- expr(x + 2)

expr(!!x1 / !!x2)
```

![](images/bang-bang-infix.png)

如果我们只是简单地将表达式的文本粘贴在一起，我们最终会得到`x + 1 / x + 2`，这是完全不同的AST:

![](images/infix-bad.png)

### Unquoting a function

通常`!!`用来解引用参数，但是`!!`也可以用来解引用函数。需要注意的是`expr(!!f(x))`解引用的是`f(x)`，需要使用额外的括号表示解引函数——`expr((!!f)(x))`。

```{r}
f <- expr(foo)
expr((!!f)(x, y))
```

函数`f`来自于包的写法也可以：

```{r}
f <- expr(pkg::foo)
expr((!!f)(x, y))
```

![](images/fun.png)

上面的代码也可以使用`rlang::call2()`改写：

```{r}
f <- expr(pkg::foo)
call2(f, expr(x), expr(y))
```

### Unquoting a missing argument

在极少数情况下，我们需要解引用缺失值参数（missing argument），但直接解引用会失效：

```{r}
arg <- missing_arg()
expr(foo(!!arg, !!arg))
```

我们需要使用`rlang::maybe_missing()`来处理缺失值参数：

```{r}
expr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))
```

### Unquoting in special forms

某些函数的infix形式的解引用会失败，例如`$`：它必须始终跟随变量名称，而不是其他表达式，强制使用会报错：

```{r}
x <- expr(x)
expr(df$!!x)
```

需要将函数转变为prefix形式：

```{r}
x <- expr(x)
expr(`$`(df, !!x))
```

### Unquoting many arguments

`!!`是一对一地解引用，`!!!`是一对多的解引用。可以是“表达式”列表或带name属性的向量和列表。

```{r}
xs <- exprs(1, a, -b)
expr(f(!!!xs, y))

# Or with names
ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
```

![](images/bang-bang-bang.png)

`!!!`也可以应用在`call2()`中：

```{r}
call2("f", !!!xs, expr(y))
```

### The polite fiction of `!!`

`!!`和`!!!`与R中的类似`+`,`-`,`!`等运算符不同，在R的视角里，`!!`就是运行了两次的`!`：

```{r}
!!TRUE
!!!TRUE
```

`!!`和`!!!`必须在准引用函数中才能变得类似`+`,`-`,`!`等运算符。在准引用函数外使用，会被视为`!`作用于“表达式”，导致报错：

```{r}
x <- quote(variable)
!!x
```

但是因为`!`可以作用于数字，所以有时会产生错误的结果：

```{r}
df <- data.frame(x = 1:5)
y <- 100
with(df, x + !!y)
```

### Non-standard ASTs


```{r}
epxr(!!data.frame(x = 10))

lobstr::ast(!!data.frame(x = 10))
```

