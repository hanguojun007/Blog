---
title: "23 Measuring performance"
date: "2025-08-26"
date-modified: "2025-08-26"

format:
  html:
    code-link: true

fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

::: {.callout-tip}
Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered.

— Donald Knuth
:::

在你想让代码运行得更快之前，首先需要弄清楚是什么让它变慢。这听起来很简单，但实际上并非如此。即使是有经验的程序员，也很难找出代码中的瓶颈。所以，不要依赖直觉，你应该使用剖析器（**profiling**）对代码进行性能分析：使用真实的输入来测量每一行代码的运行时间。

一旦你找出了瓶颈，就需要谨慎地尝试各种替代方案，以找到更快且功能相同的代码。在第24章中，你将学到很多加快代码运行速度的方法，但首先你需要学习如何进行微基准测试（**microbenchmark**），这样才能精确地衡量性能上的差异。

### Outline

-   23.2节：介绍如何使用剖析器来分析导致代码运行慢的原因。

-   23.3节：如何使用微基准测试来探索可替代方案并找到运行最快的方案。

### Prerequisites

使用“profvis”进行性能分析和微基准测试。

```{r}
library(profvis)
library(bench)
```

## Profiling

剖析器是所有编程语言中用来分析代码性能的主要工具。剖析器的种类繁多，R使用一种很简单称为采样（统计）剖析器的工具。它的工作原理是每个几毫秒停止程序执行，记录当前的调用栈，进而统计每个栈消耗的时间。例如下面的`f()`函数：

```{r}
f <- function() {
  pause(0.1)
  g()
  h()
}
g <- function() {
  pause(0.1)
  h()
}
h <- function() {
  pause(0.1)
}
```

使用`profvis::pause()`而非`Sys.sleep()`是因为后者不会出现在结果中，R会认为`Sys.sleep()`不消耗时间。

如果我们剖析`f()`的运行过程，每隔 0.1s 停止运行，我们会看到：

```r
"pause" "f"
"pause" "g" "f"
"pause" "h" "g" "f"
"pause" "h" "f"
```

每一行代表剖析器的一个 “刻度”（本例中为 0.1s）, 函数调用从右到左记录：第一行显示`f()`调用`pause()`。它表示代码运行`f()`花费了 0.1s，然后运行`g()`花费了 0.2s，最后运行`h()`花费了 0.1s。

使用`utils::Rprof()`可以真实地显示剖析过程，但不太可能得到上面那种清晰地结果：

```{r}
tmp <- tempfile()
Rprof(tmp, interval = 0.1)
f()
Rprof(NULL)
writeLines(readLines(tmp))
```