---
title: "24 Improving performance"
date: "2025-08-28"
date-modified: "2025-08-28"

format:
  html:
    code-link: true

fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

::: {.callout-tip}
We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified.

— Donald Knuth
:::

本节介绍四种通用的优化工具和一个通用的性能优化策略，帮助你确保优化后的代码仍然结果正确。但要注意：优化需建立在对实际瓶颈的识别之上，避免在非关键部分浪费精力，同时抓住真正影响性能的核心环节。如果你想更多地了解R语言的性能特点，推荐**Evaluating the Design of the R Language**这本书，该书通过将一个经过修改的R解释器与大量实际应用中的代码相结合，得出了相关结论。

### Outline

-   24.2节：介绍如何组织代码，使优化尽可能简单、无bug。
-   24.3节：提醒你去寻找已有的解决方案。
-   24.4节：强调“懒惰”的重要性：使函数运行快的最简单方法就是让函数做最简单的事。
-   24.5节：介绍向量化，并展示如何最大限度地利用内置函数。
-   24.6节：讨论复制数据的性能风险。
-   24.7节：将所有片段整合成一个案例研究，展示如何将重复t检验的速度提高约1000倍。
-   24.8节：提供了更多帮助你编写快速代码资源的指针。

### Prerequisites

```{r}
library(bench)
```

## Code organisation

在尝试优化代码时，通常会掉入两个陷阱中：

-   代码运行快速但不正确。
-   你认为运行快速，但实际效果并不好（没有进行基准测试）。

下面的策略会帮助你避免这些陷阱。

在进行多种方法的基准测试前，可以将这个方法打包成一个函数。因为函数内的环境是独立的，不会存在干扰，也方便检查返回的结果是否正确。例如，对比两种不同计算均值的方法：

```{r}
mean1 <- function(x) mean(x)
mean2 <- function(x) sum(x) / length(x)
```

建议你记录所有尝试的内容，甚至包括失败。如果将来发生类似的问题，查看你尝试过的所有内容会很有用。推荐使用RMarkdown或quarto, 这使得将代码与详细的注释和说明混合在一起变得容易。

接下来，生成一个具有代表性的测试示例。这个示例应该足够大，以捕捉问题的本质，但又要足够小，运行最多只需要几秒钟。你不希望花费太长时间，因为你需要多次运行测试示例来比较方法。另一方面，你也不希望示例太小，因为那样结果可能无法扩展到真正的问题。这里使用100,000个数字来进行测试：

```{r}
x <- runif(1e5)
```

现在使用`bench::mark()`来精确比较变量。`bench::mark()`会自动检查所有调用是否返回相同类型的值。这并不能保证函数对所有输入的行为都相同，因此在理想情况下，还需要进行单元测试，以确保不会意外地改变函数的行为。

```{r}
bench::mark(
  mean1(x),
  mean2(x)
)[c("expression", "min", "median", "itr/sec", "n_gc")]
```

从结果上看，`mean()`意外地要比`sum(x) / length(x)`慢一些。这是因为`mean()`在计算时，会进行一些额外的步骤，来提升结果地精度。如果你对这种计算策略感兴趣，可以查看：

-   http://stackoverflow.com/questions/22515525#22518603
-   http://stackoverflow.com/questions/22515175#22515856
-   http://stackoverflow.com/questions/3476015#22511936

## Checking for existing solutions

当你尝试过自己很多种想法后，仍然很难解决问题时，你可以检查是否已经有成熟地解决方案了。下面是两个好的检索开始：

-   [CRAN task views](http://cran.rstudio.com/web/views/)，根据任务收集CRAN上的包。

-   在[Rcpp](http://cran.r-project.org/web/packages/Rcpp)的CRAN主页上，可以找到一些使用Rcpp的包，这些包都使用C++语言编写，可能会更快些。

除此之外，你需要将你的问题描述清楚，并使用搜索引擎（现在用AI啦😊）搜索。同时，你要广泛地阅读相关书籍，积攒的专业知识有助于你更快速的检索并理解答案。将自己解决问题的过程和最终答案记录下来，长时间的积累后，可以使用某些工具进行构建自己的知识库以便日后查阅。

## Doing as little as possible

尽可能将函数的功能限定在某个范围内，接受特定的输入，输出特定的结果。例如：

-   `rowSums()`，`colSums()`，`rowMeans()`，`colMeans()`要比应用`apply()`来计算快很多。

-   `vapply()`比`sapply()`更快，因为它规定了输出的类型。

-   `any(x == 10)`要比`10 %in% x`更快。

某些函数的输入要求特定类型，当输入不符合时，函数可能会执行额外的类型转换工作。例如，应用`apply()`到`data.frame`时，会自动将`data.frame`转换为`matrix`。

如果提供更多问题的信息，某些函数会减少一些工作量。例如：

-   `read.csv()`中使用`colClasses`指定已知列类型。

-   `factor()`使用`levels`参数指定已知因子级别。

-   `cut()`设置`labels = FALSE`可以避免产生标签。

-   `unlist(x, use.names = FALSE)`要比`unlist(x)`更快。

-   `interaction()`设置`drop = TRUE`可以丢掉不必要的因子水平。

下面以`mean()`和`as.data.frame()`为例，展示如何使用这种策略来提高性能。

### `mean()`

由于R的大多数函数使用了S3或S4面向对象，因此，我们可以通过避免方法派发来提高性能。这在一个大型循环任务中会很有效。

-   S3，可以直接调用`generic.class()`函数。

-   S4，需要使用`selectMethod()`函数获取方法，然后赋值给环境变量进行调用。

例如，`mean.default()`计算小型数值向量时要比`mean()`快上些：

```{r}
x <- runif(1e2)

bench::mark(
  mean(x),
  mean.default(x)
)[c("expression", "min", "median", "itr/sec", "n_gc")]
```

这种优化方式存在一定风险，当`x`不是数值向量时，`mean.default()`会报错。你甚至可以直接调用`.Internal()`函数来极大的提升性能，同时有也将引入更大的风险——无法对NA值进行处理。

```{r}
x <- runif(1e2)
bench::mark(
  mean(x),
  mean.default(x),
  .Internal(mean(x))
)[c("expression", "min", "median", "itr/sec", "n_gc")]
```

注意：这些差异之所以出现，是因为`x`很小。如果你增加大小，这些差异基本上就会消失，因为大部分时间都用在计算平均值上，而不是进行方法派发。这很好地提醒了我们，输入的大小很重要，你应该根据真实的数据来进行优化。

```{r}
x <- runif(1e5)
bench::mark(
  mean(x),
  mean.default(x),
  .Internal(mean(x))
)[c("expression", "min", "median", "itr/sec", "n_gc")]
```

### `as.data.frame()`

