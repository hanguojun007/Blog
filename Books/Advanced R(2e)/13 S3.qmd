---
title: "13 S3"
date: "2025-07-29"
date-modified: "2025-07-29"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

R 的第一个OOP是S3面向对象，它的唯一优点是极其简单——无法再扔掉它的任何一部分来实现OOP。S3面向对象是R `base`和`stats`包中唯一使用的OOP。

S3面向对象不像其他语言中那么严格，赋予了R编程人员很大的自由，这是危险的；为了能更好的使用S3面向对象，本章会介绍使用S3面向对象时约定的惯例。

本章的目的也仅是对S3面向对象如何工作进行介绍，不涉及如何有效地创建新的S3类。

### Outline

-   13.2节：
-   13.3节：创建新的S3类时的细节，三个函数：**constructor**，**helper**，**validator**
-   13.4节：介绍类与方法如何工作（方法派发），**method dispatch**
-   13.5节：S3类的四种主要风格：vector，record，data frame，scalar
-   13.6节：介绍S3的继承及如何添加类的关系
-   13.7节：详细介绍类方法分派

### Prerequisites

S3类与`class`属性密不可分，我们需要使用`sloop`包来查看S3类的内部结构。

```{r}
library(sloop)
```

## Basics

### 类，属性

S3对象是一个至少有1个`class`属性的base type。例如factor，它的base type是`integer`，除此之外还有`class`属性和`levels`属性。

```{r}
f <- factor(c("a", "b", "c"))

typeof(f)
attributes(f)
```

使用`unclass()`可以去除S3对象的`class`属性，暴露出其底层的base type，同时失去对象的特有行为。

```{r}
unclass(f)
```

### 方法

S3类方法的实现是基于“泛型函数”的。识别泛型函数的一种简单方法是使用`sloop::ftype()`，如果结果中有"generic"字样，就是泛型函数。

```{r}
ftype(print)
ftype(str)
ftype(unclass)
```

不同S3对象输入到同一个泛型函数时会产生不同的结果（**多态**）。底层逻辑是，根据对象`class`属性，选择对应的方法。许多R函数属于泛型函数，例如`print()`。

```{r}
print(f)

# stripping class reverts to integer behaviour
print(unclass(f))
```

我们知道面向对象系统有一个重要特征——“**封装**”。S3系统的泛型函数同样具有封装的特性，会隐藏对象中的细节。例如常用的泛型函数`str()`，虽然是用来查看对象的结构，但你所看到的是对象想让你看到的，没有展示对象内部详细的细节。`POSIXlt`类用来表示时间，使用`str()`只能看到年月日，但其底层是一个`list`。

```{r}
time <- strptime(c("2017-01-01", "2020-05-04 03:21"), "%Y-%m-%d")
str(time)

str(unclass(time))
```

### 方法派发

泛型函数会为不同类找到正确的实现，类的特定实现称为方法（**method**），泛型函数通过执行方法分派（**method dispatch**）来找到对应的方法。

可以使用`sloop::s3_dispatch()`函数查看方法派发的过程。如下面所示，找到了当前print的多个方法`print.factor`和`print.default`，最终选择了`print.factor`。

```{r}
s3_dispatch(print(f))
```

从结果中可以看到，泛型函数的命名规则是`generic.class()`。通常你无需使用`generic.class()`形式的函数，只需使用`generic()`，它会根据输入对象的`class`属性自动识别。因为某些函数的定义早于S3系统，所以类型`<>.<>`的函数不都是泛函，可以使用`sloop::ftype()`进行识别。

```{r}
ftype(t.test)
ftype(t.data.frame)
```

S3 系统的泛函通常无法看到源码，但是可以使用`sloop::s3_get_method()`查看。

```{r}
#| error: true
weighted.mean.Date

s3_get_method(weighted.mean.Date)
```

## Classes

S3面向对象实例化一个对象只能使用`structure()`或`calss<-()`函数——通过设置`class`属性的方法实现。

```{r}
# Create and assign class in one step
x <- structure(list(), class = "my_class")

# Create, then set class
x <- list()
class(x) <- "my_class"
```

使用`class()`查看一个对象的类型，使用`inherits(x, "classname")`来判断一个对象是否属于某类。

```{r}
class(x)
inherits(x, "my_class")
inherits(x, "your_class")
```

classname 可以是任意字符串，但是推荐使用字姆和`_`，杜绝使用`.`。在package中使用class时，推荐加上包名。

S3面向对象没有类正确性检查，意味着可以随意更改一个对象的类：

```{r}
# Create a linear model
mod <- lm(log(mpg) ~ log(disp), data = mtcars)
class(mod)
print(mod)

# Turn it into a date (?!)
class(mod) <- "Date"

# Unsurprisingly this doesn't work very well
print(mod)
```

为了避免上述问题发生，推荐创建三个函数：

-   低级构造函数(Constructor)，`new_myclass()`：高效地创建结构正确的类。
-   验证函数(validator)，`validate_myclass()`：验证类的合法性。
-   帮助函数(helper)，`myclass()`：用户友好的创建类。

### Constructors

S3 面向对象没有提供正式的类定义函数，无法保证类的结构统一，我们需要自行创建一个构造函数，保证类的构造正确。构造函数应当遵循下面三条原则：

-   函数命名为`new_myclass()`样式。
-   一个参数服务于构成类的base type；每个属性一个参数。
-   检查base type和每个参数的类型是否符合要求。

下面是一个具有units属性，class属性为`difftime`的类构造函数：

```{r}
new_difftime <- function(x = double(), units = "secs") {
  stopifnot(is.double(x))
  units <- match.arg(units, c("secs", "mins", "hours", "days", "weeks"))

  structure(x,
    class = "difftime",
    units = units
  )
}

new_difftime(c(1, 10, 3600), "secs")

new_difftime(52, "weeks")
```

构造函数面向的是开发者，这意味着，有些时候，我们可以牺牲一些安全性来换取高效性，例如避免耗时项的检查。

### Validators

越复杂的类越需要细致地检查。如下例factor类，虽然有对输入类型检查，但仍然创建了错误的类。

```{r}
#| error: true
new_factor <- function(x = integer(), levels = character()) {
  stopifnot(is.integer(x))
  stopifnot(is.character(levels))

  structure(
    x,
    levels = levels,
    class = "factor"
  )
}

new_factor(1:5, "a")
new_factor(0:1, "a")
```

想比于构造函数中对base type和参数类型的检查，对类输入的其他检查应该分离为单独的函数。这样当你知道输入是正确时，可以以更低的成本创建类，并且检查方法可以用在其他地方。

```{r}
#| error: true
validate_factor <- function(x) {
  values <- unclass(x)
  levels <- attr(x, "levels")

  if (!all(!is.na(values) & values > 0)) {
    stop(
      "All `x` values must be non-missing and greater than zero",
      call. = FALSE
    )
  }

  if (length(levels) < max(values)) {
    stop(
      "There must be at least as many `levels` as possible values in `x`",
      call. = FALSE
    )
  }

  x
}

validate_factor(new_factor(1:5, "a"))
validate_factor(new_factor(0:1, "a"))
```

### Helpers

为了方便使用者创建类对象，我们需要提供一个帮助函数。其遵循以下原则：

-   函数名和类名相同，`myclass()`。
-   如果存在constructor和validator，函数要使用它们。
-   为终端用户创建精心设计的错误消息。。
-   有一个精心设计的用户界面，精心选择的默认值和有用的转换

下面是三个常见的示例：

#### 输入参数类型强制转换

例如上面的`new_difftime()`对输入十分严格，当输入是integer时报错。

```{r}
new_difftime(1:10)
```

可以在helper函数中添加类型强制转换：

```{r}
difftime <- function(x = double(), units = "secs") {
  x <- as.double(x)
  new_difftime(x, units = units)
}

difftime(1:10)
```

#### 提供有用的默认值

在生成factor时，提供默认的levels。

```{r}
factor <- function(x = character(), levels = unique(x)) {
  ind <- match(x, levels)
  validate_factor(new_factor(ind, levels))
}

factor(c("a", "a", "b"))
```

#### 使用简单成分组成用户界面

下面是一个构建`POSIXct`类的函数，函数的输入都是简单的整数。

```{r}
POSIXct <- function(year = integer(),
                    month = integer(),
                    day = integer(),
                    hour = 0L,
                    minute = 0L,
                    sec = 0,
                    tzone = "") {
  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)
}

POSIXct(2020, 1, 1, tzone = "America/New_York")
```

## Generics and methods

如上所述，S3系统的泛型函数会执行方法分派——找到类能使用的方法，该过程由`UseMethod()`函数实现。`UseMethod()`函数有两个参数：

-   generic：字符串类型的泛型函数名称。
-   object：要分派的对象。

通常只需要第一个参数，例如`mean()`:

```{r}
mean
```

创建自己的泛型函数，在创建时，泛型函数的参数不需要传递到`UseMethod()`中。

``` r
my_new_generic <- function(x) {
  UseMethod("my_new_generic")
}
```

泛型函数内不要添加额外的处理逻辑，这会导致不可预的意外，例如下面的泛型函数`g()`，你无法修改变量`y`的值。

```{r}
g <- function(x) {
  x <- 10
  y <- 10
  UseMethod("g")
}
g.default <- function(x) c(x = x, y = y)

x <- 1
y <- 1
g(x)
```

### Method dispath

`UseMethod()`执行方法派发的原理：创建泛型函数拥有的方法向量（`generic.class`），寻找潜在可用的方法。使用`sloop::s3_dispath()`可以查看这一过程。

```{r}
x <- Sys.Date()
s3_dispatch(print(x))
```

-   `=>`表示该方法被调用
-   `*`表示该方法被定义但未被调用

"default" class是特殊的伪类，它不是真实存在的类；包含它是为了使定义一个标准回退成为可能，这个回退在特定类的方法不可用时可以找到。例如下面的`test`类，在执行`t()`时，会自动为其分配`t.default()`方法，而不是R 4.0.0版本前的将`t.test()`当作方法进行派发。

```{r}
x <- structure(1:10, class = "test")
s3_dispatch(t(x))
```

``` r
# Output in R version 3.6.2
x <- structure(1:10, class = "test")
t(x)
#>
#>  One Sample t-test
#>
#> data:  x
#> t = 5.7446, df = 9, p-value = 0.0002782
#> alternative hypothesis: true mean is not equal to 0
#> 95 percent confidence interval:
#>  3.334149 7.665851
#> sample estimates:
#> mean of x
#>       5.5
```

方法派发的本质相当简单，但随着本章的深入，你会发现它在包含继承、基类型、内部泛型和组泛型方面变得越来越复杂。下面的代码展示了几个更复杂的情况，我们将在后续13.7节和14章中详细介绍。

```{r}
x <- matrix(1:10, nrow = 2)
s3_dispatch(mean(x))

s3_dispatch(sum(Sys.time()))
```

### Finding methods

`sloop::s3_methods_generic()`函数可以查看一个generic函数的所有方法。`sloop::s3_methods_class()`函数可以查看一个class的所有方法。

```{r}
s3_methods_generic("mean")

s3_methods_class("ordered")
```

### Creating methods

创建自己类的方法格式为：

``` r
generic_name.class_name <- function(generic_params) {
  # do something
}
```

在创建新方法时要注意：

-   首先，只有当你拥有泛型函数或类时，才应该编写方法。虽然即使你不拥有某个类或泛型函数,R 也会允许你定义方法，但这是极其不礼貌的行为。相反，请与泛型函数或类的作者合作，在他们的代码中添加方法。

-   一个方法必须具有与其泛型相同的参数。这是通过 R CMD 检查在包中强制执行的，但即使不创建包，这也是一个很好的实践。

## Object styles

这里用`length()`函数介绍一下不同类的方法风格。当`length()`函数作用于向量时，返回向量的长度。当作用在其他如dataframe类时，返回的是list的长度。

-   Record style object：list中的元素等长。例如`POSIXlt`类：

```{r}
x <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))
x

length(x)
length(unclass(x))

x[[1]] # the first date time
unclass(x)[[1]] # the first component, the number of seconds
```

-   Data frame

```{r}
x <- data.frame(x = 1:100, y = 1:100)
length(x)
nrow(x)
```

-   Scalar object: 使用一个list表示一个单一的对象。例如：`lm`对象

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
length(mod)
```

更多有关Object style2的内容可参考[vctrs](https://vctrs.r-lib.org)包。

## Inheritance

S3类的方法“**继承**”有由下面三种方式实现：

-   `class`属性可以是一个向量。

```{r}
class(ordered("x"))
class(Sys.time())
```

-   如果第一个类（class向量）没有方法定义，R 会自动向下寻找。

```{r}
s3_dispatch(print(ordered("x")))
s3_dispatch(print(Sys.time()))
```

-   使用`NextMethod()`可以访委托方法给已存在的方法。

```{r}
# 注意`->`
s3_dispatch(ordered("x")[1])
s3_dispatch(Sys.time()[1])
```

S3面向对象没有对子类和父类之间的关系施加限制，在创建一个子类时，推荐：

-   子类的base type与父类保持一致
-   子类的属性包含（继承）父类的属性

### `NextMethod()`

`NextMethod ()`是继承中最难理解的部分，所以我们从一个最常用的`[`的具体示例开始。我们首先创建一个简单的类：一个在打印时隐藏其输出的秘密类：

```{r}
new_secret <- function(x = double()) {
  stopifnot(is.double(x))
  structure(x, class = "secret")
}

print.secret <- function(x, ...) {
  print(strrep("x", nchar(x)))
  invisible(x)
}

x <- new_secret(c(15, 1, 456))
x
```

上面代码运行成功，但secret类没有定义`[`方法。

```{r}
s3_dispatch(x[1])
x[1]
```

下面直接定义的`[.secret`方法会陷入无限循环：

``` r
`[.secret` <- function(x, i) {
  new_secret(x[i])
}
```

我们需要额外的步骤，先去掉x的类属性，取完值后再重新定义类：

```{r}
`[.secret` <- function(x, i) {
  x <- unclass(x)
  new_secret(x[i])
}
x[1]
```

上面的方法虽然有效，但会额外的创建`x`对象，造成资源浪费。更好的方法是使用`NextMethod()`方法。

```{r}
`[.secret` <- function(x, i) {
  new_secret(NextMethod())
}
x[1]
```

```{r}
s3_dispatch(x[1])
```

`=>`表示调用了`[.secret`, 但`NextMethod()`将方法委托于底层的内部`[`方法，如`->`所示。

`NextMethod()`在寻找委托方法的类时，会根据全局变量`.Class`来判断，内部的类型改变无效，例如：下面的结果返回的是`a2`。

```{r}
generic2 <- function(x) UseMethod("generic2")
generic2.a1 <- function(x) "a1"
generic2.a2 <- function(x) "a2"
generic2.b <- function(x) {
  class(x) <- "a1"
  NextMethod()
}

generic2(structure(list(), class = c("b", "a2")))
```

### Allowing subclassing

当你创建一个类时，你需要决定是否允许可以存在一个子类，因为允许子类会要求你再创建构造函数和方法时作出一些额外的工作。

例如，允许子类后，父类的构造函数要添加额外的参数——`...`,`class`。

```{r}
new_secret <- function(x, ..., class = character()) {
  stopifnot(is.double(x))

  structure(
    x,
    ...,
    class = c(class, "secret")
  )
}
```

然后，子类的构造函数可以直接调用父类的构造函数，并添加额外的参数。

```{r}
new_supersecret <- function(x) {
  new_secret(x, class = "supersecret")
}

print.supersecret <- function(x, ...) {
  print(rep("xxxxx", length(x)))
  invisible(x)
}

x2 <- new_supersecret(c(15, 1, 456))
x2
```

如果允许添加子类，方法同样需要额外的工作，否则方法始终返回父类。

```{r}
`[.secret` <- function(x, ...) {
  new_secret(NextMethod())
}
x2[1:3]


`[.secret` <- function(x, ...) {
  new_secret(NextMethod(), class = class(x))
}
x2[1:3]
```

我们也可以使用`vctrs::vec_restore()`泛型函数，为secret类添加不同类时的返回结果。

```{r}
# `to` 参数用来传递类的其他属性。
vec_restore.secret <- function(x, to, ...) new_secret(x)
vec_restore.supersecret <- function(x, to, ...) new_supersecret(x)

`[.secret` <- function(x, ...) {
  vctrs::vec_restore(NextMethod(), x)
}
x2[1:3]
```

## Dispatch details

### S3 and base types

S3面向对象系统中的泛型函数在作用于 base type 时，不会根据`calss()`返回的类进行方法派发。

```{r}
class(matrix(1:5))
s3_dispatch(print(matrix(1:5)))

x1 <- 1:5
class(x1)
s3_dispatch(mean(x1))

x2 <- structure(x1, class = "integer")
class(x2)
s3_dispatch(mean(x2))
```

base type 的方法派发根据是其**implicit class**。**implicit class** 有三种组成：

-   当对象有维度时，"array", "matrix"。
-   `typeof()`的结果。
-   当对象是"integer"或"double"时，"numeric"。

**implicit class** 只能由`sloop::s3_class()`获取。

```{r}
s3_class(matrix(1:5))
```

### Internal generics

base R 中的一些函数，如`[`,`sum()`,`cbind()`等被称为**internal generics**。因为它们不使用`UseMethod()`，而是C语言中的`DispatchGroup()`或`DispatchOrEval()`。使用`s3_dispatch()`时，会显示为`(internal)`。

```{r}
s3_dispatch(Sys.time()[1])
```

### Group generics

Group generics 与 internal generics 类似，只存在于 base R 中，你自己无法构建。

base R 中存在4大类 Group generics：

-   **Math**：[`abs()`](https://rdrr.io/r/base/MathFun.html), [`sign()`](https://rdrr.io/r/base/sign.html), [`sqrt()`](https://rdrr.io/r/base/MathFun.html), [`floor()`](https://rdrr.io/r/base/Round.html), [`cos()`](https://rdrr.io/r/base/Trig.html), [`sin()`](https://rdrr.io/r/base/Trig.html), [`log()`](https://rdrr.io/r/base/Log.html), and more (see [`?Math`](https://rdrr.io/r/base/groupGeneric.html) for the complete list).
-   **Ops**：`+`, `-`, `*`, `/`, `^`, `%%`, `%/%`, `&`, `|`, `!`, `==`, `!=`, `<`, `<=`, `>=`, and `>`.
-   **Summary**：[`all()`](https://rdrr.io/r/base/all.html), [`any()`](https://rdrr.io/r/base/any.html), [`sum()`](https://rdrr.io/r/base/sum.html), [`prod()`](https://rdrr.io/r/base/prod.html), [`min()`](https://rdrr.io/r/base/Extremes.html), [`max()`](https://rdrr.io/r/base/Extremes.html), and [`range()`](https://rdrr.io/r/base/range.html).
-   **Complex**：[`Arg()`](https://rdrr.io/r/base/complex.html), [`Conj()`](https://rdrr.io/r/base/complex.html), [`Im()`](https://rdrr.io/r/base/complex.html), [`Mod()`](https://rdrr.io/r/base/complex.html), [`Re()`](https://rdrr.io/r/base/complex.html).

当你为你的类定义了某个Group generic，这个Group generic内的所有方法都会被覆盖。当某个方法不存在时，会从组内寻找。

```{r}
s3_dispatch(sum(Sys.time()))
```

很多 Group generics 中都使用了`NextMethod()`。例如期，我们用`abs()`来计算一个`difftime`对象。

```{r}
y <- as.difftime(10, units = "mins")
s3_dispatch(abs(y))
```

`Math.difftime()`大致如下：

```r
Math.difftime <- function(x, ...) {
  new_difftime(NextMethod(), units = attr(x, "units"))
}
```

### Double dispatch

Ops Group generics 使用了 double dispatch。这保证了`a + b`和`b + a`的计算结果一致。例如：

```{r}
date <- as.Date("2017-01-01")
integer <- 1L

date + integer
integer + date
```

因为要同时为两种类进行方法派发，所以就会出现下面三种情况：

-   如果方法相同，无所谓使用哪个方法。
-   如果方法不同，R 最终回归到内部方法，并附带一个警告。
-   如果有一个方法是“internal”，则R使用另外一种方法。
