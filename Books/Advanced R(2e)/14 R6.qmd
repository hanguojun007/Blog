---
title: "14 R6"
date: "2025-07-31"
date-modified: "2025-07-31"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

本章介绍R6 OOP系统，它有两大特点：

-   R6使用了封装的OOP范式，意味着方法（method）属于对象（object）而不是泛型函数（generic），调用方法的范式为`object$method()`。

-   R6对象是可改变的，意味着它们可以原地修改并具有参考语义。当你将一个R6对象赋值给另一个变量时，实际上是将指向该R6对象的引用来赋值给新变量。这样，任何对该对象所做的更改都会反映在所有引用它的变量中。

虽然R6 OOP系统与其他语言中的OOP范式相同，使用起来更容易上手，但它缺点就是不符合R的使用习惯，我们将在第16章中讨论它们。

### Outline

-   14.2节：介绍使用`R6::R6Class()`创建R6类，使用构造器`$new()`创建新的R6对象。
-   14.3节：讨论R6的访问机制：私有域和主动域。
-   14.4节：探讨R6的参考语义的影响。学习如何使用终结器自动清理初始化器中执行的任何操作，以及如何在另一个R6对象中将一个R6对象作为字段使用。
-   14.5节：对比R6系统和RC系统。

### Prerequisites

```{r}
# install.packages("R6")
library(R6)
```

## Classes and methods

`R6::R6Class()`函数可以同时构建类（class）和方法（method），同时也是R6包中唯一需要使用的函数。

`R6Class()`函数有两个极其重要的参数：

-   `classname`：类名，它不是必须的，但它改进了错误消息，并使得R6对象可以与S3类的泛型函数结合使用。R6 class名称通常使用`UpperCamelCase`命名法。
-   `public`：一个列表，包含类的属性（field）和方法，可以通过`self$`的方法获取。属性和方法通常使用`snake_case`命名法。

```{r}
Accumulator <- R6Class(
  classname = "Accumulator",
  public = list(
    sum = 0,
    add = function(x = 1) {
      self$sum <- self$sum + x
      invisible(self)
    }
  )
)
```

在使用`R6Class()`创建对象时，需要始终将创建的结果赋值给与类名相同的变量。

```{r}
Accumulator
```

可以使用`object$new()`的方法创建新对象。

```{r}
x <- Accumulator$new()
```

同样地，使用`$`获取对的属性和方法。

```{r}
x$add(4)
x$sum
```

后续我们以`()`区分`$`获取的时属性还是方法——`$add()`表示方法，`$sum`表示属性。

### Method chaining

当`$add()`方法返回的是`self`而不是`$sum`时，我们就可以使用方法链（**method chaining**），类似管道符。通常我们使用`return()`来返回，但鉴于`self`的隐私性，这里使用`invisible()`。

```{r}
x$add(10)$add(10)$sum

x$
  add(10)$
  add(10)$
  sum
```

### Important methods

对大多数R6对象，有两个重要的方法需要定义——`$initialize()`和`$print()`。它们非必须，但会提升对象的使用性。

`$initialize()`方法会覆盖默认的`$new()`方法。例如下面的“Person”类，我在`$initialize()`方法中判断了`$name`属性只能是单一的字符串，`$age`属性只能是单一的数字。如果你有更多对输入的检查，将它们放在`$validate()`方法中更合适。

```{r}
Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)

    self$name <- name
    self$age <- age
  }
))

hadley <- Person$new("Hadley", age = "thirty-eight")

hadley <- Person$new("Hadley", age = 38)
```

`$print()`方法会覆盖默认的`print()`方法，允许你自定义对象的打印输出。和其他R6对象的方法一样，最终使用`invisible()`来返回。

```{r}
Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    self$name <- name
    self$age <- age
  },
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  }
))

hadley2 <- Person$new("Hadley")
hadley2
```

### Adding methods after creation

可以使用`$set()`修改R6对象的属性和方法。

```{r}
Accumulator <- R6Class("Accumulator")
Accumulator$set("public", "sum", 0)
Accumulator$set("public", "add", function(x = 1) {
  self$sum <- self$sum + x
  invisible(self)
})
```

需要注意：对象添加新的属性和方法后，只有用它创建新的对象时才会添加，已经创建好的对象不会添加新的属性和方法。

### Inheritance

参数`inherit`允许创建继承关系。

```{r}
AccumulatorChatty <- R6Class(
  "AccumulatorChatty",
  inherit = Accumulator,
  public = list(
    add = function(x = 1) {
      cat("Adding ", x, "\n", sep = "")
      super$add(x = x)
    }
  )
)

x2 <- AccumulatorChatty$new()
x2$add(10)$add(1)$sum
```

拥有继承关系的子类可以使用父类的方法，但时如何名称相同发生覆盖，则需要使用`suppe$`来方法父类方法，这与上一章中的`NextMethod()`函数类似。

### Introspection

每一个R6对象中都含有一个S3类。这意味着我们可以对R6对象使用一些S3类常用的函数，上述提到的`$print()`方法，本质上是`print.R6()`函数。

`class()`可以确定是否属于R6类。

```{r}
class(hadley2)
```

`names()`可以查看R6类的所有属性和方法名。下面的`.__enclos_env__`是R6内部的实现细节（R6 = S3 + env）。

```{r}
names(hadley2)
```

### Exercises

1.  Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.

```{r}
#| code-fold: true
#| code-summary: "solution"
Bank <- R6Class("Bank", list(
  name = "",
  balance = 0,
  initialize = function(name, balance = 0) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(balance), length(balance) == 1)

    self$name <- name
    self$balance <- balance
  },
  print = function(...) {
    cat("Bank: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Balance:  ", self$balance, "\n", sep = "")
    invisible(self)
  },
  deposit = function(x) {
    self$balance <- self$balance + x
    invisible(self)
  },
  withdraw = function(x) {
    self$balance <- self$balance - x
    invisible(self)
  }
))

a <- Bank$new(name = "a", balance = 1000)
a$deposit(500)$withdraw(2000)
a

Bank2 <- R6Class("Bank2", inherit = Bank, public = list(
  withdraw = function(x) {
    if (self$balance - x < 0) {
      stop("Insufficient funds", call. = FALSE)
    }
  }
))

b <- Bank2$new(name = "b", balance = 1000)
b$deposit(500)$withdraw(2000)
b

Bank3 <- R6Class("Bank3", inherit = Bank, public = list(
  withdraw = function(x) {
    if (self$balance - x < 0) {
      message("charge of $5 applied")
      self$balance <- self$balance - x - 5
    }
  }
))

c <- Bank3$new(name = "c", balance = 1000)
c$deposit(500)$withdraw(2000)
c
```

2.  Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with $draw(n), and return all cards to the deck and reshuffle with $reshuffle(). Use the following code to make a vector of cards.

```{r}
suit <- c("♠", "♥", "♦", "♣")
value <- c("A", 2:10, "J", "Q", "K")
cards <- paste0(rep(value, 4), suit)
```

```{r}
#| code-fold: true
#| code-summary: "solution"

ShuffledDeck <- R6Class(
  classname = "ShuffledDeck",
  public = list(
    deck = NULL,
    initialize = function(deck = cards) {
      self$deck <- sample(deck)
    },
    reshuffle = function() {
      self$deck <- sample(cards)
      invisible(self)
    },
    n = function() {
      length(self$deck)
    },
    draw = function(n = 1) {
      if (n > self$n()) {
        stop("Only ", self$n(), " cards remaining.", call. = FALSE)
      }

      output <- self$deck[seq_len(n)]
      self$deck <- self$deck[-seq_len(n)]
      output
    }
  )
)

my_deck <- ShuffledDeck$new()
my_deck$draw(52)
my_deck$draw(10)
my_deck$reshuffle()$draw(5)
my_deck$reshuffle()$draw(5)
```

## Controlling access