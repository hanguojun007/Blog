---
title: "7 Environments"
date: "2025-06-23"
date-modified: "2025-06-24"
format: "html"
execute:
  warning: false
  fig-width: 6
  fig-asp: 0.618
  out-width: 70%
  fig-align: center
---

```{r}
#| echo: false

source("_common.R")
```

## Introduction

环境是赋予作用域（scoping）能力的数据结构。本章会详细地介绍环境的数据结构，来提高对于作用域地理解。

### Outline

-   7.2节介绍环境地基本属性及如何创建一个自己的环境。
-   7.3节介绍函数于环境的关系。
-   7.4节介绍环境的特殊用法：R包
-   7.5节介绍`caller`环境。
-   7.6节介绍`environment`函数。

### Prerequisites

本章将使用 rlang 函数来处理环境，因为它允许我们关注环境的本质，而不是偶然的细节。

```{r}
library(rlang)
```

rlang中的`env_*()`函数被设计用来在工作流中使用。所有的函数都接收一个环境作为参数，大多数会返回一个环境。

## Environment basics

环境与有name属性的list很相似，但是有4点差异：

-   要求name唯一。
-   name不会被排序，即无法使用顺序来提取环境中的变量。
-   总有一个父环境，除了根环境。
-   被修改时不会在内存中复制。

### Basics

使用`rlang::env()`创建一个环境，与list类似，接收一个键值对集合。`base::new.env()`函数也可以创建环境，但是不能直接传递键值对集合，需要使用`$<-`赋值。

```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)

e2 <- new.env()
e2$a <- FALSE
e2$b <- "a"
e2$c <- 2.3
e2$d <- 1:3


identical(e1, e2)
```

![](images/bindings.png)


环境具有引用语义：与大多数R对象不同，当你修改环境时，你是在原地修改它们，而不是创建副本。一个重要的含义是，环境可以自我包含。

```{r}
e1$d <- e1
```

![](images/loop.png)

在终端中直接运行环境仅会显示内存地址，使用`env_print()`可以打印更多环境信息，也可以使用`env_names()`直接输出目前环境中绑定过的变量名。

```{r}
e1
env_print(e1)
env_names(e1)
```

### Important environments

这里介绍两个特殊环境，更多特殊的环境会在之后详细讲到：

-   全局环境：就是当前交互终端的环境，`global_env()`或`globalenv()`获取。

-   当前环境：当前执行代码的环境，`current_env()`或`environment()`获取，如果在终端中执行，那么等于全局环境。

使用`identical()`判断两个环境是否相等，不能使用`==`，因为环境不是atomic或list类型。

```{r}
#| error: true
identical(global_env(), current_env())

global_env() == current_env()
```

### Parents

使用`env()`创建环境时，提供一个没有name的参数即可设定环境的父环境。使用`env_parent()`或`parent.env`可以查看父环境。

```{r}
e2a <- env(d = 4, e = 5)
e2b <- env(e2a, a = 1, b = 2, c = 3)
env_parent(e2b)
parent.env(e2b)
env_parent(e2a)
parent.env(e2a)
```

![](images/parents.png)

每个环境都有父环境，除了空环境（empty environment）。使用`env_parents()`可以查看所有父环境。

```{r}
e2c <- env(empty_env(), d = 4, e = 5)
e2d <- env(e2c, a = 1, b = 2, c = 3)
env_parents(e2b)
env_parents(e2d)
```

![](images/parents-empty.png)

`env_parents()`通常只返回到全局环境。设置`last = empty_env()`可以返回所有父环境。

```{r}
env_parents(e2b, last = empty_env())
```

### Super assignment, `<<-`

常规赋值`<-`会在当前环境中创建变量。超赋值`<<-`从不会在当前环境中创建变量，只是会修改变量，当前环境中没有就依次在父环境中搜索，直到全局环境。如果全局环境中也没有这个变量，就会在全局环境中创建这个变量。

```{r}
x <- 0
f <- function() {
  x <<- 1
}
f()
x
```

### Getting and setting

获取环境中的变量方法有`$`，`[[`，`env_get()`。

```{r}
e3 <- env(x = 1, y = 2)
e3$x
e3$z <- 3
e3[["z"]]
env_get(e3, "z")
```

需要注意的是：`[[`不适用于数字索引，也不可以使用`[`。

```{r}
#| error: true
e3[[1]]

e3[c("x", "y")]
```

变量不存在时，`$`，`[[`会返回`NULL`，`env_get()`会返回错误。`env_get()`设置参数`default`后，可以给定默认值而不报错。

```{r}
#| error: true
e3$xyz

env_get(e3, "xyz")

env_get(e3, "xyz", default = NA)
```

`rlang`包还提供两种额外的设定变量值的方法：

-   `env_poke()`：只设置一个变量。
-   `env_bind()`：设置多个变量。

```{r}
env_poke(e3, "a", 100)
e3$a

env_bind(e3, a = 10, b = 20)
env_names(e3)
```

与list不同，当设置变量值为`NULL`时，并不会移除这个变量，而是实际有一个变量指向了`NULL`。`env_has()`可以用来检测环境中是否存在某个变量。`env_unbind()`会真实地解绑一个变量。

```{r}
e3$a <- NULL
env_has(e3, "a")

env_unbind(e3, "a")
env_has(e3, "a")
```

需要注意地是：`env_unbind()`不会删除变量，只是解绑变量与值的关系。删除变量是`gc()`的任务。在R base中存在功能与上述类似的函数：`get()`，`assign()`，`exists()`，`rm()`，这些函数被设计用来在当前环境中工作，其他环境中会略显不足。

### Advanced bindings

`env_bind()`函数有两个变体：

-   `env_bind_lazy()`可以创建延迟绑定。在首次绑定前会先运行导致延迟的代码，然后再绑定。延迟绑定主要应用于R包中的`autoload()`，预先将数据集加载到内存中。

``` {r}
env_bind_lazy(current_env(), b = {
  Sys.sleep(1)
  1
})

system.time(print(b))
system.time(print(b))
```

-   `env_bind_active()`可以创建实时绑定，每次重新绑定值。

``` {r}
env_bind_active(current_env(), z1 = function(val) runif(1))

z1
z1
```

更多见`?delayedAssign()`和`?makeActiveBinding()`。

## Recursing over environments


## Special environments

许多环境是由R自行创建，例如：包环境，函数环境。

### Package environments and the search path


