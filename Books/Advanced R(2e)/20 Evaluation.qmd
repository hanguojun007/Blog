---
title: "20 Evaluation"
date: "2025-08-15"
date-modified: "2025-08-15"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---


## Introduction



### Prerequisites

要求熟悉前两章内容和第7章有关环境的内容。

```{r}
library(rlang)
library(purrr)
```

## Evaluation basics

`eval()`函数有两个参数：`epxr`，`env`。

`expr`参数是待评估的“表达式”或符号。由于`eval()`函数不会对输入引用，所以需要与`expr()`一同使用：

```{r}
x <- 10
eval(expr(x))

y <- 2
eval(expr(x + y))
```

`env`参数用来指定评估“表达式”的“环境”，如果没有指定，则默认为当前环境。

```{r}
eval(expr(x + y), env(x = 1000))
```

当指定了环境，却没有引用输入时，会导致错误的结果：

```{r}
eval(print(x + 1), env(x = 1000))

eval(expr(print(x + 1)), env(x = 1000))
```

在了解了基础知识后，让我们探索一些应用。我们将使用“rlang”重新实现某些函数的底层原理，主要是base R中的函数。

### Application:`local()`

有时我们会创建一些临时变量来执行一系列计算，这些临时变量不会长期使用，可能也会相当占用内存，需要在使用结束后删除。一种方法是使用`rm()`清楚临时变量；另一种是将计算过程打包为函数，仅调用一次。更优雅的方式是使用`local()`函数，它可以创建一个临时环境，并执行其中的代码。

```{r}
# Clean up variables created earlier
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

`local()`函数的本质很简单，我们可以采用下面的策略实现它。首先捕获输入的“表达式”，然后使用`local()`函数的执行环境作为`eval()`的调用环境参与评估。

```{r}
local2 <- function(expr) {
  env <- env(caller_env())
  eval(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

但`base::local()`的底层实现很复杂，它使用了`eval()`和`substitute()`。

### Application:`source()`

我们可以通过组合`eval()`和`parse_expr()`来实现`source()`的功能。首先从磁盘中读取文件，然后使用`parse_expr()`将字符串转换成“表达式”列表，最后使用`eval()`评估“表达式”。实现如下：

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}
```

真实的`base::source()`函数更加复杂，会打印输入输出信息，同时有许多额外参数控制行为。

#### Expression vectors

上一章讲到，`base::parse()`函数解析字符串时，如果捕获到多个“表达式”，会返回一个包含多个表达式的向量。`base::eval()`函数可以直接评估这个向量，而不用上面的`for`循环。

```{r}
source3 <- function(file, env = parent.frame()) {
  lines <- parse(file)
  res <- eval(lines, envir = env)
  invisible(res)
}
```

### Gotcha:`function()`

如果你使用`eval()`和`expr()`来生成函数，有一个小小的漏洞需要注意：

```{r}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
```

这个函数看起来不像能工作，但它确实能工作：

```{r}
f()
```

这是因为，如果函数有“srcref”属性，就会打印它，但“srcref”是一个base R的特性，它无法识别准引号。

要解决这个问题，可以使用`new_function()`或删除“srcref”属性：

```{r}
attr(f, "srcref") <- NULL
f
```

## Quosures

几乎`eval()`的所有使用都包括“表达式”和“环境”两个参数，但是base R中没有能同时提供这两个参数的数据结构，“rlang”包创建了这种数据结构——“**quosures**”。**quosures**是“quoting”和“closure”的复合体，意味着它同时包含了“表达式”和环境。

在本节中，你将学习如何创建和操作quosure, 以及一些关于如何实现它。

### Creating

有三中方式创建quosure:

-   使用`enquo()`和`enquos()`，它们会同时捕获表达式和环境。许多quosure都是由此创建的。

```{r}
foo <- function(x) enquo(x)
foo(a + b)
```

-   使用`quo()`和`quos()`，与`enquo()`和`enquos()`的关系可以参考`expr()``enexpr()`。使用的场景很少。

```{r}
quo(x + y + z)
```

-   使用`new_quosure()`，输入“表达式”和环境来创建quosure。使用场景也极少。

```{r}
new_quosure(expr(x + y), env(x = 1, y = 10))
```

### Evaluting

只能使用`eval_tidy()`来评估quosure。

```{r}
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
```

### Dots

`enquos()`可以正确识别`...`中传入的参数及其绑定的环境。例如，下面的`qs`对象，正确评估了`global`和`f`的环境。

```{r}
f <- function(...) {
  x <- 1
  g(..., f = x)
}
g <- function(...) {
  enquos(...)
}

x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
```

### Under the hood

Quosures 数据结构受R中的“formulas”启发，因为“formula”同样也是同时捕获“表达式”与“环境”。早期也确实使用“formula”来进行评估，但因为无法简单的将`~`变为准引用函数，所以放弃使用“formula”。

```{r}
f <- ~ runif(3)
str(f)
```

Quosures 同样也是“formula”的子类：

```{r}
q4 <- new_quosure(expr(x + y + z))
class(q4)
```

这意味着一些函数可以直接作用于Quosures：

```{r}
is_call(q4)

q4[[1]]
q4[[2]]
```

有一个用于存放环境的属性：

```{r}
attr(q4, ".Environment")
```

但是不建议使用上面的函数，而是使用`get_expr()`和`get_env()`来获取表达式和环境：

```{r}
get_expr(q4)
get_env(q4)
```

### Nested quosures

准引用支持在“表达式”中引入quosures，这是一种高级技术，使得创建嵌套quosures变得可能。例如下面的“表达式”中嵌套了两个短语。

```{r}
q2 <- new_quosure(expr(x), env(x = 1))
q3 <- new_quosure(expr(x), env(x = 10))

x <- expr(!!q2 + !!q3)
```

它可以被正确地评估，但是如果打印它，你会发现它的“formula”形式：

```{r}
eval_tidy(x)
x
```

可以使用`rlang::expr_print()`来更好的展示，在终端中根据不同环境源显示不同颜色：

```{r}
expr_print(x)
```

## Data masks

本节介绍数据掩码（**data mask**）相关内容，这是一种同时在“环境”与“数据框构成的环境”中评估“表达式”的技术。它的核心思想与base R中的`with()`,`subset()`和`transform()`类似，被广泛应用在“tidyverse”系列包中。

::: {.callout-note}
注意：`enquo()`保证了能在不同环境中正确评估“表达式”中的变量，`expr()`不能，这是一个重要的区别。但是本节所有示例中的`enquo()`与`expr()`都可以替换，不影响结果。
:::

### Basics

数据掩码允许你混合环境来源和数据框来源的变量。你可以将数据框当作环境变量传递给`eval_tidy()`的第二个参数。

```{r}
q1 <- new_quosure(expr(x * y), env(x = 100))
df <- data.frame(y = 1:10)

eval_tidy(q1, df)
```

上面的代码可能有些难以理解，我们可以作一些拆分：

```{r}
x <- 100
df <- data.frame(y = 1:10)
eval_tidy(expr(x * y), df)
```

稍加修改，改写为类似`base::with()`的函数：

```{r}
with2 <- function(data, expr) {
  expr <- enquo(expr)
  eval_tidy(expr, data)
}

with2(df, x * y)
```

`base::eval()`可以实现类似的效果，传递数据框到第二个参数，环境到第三个参数。

```{r}
with3 <- function(data, expr) {
  expr <- substitute(expr)
  eval(expr, data, caller_env())
}
```

### Pronouns

数据掩码会引起歧义。例如，在以下代码中，除非你知道`df`中包含哪些变量，否则你无法知道`x`是来自数据掩码还是环境。

```{r}
with2(df, x)
```

为了解决歧义问题，数据掩码提供了两个声明：`.data`和`.env`。

-   `.data$x` 表示数据掩码中的变量`x`。
-   `.env$x` 表示环境中的变量`x`。

```{r}
x <- 1
df <- data.frame(x = 2)

with2(df, .data$x)
with2(df, .env$x)
```

对于两个声明，你可以使用`[[`，但是要注意它们是特殊的对象，和真实的数据框、环境不同。例如，如果找不到变量，它会抛出错误：

```{r}
df$y
with2(df, .data$y)
```

### Application: `subset()`

下面是`subset()`的使用场景之一：直接通过某个“表达式”进行过滤数据框的行。

```{r}
sample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))

# Shorthand for sample_df[sample_df$a >= 4, ]
subset(sample_df, a >= 4)

# Shorthand for sample_df[sample_df$b == sample_df$c, ]
subset(sample_df, b == c)
```

`subset()`的核心逻辑是：

-   两个参数：数据框`data`和“表达式”`rows`。
-   在数据框`data`中，评估`rows`，并返回结果逻辑向量。
-   根据逻辑向量，返回数据框的行。

```{r}
subset2 <- function(data, rows) {
  rows <- enquo(rows)
  rows_val <- eval_tidy(rows, data)
  stopifnot(is.logical(rows_val))

  data[rows_val, , drop = FALSE]
}

subset2(sample_df, a >= 4)
```

### Application: `transform()`

`transform()`函数类似`dplyr::mutate()`，可以在数据框中添加新的一列。

```{r}
df <- data.frame(x = c(2, 3, 1), y = runif(3))
transform(df, x = -x, y2 = 2 * y)
```

下面是`transform()`的简单等价实现：

```{r}
transform2 <- function(.data, ...) {
  dots <- enquos(...)

  for (i in seq_along(dots)) {
    name <- names(dots)[[i]]
    dot <- dots[[i]]

    .data[[name]] <- eval_tidy(dot, .data)
  }

  .data
}

transform2(df, x2 = x * 2, y = -y)
```

### Application: `select()`

数据掩码不总是作用于数据框，也可以是list。这是`subset()`的另一个使用场景——根据“表达式”选择某些列——的底层逻辑。

```{r}
df <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)
subset(df, select = b:d)
```

它的关键思想是创建一个有name属性的list，list的每个元素是对应列的位置索引。

```{r}
vars <- as.list(set_names(seq_along(df), names(df)))
str(vars)
```

然后在list中进行评估，返回位置索引：

```{r}
select2 <- function(.data, ...) {
  dots <- enquos(...)

  vars <- as.list(set_names(seq_along(.data), names(.data)))
  cols <- unlist(map(dots, eval_tidy, vars))

  .data[, cols, drop = FALSE]
}
select2(df, b:d)
```

## Using tidy evaluation
