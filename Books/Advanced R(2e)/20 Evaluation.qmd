---
title: "20 Evaluation"
date: "2025-08-15"
date-modified: "2025-08-15"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---


## Introduction



### Prerequisites

要求熟悉前两章内容和第7章有关环境的内容。

```{r}
library(rlang)
library(purrr)
```

## Evaluation basics

`eval()`函数有两个参数：`epxr`，`env`。

`expr`参数是待评估的“表达式”或符号。由于`eval()`函数不会对输入引用，所以需要与`expr()`一同使用：

```{r}
x <- 10
eval(expr(x))

y <- 2
eval(expr(x + y))
```

`env`参数用来指定评估“表达式”的“环境”，如果没有指定，则默认为当前环境。

```{r}
eval(expr(x + y), env(x = 1000))
```

当指定了环境，却没有引用输入时，会导致错误的结果：

```{r}
eval(print(x + 1), env(x = 1000))

eval(expr(print(x + 1)), env(x = 1000))
```

在了解了基础知识后，让我们探索一些应用。我们将使用“rlang”重新实现某些函数的底层原理，主要是base R中的函数。

### Application:`local()`

有时我们会创建一些临时变量来执行一系列计算，这些临时变量不会长期使用，可能也会相当占用内存，需要在使用结束后删除。一种方法是使用`rm()`清楚临时变量；另一种是将计算过程打包为函数，仅调用一次。更优雅的方式是使用`local()`函数，它可以创建一个临时环境，并执行其中的代码。

```{r}
# Clean up variables created earlier
rm(x, y)

foo <- local({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

`local()`函数的本质很简单，我们可以采用下面的策略实现它。首先捕获输入的“表达式”，然后使用`local()`函数的执行环境作为`eval()`的调用环境参与评估。

```{r}
local2 <- function(expr) {
  env <- env(caller_env())
  eval(enexpr(expr), env)
}

foo <- local2({
  x <- 10
  y <- 200
  x + y
})

foo
x
y
```

但`base::local()`的底层实现很复杂，它使用了`eval()`和`substitute()`。

### Application:`source()`

我们可以通过组合`eval()`和`parse_expr()`来实现`source()`的功能。首先从磁盘中读取文件，然后使用`parse_expr()`将字符串转换成“表达式”列表，最后使用`eval()`评估“表达式”。实现如下：

```{r}
source2 <- function(path, env = caller_env()) {
  file <- paste(readLines(path, warn = FALSE), collapse = "\n")
  exprs <- parse_exprs(file)

  res <- NULL
  for (i in seq_along(exprs)) {
    res <- eval(exprs[[i]], env)
  }

  invisible(res)
}
```

真实的`base::source()`函数更加复杂，会打印输入输出信息，同时有许多额外参数控制行为。

#### Expression vectors

上一章讲到，`base::parse()`函数解析字符串时，如果捕获到多个“表达式”，会返回一个包含多个表达式的向量。`base::eval()`函数可以直接评估这个向量，而不用上面的`for`循环。

```{r}
source3 <- function(file, env = parent.frame()) {
  lines <- parse(file)
  res <- eval(lines, envir = env)
  invisible(res)
}
```

### Gotcha:`function()`

如果你使用`eval()`和`expr()`来生成函数，有一个小小的漏洞需要注意：

```{r}
x <- 10
y <- 20
f <- eval(expr(function(x, y) !!x + !!y))
f
```

这个函数看起来不像能工作，但它确实能工作：

```{r}
f()
```

这是因为，如果函数有“srcref”属性，就会打印它，但“srcref”是一个base R的特性，它无法识别准引号。

要解决这个问题，可以使用`new_function()`或删除“srcref”属性：

```{r}
attr(f, "srcref") <- NULL
f
```

## Quosures

几乎`eval()`的所有使用都包括“表达式”和“环境”两个参数，但是base R中没有能同时提供这两个参数的数据结构，“rlang”包创建了这种数据结构——“**quosures**”。**quosures**是“quoting”和“closure”的复合体，意味着它同时包含了“表达式”和环境。

在本节中，你将学习如何创建和操作quosure, 以及一些关于如何实现它。

### Creating

有三中方式创建quosure:

-   使用`enquo()`和`enquos()`，它们会同时捕获表达式和环境。许多quosure都是由此创建的。

```{r}
foo <- function(x) enquo(x)
foo(a + b)
```

-   使用`quo()`和`quos()`，与`enquo()`和`enquos()`的关系可以参考`expr()``enexpr()`。使用的场景很少。

```{r}
quo(x + y + z)
```

-   使用`new_quosure()`，输入“表达式”和环境来创建quosure。使用场景也极少。

```{r}
new_quosure(expr(x + y), env(x = 1, y = 10))
```

### Evaluting

只能使用`eval_tidy()`来评估quosure。

```{r}
q1 <- new_quosure(expr(x + y), env(x = 1, y = 10))
eval_tidy(q1)
```

### Dots

`enquos()`可以正确识别`...`中传入的参数及其绑定的环境。例如，下面的`qs`对象，正确评估了`global`和`f`的环境。

```{r}
f <- function(...) {
  x <- 1
  g(..., f = x)
}
g <- function(...) {
  enquos(...)
}

x <- 0
qs <- f(global = x)
qs
map_dbl(qs, eval_tidy)
```

