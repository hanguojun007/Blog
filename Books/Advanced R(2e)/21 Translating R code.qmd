---
title: "21 Translating R code"
date: "2025-08-20"
date-modified: "2025-08-20"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

first-class环境，词法作用域，元编程组成了一套实现将R代码转换为其他语言的工具箱。例如，`dbplyr`为`dplyr`处理数据库提供了支持，允许用R语言表达数据操作并自动将其翻译成SQL，可以使用`translate_sql()`一览其关键思想：

```{r}
library(dbplyr)
con <- simulate_postgres()

translate_sql(x^2, con = con)
translate_sql(x < 5 & !is.na(x), con = con)
translate_sql(!first %in% c("John", "Roger", "Robert"), con = con)
translate_sql(select == 7, con = con)
```

由于SQL语言有许多特性，将R语言翻译成SQL语言的机制非常复杂，因此本章我们介绍两种简单但有用的领域特定语言(DSL): 一种用于生成HTML, 另一种用于在LaTeX中生成数学方程。

### Outline

-   21.2节：介绍创建HTML。

-   21.2节：介绍创建LaTeX。

### Prerequisites

学习本章，你需要了解：环境、表达式、整洁评估、泛函编程、元编程、S3面向对象等。

```{r}
library(rlang)
library(purrr)
```

## HTML

HTML文件是网站的底层核心，是一种特殊的标记语言（SGML，Standard Generalised Markup Language），它和XML相似但不等同。

``` html
<body>
  <h1 id='first'>A heading</h1>
  <p>Some text &amp; <b>some bold text.</b></p>
  <img src='myimg.png' width='100' height='100' />
</body>
```

HTML文件中的关键组件是标签（tag），形如`<tag></tag>`或`<tag/>`。标签可以嵌套在其他标签中，并与文本交织在一起。HTML标签有超过100个，但在本章中，我们只关注其中的少数几个：

-   `<body>`：文档的主体，包含文档所有内容的顶级标签。
-   `<h1>`：文档的标题级别。
-   `<p>`：段落。
-   `<b>`：粗体。
-   `<img>`：图片。

标签具有带名字的属性，形如`<tag name1='value1' name2='value2'/></tag>`。其中有两个重要的属性——`id`和`class`，它们会与CSS联合使用来控制页面的外观。

`<img>`标签不包裹任何内容，它只能被写作`<img />`而不能写成`<img></img>`，类似`<img>`的标签被称为空标签（Void tags）。因为它们不能包裹内容，所以它们的属性非常重要，`<img>`有三个常被使用的属性：`scr`控制图片路径，`width`和`height`控制图片大小。

因为`<`和`>`是HTML中的特殊字符，想要在文本中书写它们，必须用转义符`&lt;`和`&gt;`来代替。同样，`&`也必须用转义符`&amp;`来代替。

### Goal

我们的目标是使用R生成上面的模板html文档。类似：

``` r
with_html(
  body(
    h1("A heading", id = "first"),
    p("Some text &", b("some bold text.")),
    img(src = "myimg.png", width = 100, height = 100)
  )
)
```

它有三个特点：

-   函数名与标签名相同。
-   未命名参数成为标签的内容，而命名参数成为其属性。
-   & 和其他特殊字符会自动转义。

### Escaping

转义功能对于代码“翻译”至关重要，它有两个难点：

-   对输入的字符进行自动转义，`&`,`<`,`>`。

-   正确识别是否需要转义，防止`&amp;`变为`&amp;amp;`。

解决这两个难点的最简单方法是使用S3面向对象，区分要进行转义的普通字符，和已经转义的字符（类）。

```{r}
html <- function(x) structure(x, class = "advr_html")

print.advr_html <- function(x, ...) {
  out <- paste0("<HTML> ", x)
  cat(paste(strwrap(out), collapse = "\n"), "\n", sep = "")
}
```

创建转义泛函和它针对两种类的方法：

-   `escape.character()`：对普通字符进行转义。
-   `escape.advr_html()`：对已经转义的字符不做任何处理。

```{r}
escape <- function(x) UseMethod("escape")

escape.character <- function(x) {
  x <- gsub("&", "&amp;", x)
  x <- gsub("<", "&lt;", x)
  x <- gsub(">", "&gt;", x)

  html(x)
}

escape.advr_html <- function(x) x
```

检查它是否运行成功：

```{r}
escape("This is some text.")
escape("x > 1 & y < 2")

# Double escaping is not a problem
escape(escape("This is some text. 1 > 2"))

# And text we know is HTML doesn't get escaped.
escape(html("<hr />"))
```

### Basic tag functions

接下来，我们将手动编写一个单标签函数，然后弄清楚如何对其进行泛化，这样我们就可以用代码为每个标签生成一个函数。

我们以`<p>`标签为例。HTML的标签可以同时具有属性和子标签（`<b>`,`<i>`）。考虑到属性有name，子标签没有，我们可以将它们类比为函数参数，在函数内部处理两种类型的参数。`p()`函数的使用方法可能会类似于：

``` r
p("Some text. ", b(i("some bold italic text")), class = "mypara")
```

考虑到标签拥有的属性数目不同，子标签的数量也会不同。我们需要使用`...`来获取参数，然后根据是否有name属性进行分类。

```{r}
dots_partition <- function(...) {
  dots <- list2(...)

  if (is.null(names(dots))) {
    is_named <- rep(FALSE, length(dots))
  } else {
    is_named <- names(dots) != ""
  }

  list(
    named = dots[is_named],
    unnamed = dots[!is_named]
  )
}

str(dots_partition(a = 1, 2, b = 3, 4))
```

现在我们可以创建`p()`函数了。示例中引入了一些新的函数，这里不再详细讨论。

```{r}
html_attributes <- function(list) {
  if (length(list) == 0) {
    return("")
  }

  attr <- map2_chr(names(list), list, html_attribute)
  paste0(" ", unlist(attr), collapse = "")
}
html_attribute <- function(name, value = NULL) {
  if (length(value) == 0) {
    return(name)
  } # for attributes with no value
  if (length(value) != 1) stop("`value` must be NULL or length 1")

  if (is.logical(value)) {
    # Convert T and F to true and false
    value <- tolower(value)
  } else {
    value <- escape_attr(value)
  }
  paste0(name, "='", value, "'")
}
escape_attr <- function(x) {
  x <- escape.character(x)
  x <- gsub("\'", "&#39;", x)
  x <- gsub("\"", "&quot;", x)
  x <- gsub("\r", "&#13;", x)
  x <- gsub("\n", "&#10;", x)
  x
}

p <- function(...) {
  dots <- dots_partition(...)
  attribs <- html_attributes(dots$named)
  children <- map_chr(dots$unnamed, escape)

  html(paste0(
    "<p",
    attribs,
    ">",
    paste(children, collapse = ""),
    "</p>"
  ))
}

p("Some text")
p("Some text", id = "myid")
p("Some text", class = "important", `data-value` = 10)
```

### Tag functions

创建其他的标签函数，我们只需要替换`p`即可。所以`tag()`接受一个标签参数，返回一个`rlang::new_function()`创建的函数。`new_function()`内使用`exprs(... = )`来捕获参数。

```{r}
tag <- function(tag) {
  new_function(
    exprs(... = ),
    expr({
      dots <- dots_partition(...)
      attribs <- html_attributes(dots$named)
      children <- map_chr(dots$unnamed, escape)

      html(paste0(
        !!paste0("<", tag),
        attribs,
        ">",
        paste(children, collapse = ""),
        !!paste0("</", tag, ">")
      ))
    }),
    caller_env()
  )
}
tag("b")
```

现在可以复现上面的函数样式了：

```{r}
p <- tag("p")
b <- tag("b")
i <- tag("i")
p("Some text. ", b(i("some bold italic text")), class = "mypara")
```

在创建所有HTML标签函数前，需要为空标签类型创建泛函`void_tag()`。它与`tag()`函数类似，但在出现子标签时报错。

```{r}
void_tag <- function(tag) {
  new_function(
    exprs(... = ),
    expr({
      dots <- dots_partition(...)
      if (length(dots$unnamed) > 0) {
        abort(!!paste0("<", tag, "> must not have unnamed arguments"))
      }
      attribs <- html_attributes(dots$named)

      html(paste0(!!paste0("<", tag), attribs, " />"))
    }),
    caller_env()
  )
}

img <- void_tag("img")
img
img(src = "myimage.png", width = 100, height = 100)
```

### Processing all tags

现在我们可以批量创建所有的标签函数：

```{r}
tags <- c(
  "a", "abbr", "address", "article", "aside", "audio", "b", "bdi", "bdo",
  "blockquote", "body", "button", "canvas", "caption", "cite", "code",
  "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "div", "dl",
  "dt", "em", "eventsource", "fieldset", "figcaption", "figure", "footer",
  "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup",
  "html", "i", "iframe", "ins", "kbd", "label", "legend", "li", "mark", "map",
  "menu", "meter", "nav", "noscript", "object", "ol", "optgroup", "option",
  "output", "p", "pre", "progress", "q", "ruby", "rp", "rt", "s", "samp",
  "script", "section", "select", "small", "span", "strong", "style", "sub",
  "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead",
  "time", "title", "tr", "u", "ul", "var", "video"
)

void_tags <- c(
  "area", "base", "br", "col", "command", "embed", "hr", "img", "input",
  "keygen", "link", "meta", "param", "source", "track", "wbr"
)
```

仔细观察会发现，有些标签与base R中的函数名重复（`body`,`col`,`q`,`sub`,`summary`,`table`），我们可以将所有的函数以列表的形式保存起来，方便后续调用。

```{r}
html_tags <- c(
  tags %>% set_names() %>% map(tag),
  void_tags %>% set_names() %>% map(void_tag)
)

html_tags$p(
  "Some text. ",
  html_tags$b(html_tags$i("some bold italic text")),
  class = "mypara"
)
```

上面的标签函数调用略有冗长，每次都要前缀`html_tags$`。我们可以使用一个辅助函数来实现直接使用标签函数。

```{r}
with_html <- function(code) {
  code <- enquo(code)
  eval_tidy(code, html_tags)
}

with_html(
  body(
    h1("A heading", id = "first"),
    p("Some text &", b("some bold text.")),
    img(src = "myimg.png", width = 100, height = 100)
  )
)
```

## LaTeX