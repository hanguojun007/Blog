---
title: "9 Functionals"
date: "2025-07-17"
date-modified: "2025-07-17"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

泛函是一种以函数作为输入，输出向量的函数。下面是一个简单的泛函函数示例：

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

base R 中常见的`apply`家族函数就属于泛函，还有purrr包中的map系列函数，以及一些数学泛函——`integrate()`,`optim()`。

base R 中的for循环优先级：泛函 \> for \> while \> repeat。如果你对for循环很熟悉，转换到泛函时，只需要从for循环中的提取函数，将其作为参数传入符合要求的泛函即可。当你找不到符合要求的泛函时，首先不要硬适配某种泛函，优先使用for循环，当类似的循环逻辑被重复使用时，考虑编写自己的泛函。

### Outline

-   9.2节：介绍`purrr::map()`。
-   9.3节：讲解如何使用多个简单的泛函组合解决一个复杂问题，并且讨论purrr系列函数的使用风格。
-   9.4节：介绍18个`purrr::map()`变体。
-   9.5节：介绍另外一种风格的泛函——`purrr::reduce()`。
-   9.6节：
-   9.7节：介绍 base R 中的泛函。

### Prerequisites

本章主要关注purrr包中的泛函，它们有着一致的使用风格，比较容易理解掌握。

```{r}
library(purrr)
```

## My first functional: `map()`

`purrr::map()`函数接受一个‘list’或‘atomic vector’（`.x`）和函数（`.f`）作为输入，向量中的每个元素会被应用到函数中，最终返回一个list。即：`map(1:3, f)`等价于`list(f(1), f(2), f(3))`。

```{r}
triple <- function(x) x * 3
map(1:3, triple)
```

![](images/map.png)

这里的map不是“地图”的意思，而是“映射”，意味着‘map’将输入中的向量与结果通过函数进行了映射。

下面是`map()`函数的核心逻辑：创建一个与输入等长的list，for循环处理向量，并把结果赋给list的元素。

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

为了提高性能，`map()`函数其实是用C语言实现的。base R 中的`lapply()`函数与`purrr::map()`函数类似，但是`lapply()`函数不提供下面涉及到的额外功能。

### Producing atomic vectors

`map()`函数结果返回一个list，这赋予了其极大的灵活性，因为任何数据类型都可以储存在list中。但是有时返回的数据类型足够简单，我们无需再使用list储存。purrr 提供了四种特殊的变体函数——`map_lgl()`,`map_int()`,`map_dbl()`和`map_chr()`——分别返回布尔、整数、浮点数和字符向量。

```{r}
# map_chr() always returns a character vector
map_chr(mtcars, typeof)

# map_lgl() always returns a logical vector
map_lgl(mtcars, is.double)

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique)

# map_dbl() always returns a double vector
map_dbl(mtcars, mean)
```

所有`map_*()`系列函数要求返回的list长度与输入`.x`长度一致，所以`.f`必须返回一个值的结果，否则报错。

```{r}
pair <- function(x) c(x, x)
map_dbl(1:2, pair)
```

类似的，如果`map_*()`系列函数要求返回特定类型的值时，`.f`必须返回该类型的结果，否则报错。

```{r}
map_dbl(1:2, as.character)
```

`map()`函数则没有上面的要求：

```{r}
map(1:2, pair)
map(1:2, as.character)
```

在 base R 中，有两个函数类似`map_*()`系列函数，可以返回原子向量——`sapply()`和`vapply()`。作者不建议使用`sapply()`，因为它会对结果进行整理，导致生成不确定的或向量，或list，或矩阵的结果。相反，`vapply()`通过参数`FUN.VALUE`要求用户指定结果的数据类型。例如`vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))`，其等价于`map_dbl(x, mean, na.rm = TRUE)`。

### Anonymous functions and shortcuts

参数`.f`除提供函数名外，更多的是使用匿名函数或`~ f(.x, ...)`形式的公式。`~ f(.x, ...)`在传递其他参数时十分有用，也是最常用的方法。

```{r}
map_dbl(mtcars, function(x) length(unique(x)))
map_dbl(mtcars, ~ length(unique(.x)))
```

`~ f(.x, ...)`形式的背后是 rlang 支持的lambda表达式。表达式会将`map*()`系列函数的参数`.x`解析为`f()`的第一个参数，参数`.y`解析为第二个，依次类推.其他`map*()`系列函数未定义，但函数`f()`需要的参数会通过`...`传递。只有一个参数时可以使用`.`替换`.x`，但是不建议，`.`仅作为向下兼容的牺牲写法，会与其他功能的`.`冲突。

```{r}
as_mapper(~ length(unique(.x)))
```

`map_*()`系列函数可以用来批量提取数据中的某个元素（通过`purrr::pluck()`函数）。通过name信息，位置信息，或二者组合来提取数据，这在从JSON数据（或R对象）中提取数据时特别有用。

```{r}
x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

# Select by name
map_dbl(x, "x")

# Or by position
map_dbl(x, 1)

# Or by both
map_dbl(x, list("y", 1))

# You'll get an error if a component doesn't exist:
map_chr(x, "z")

# Unless you supply a .default value
map_chr(x, "z", .default = NA)
```

下面是一个提取R t.test 结果对象中P值的示例：

```{r}
trials <- map(1:100, ~ t.test(rpois(10, 10), rpois(10, 7)))
library(ggplot2)

df_trials <- tibble::tibble(p_value = map_dbl(trials, "p.value"))

df_trials %>%
  ggplot(aes(x = p_value, fill = p_value < 0.05)) +
  geom_dotplot(binwidth = .01) + # geom_histogram() as alternative
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )
```

### Passing arguments with `...`

诚如上述，你可以使用`...`来传递参数给函数。例如`na.rm = TRUE`，既可以使用`~ f(.x, ...)`形式直接传递参数，也可以通过map函数进行传递。

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
map_dbl(x, mean, na.rm = TRUE)
```

![](images/map-arg.png)

注意：`...`传入的参数不会被map函数解析，而是直接传递。map函数的其他变体会对参数进行解析，详见9.4节。

![](images/map-arg-recycle.png)

::: callout-note
注意：使用`~ f(.x, ...)`形式直接传递参数和通过map函数进行传递，这两种方式有些许不同。前者会在每次调用函数`f`时都评估参数，后者只会在map函数中评估一次。当参数需要延迟评估时要特别注意，例如下面的参数是有`runif()`随机生成。

```{r}
plus <- function(x, y) x + y

x <- c(0, 0, 0, 0)
map_dbl(x, plus, runif(1))
map_dbl(x, ~ plus(.x, runif(1)))
```
:::

### Argument names

当使用`...`传递参数时，推荐使用参数名称，而不是位置。例如，`map(x, mean, trim = 0.1)`要比`map(x, mean, 0.1)`更好。

`map()`函数的参数有两个——输入Vector，函数。考虑到尽量不与函数需要的参数名冲突，purrr 包分别使用了`.x`和`.f`作为参数名。如果使用了`x`,`f`（如最前面的`simple_map()`）作为参数名，那么就可能导致错误。此时只能使用匿名函数的形式来避免冲突。

```{r}
bootstrap_summary <- function(x, f) {
  f(sample(x, replace = TRUE))
}

simple_map(mtcars, bootstrap_summary, f = mean)

# simple_map(mtcars, f = function(x) bootstrap_summary(x, mean))
```

base R 中，也有类似`.x`和`.f`的处理，如：

-   aplly 系函数使用大写字母`X`和`FUN`作为参数名。
-   `transform()`函数参数前使用前缀`_`。

### Varying another argument {#sec-vary_another_argument}

考虑下图中的情况：你需要将`.x`传递给函数的第二个参数，函数的第一个参数是固定的常量。例如你想计算固定向量在不同`trim`时的均值，`mean(x, trim = trims)`。

![](images/map-arg-flipped.png)

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)
```

有两种方法可以解决这个问题：

-   使用匿名函数。

```{r}
map_dbl(trims, ~ mean(x, trim = .x))
map_dbl(trims, function(trim) mean(x, trim = trim))
```

-   使用`mean()`函数的参数自动匹配。你需要直到`mean()`函数的参数名称，

```{r}
map_dbl(trims, mean, x = x)
```

## Purrr style

在介绍其他map变体函数之前，我们先一窥使用purrr风格的函数的示例——数据分组建模，然后抽取模型系数。

```{r}
# 切分数据
by_cyl <- split(mtcars, mtcars$cyl)

# 创建模型
by_cyl %>%
  map(~ lm(mpg ~ wt, data = .x)) %>%
  map(coef) %>%
  map_dbl(2)
```

下面使用 base R 中的函数来实现：

```{r}
by_cyl %>%
  lapply(function(data) lm(mpg ~ wt, data = data)) %>%
  lapply(coef) %>%
  vapply(function(x) x[[2]], double(1))
```

去除管道符：

```{r}
models <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))
vapply(models, function(x) coef(x)[[2]], double(1))
```

使用for循环：

```{r}
slopes <- double(length(by_cyl))
for (i in seq_along(by_cyl)) {
  model <- lm(mpg ~ wt, data = by_cyl[[i]])
  slopes[[i]] <- coef(model)[[2]]
}
slopes
```

有趣的是，从 purr 到 base R 中的 apply 系函数，再到 for 循环，循环函数使用的越少，循环一次做的事情就越多。

## Map variants

map系函数主要有23种，从输入与输出两个维度，可以大致划分为下面的表格：

| 输入\\输出 | List | Atomic | Same type | Nothing |
|---------------|---------------|---------------|---------------|---------------|
| One argument | [`map()`](https://purrr.tidyverse.org/reference/map.html) | [`map_lgl()`](https://purrr.tidyverse.org/reference/map.html), … | [`modify()`](https://purrr.tidyverse.org/reference/modify.html) | [`walk()`](https://purrr.tidyverse.org/reference/map.html) |
| Two arguments | [`map2()`](https://purrr.tidyverse.org/reference/map2.html) | [`map2_lgl()`](https://purrr.tidyverse.org/reference/map2.html), … | [`modify2()`](https://purrr.tidyverse.org/reference/modify.html) | [`walk2()`](https://purrr.tidyverse.org/reference/map2.html) |
| One argument + index | [`imap()`](https://purrr.tidyverse.org/reference/imap.html) | [`imap_lgl()`](https://purrr.tidyverse.org/reference/imap.html), … | [`imodify()`](https://purrr.tidyverse.org/reference/modify.html) | [`iwalk()`](https://purrr.tidyverse.org/reference/imap.html) |
| N arguments | [`pmap()`](https://purrr.tidyverse.org/reference/pmap.html) | [`pmap_lgl()`](https://purrr.tidyverse.org/reference/pmap.html), … | — | [`pwalk()`](https://purrr.tidyverse.org/reference/pmap.html) |

从表格中我们可以看到，除了上面介绍过的`map()`和`map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`，剩余函数可以再划分为5大类：

-   `map2()`：支持迭代两个输入。
-   `imap()`：支持迭代两个输入，其中一个是另外一个的索引。
-   `pmap()`：支持迭代多个输入。
-   `modify()`：输出类型与输入相同。
-   `walk()`：不返回输出。

### Same type of output as input: `modify()`

`modify()`函数最常见的使用场景就是修改数据框。`map()`虽然也可以修改数据框中的数据，但其结果是一个list，而`modify()`函数返回一个数据框。

```{r}
df <- data.frame(
  x = 1:3,
  y = 6:4
)

map(df, ~ .x * 2)
modify(df, ~ .x * 2)
```

`modify()`函数的本质可以用下面的函数表示：

```{r}
simple_modify <- function(x, f, ...) {
  for (i in seq_along(x)) {
    x[[i]] <- f(x[[i]], ...)
  }
  x
}
```

### two inputs: `map2()` and friends

正如9.2节中提到，当你需要迭代两个参数时，`map()`函数无法满足，需要使用`map2()`函数。`map2()`函数对参数的迭代示意图如下：

![](images/map2.png)

假设现在需要计算加权平均值，需要同时迭代`xs`,`ws`。`map_dbl(xs, weighted.mean, w = ws)`会报错，`map2_dbl(xs, ws, weighted.mean)`才是正确用法。

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)

map_dbl(xs, weighted.mean, w = ws)
map2_dbl(xs, ws, weighted.mean)
```

传递额外参数`na.rm = TRUE`的方式与`map()`一样。

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

![](images/map2-arg.png)

`map2()`函数的本质可以用下面的函数表示：

```{r}
simple_map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}
```

`map2()`函数与`simple_map2()`函数略微不同的地方是，当`.x`与`.y`长度不一致时，`map2()`会自动将短的向量重复补齐。

![](images/map2-recycle.png)

### No outputs: `walk()` and friends

`map()`函数可以存储数据并输出，但有时我们并不需要返回结果，此时可以使用`walk()`函数。下面是循环打印信息的例子，`map()`函数返回的是一个都是`NULL`的list，`walk()`函数则不返回任何对象。

```{r}
welcome <- function(x) {
  cat("Welcome ", x, "!\n", sep = "")
}
names <- c("Hadley", "Jenny")

# As well as generate the welcomes, it also shows
# the return value of cat()
map(names, welcome)

walk(names, welcome)
```

`walk2()`函数通常用来将数据写入到磁盘。

```{r}
temp <- tempfile()
dir.create(temp)

cyls <- split(mtcars, mtcars$cyl)
paths <- file.path(temp, paste0("cyl-", names(cyls), ".csv"))
walk2(cyls, paths, write.csv)

dir(temp)
```

### Iterating over values and indices: `imap()`

base R 中对向量进行循环时，有三种类型：

-   迭代元素：`for (x in xs)`
-   迭代元素位置索引：`for (i in seq_along(xs))`
-   迭代元素名称索引：`for (nm in names(xs))`

`map()`函数使用的是第一种，`imap()`函数使用第二种和第三种。`imap(x, f)`本质上等价于`map2(x, names(x), f)`或者`map2(x, seq_along(x), f)`。

```{r}
imap_chr(iris, ~ paste0("The first value of ", .y, " is ", .x[[1]]))
```

```{r}
x <- map(1:6, ~ sample(1000, 10))
imap_chr(x, ~ paste0("The highest value of ", .y, " is ", max(.x)))
```

### Any number of inputs: pmap() and friends

`pmap()`函数的参数有两个:

-   `.l`：参数列表，要求列表中每个元素长度相同，可以看作是一个数据框(data.frame)。
-   `.f`：函数。

这里要对`map()`函数中的参数`.x = list`时作个区分，`map()`中列表作为整体是一个参数，而`pmap()`中列表中的每个元素是一个参数。

```{r}
params <- tibble::tribble(
  ~n, ~min, ~max,
  1L, 0, 1,
  2L, 10, 100,
  3L, 100, 1000
)

pmap(params, runif)
```

![](images/pmap-3.png)

`map2(x, y, f)` 可以等价为`pmap(list(x, y), f)`。

::: {layout-ncol=2}
![](images/pmap.png)

![](images/pmap-arg.png)
:::

```{r}
pmap_dbl(list(xs, ws), weighted.mean)

pmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)
```

[9.2.5](@sec-vary_another_argument)小节中的情况也可以用`pmap()`解决。

```{r}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(1000)

pmap_dbl(list(trim = trims), mean, x = x)
```

base R 有两个等价的函数：`Map()`和`mapply()`，但是它们都有显著的缺陷。

-   `Map()`：你无法提供额外的参数到函数中。

-   `mapply()`：与`sapply()`一样，无法保证结果的一致性。


## Reduce family


```{r}
Map()
mapply()
```