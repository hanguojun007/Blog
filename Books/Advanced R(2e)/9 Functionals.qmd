---
title: "9 Functionals"
date: "2025-07-17"
date-modified: "2025-07-17"

format: "html"
fig-width: 6
fig-asp: 0.618
out-width: 70%
fig-align: center

knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    R.options:
      dplyr.print_min: 6
      dplyr.print_max: 6
      pillar.max_footer_lines: 2
      pillar.min_chars: 15
      stringr.view_n: 6
      cli.num_colors: 0
      cli.hyperlink: FALSE
      pillar.bold: TRUE
      width: 77

execute:
  warning: true
  error: true
---

## Introduction

泛函是一种以函数作为输入，输出向量的函数。下面是一个简单的泛函函数示例：

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

base R 中常见的`apply`家族函数就属于泛函，还有purrr包中的map系列函数，以及一些数学泛函——`integrate()`,`optim()`。

base R 中的for循环优先级：泛函 > for > while > repeat。如果你对for循环很熟悉，转换到泛函时，只需要从for循环中的提取函数，将其作为参数传入符合要求的泛函即可。当你找不到符合要求的泛函时，首先不要硬适配某种泛函，优先使用for循环，当类似的循环逻辑被重复使用时，考虑编写自己的泛函。

### Outline

-   9.2节：介绍`purrr::map()`。
-   9.3节：讲解如何使用多个简单的泛函组合解决一个复杂问题，并且讨论purrr系列函数的使用风格。
-   9.4节：介绍18个`purrr::map()`变体。
-   9.5节：介绍另外一种风格的泛函——`purrr::reduce()`。
-   9.6节：
-   9.7节：介绍 base R 中的泛函。

### Prerequisites

本章主要关注purrr包中的泛函，它们有着一致的使用风格，比较容易理解掌握。

```{r}
library(purrr)
```

## My first functional: `map()`

`purrr::map()`函数接受一个‘list’或‘atomic vector’（`.x`）和函数（`.f`）作为输入，向量中的每个元素会被应用到函数中，最终返回一个list。即：`map(1:3, f)`等价于`list(f(1), f(2), f(3))`。

```{r}
triple <- function(x) x * 3
map(1:3, triple)
```

![](images/map.png)

这里的map不是“地图”的意思，而是“映射”，意味着‘map’将输入中的向量与结果通过函数进行了映射。

下面是`map()`函数的核心逻辑：创建一个与输入等长的list，for循环处理向量，并把结果赋给list的元素。

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

为了提高性能，`map()`函数其实是用C语言实现的。base R 中的`lapply()`函数与`purrr::map()`函数类似，但是`lapply()`函数不提供下面涉及到的额外功能。

### Producing atomic vectors

`map()`函数结果返回一个list，这赋予了其极大的灵活性，因为任何数据类型都可以储存在list中。但是有时返回的数据类型足够简单，我们无需再使用list储存。purrr 提供了四种特殊的变体函数——`map_lgl()`,`map_int()`,`map_dbl()`和`map_chr()`——分别返回布尔、整数、浮点数和字符向量。

```{r}
# map_chr() always returns a character vector
map_chr(mtcars, typeof)

# map_lgl() always returns a logical vector
map_lgl(mtcars, is.double)

# map_int() always returns a integer vector
n_unique <- function(x) length(unique(x))
map_int(mtcars, n_unique)

# map_dbl() always returns a double vector
map_dbl(mtcars, mean)
```

所有`map_*()`系列函数要求返回的list长度与输入`.x`长度一致，所以`.f`必须返回一个值的结果，否则报错。

```{r}
pair <- function(x) c(x, x)
map_dbl(1:2, pair)
```

类似的，如果`map_*()`系列函数要求返回特定类型的值时，`.f`必须返回该类型的结果，否则报错。

```{r}
map_dbl(1:2, as.character)
```

`map()`函数则没有上面的要求：

```{r}
map(1:2, pair)
map(1:2, as.character)
```

在 base R 中，有两个函数类似`map_*()`系列函数，可以返回原子向量——`sapply()`和`vapply()`。作者不建议使用`sapply()`，因为它会对结果进行整理，导致生成不确定的或向量，或list，或矩阵的结果。相反，`vapply()`通过参数`FUN.VALUE`要求用户指定结果的数据类型。例如`vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))`，其等价于`map_dbl(x, mean, na.rm = TRUE)`。

### Anonymous functions and shortcuts

参数`.f`除提供函数名外，更多的是使用匿名函数或`~ f(.x, ...)`形式的公式。`~ f(.x, ...)`在传递其他参数时十分有用，也是最常用的方法。

```{r}
map_dbl(mtcars, function(x) length(unique(x)))
map_dbl(mtcars, ~ length(unique(.x)))
```

`~ f(.x, ...)`形式的背后是 rlang 支持的lambda表达式。表达式会将`map*()`系列函数的参数`.x`解析为`f()`的第一个参数，参数`.y`解析为第二个，依次类推.其他`map*()`系列函数未定义，但函数`f()`需要的参数会通过`...`传递。只有一个参数时可以使用`.`替换`.x`，但是不建议，`.`仅作为向下兼容的牺牲写法，会与其他功能的`.`冲突。

```{r}
as_mapper(~ length(unique(.x)))
```

`map_*()`系列函数可以用来批量提取数据中的某个元素（通过`purrr::pluck()`函数）。通过name信息，位置信息，或二者组合来提取数据，这在从JSON数据中提取数据时特别有用。

```{r}
x <- list(
  list(-1, x = 1, y = c(2), z = "a"),
  list(-2, x = 4, y = c(5, 6), z = "b"),
  list(-3, x = 8, y = c(9, 10, 11))
)

# Select by name
map_dbl(x, "x")

# Or by position
map_dbl(x, 1)

# Or by both
map_dbl(x, list("y", 1))

# You'll get an error if a component doesn't exist:
map_chr(x, "z")

# Unless you supply a .default value
map_chr(x, "z", .default = NA)
```

### Passing arguments with `...`

诚如上述，你可以使用`...`来传递参数给函数。例如`na.rm = TRUE`，既可以使用`~ f(.x, ...)`形式直接传递参数，也可以通过map函数进行传递。

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
map_dbl(x, mean, na.rm = TRUE)
```

![](images/map-arg.png)

注意：`...`传入的参数不会被map函数解析，而是直接传递。map函数的其他变体会对参数进行解析，详见9.4节。

![](images/map-arg-recycle.png)

::: {.callout-note}
注意：使用`~ f(.x, ...)`形式直接传递参数和通过map函数进行传递，这两种方式有些许不同。前者会在每次调用函数`f`时都评估参数，后者只会在map函数中评估一次。当参数需要延迟评估时要特别注意，例如下面的参数是有`runif()`随机生成。

```{r}
plus <- function(x, y) x + y

x <- c(0, 0, 0, 0)
map_dbl(x, plus, runif(1))
map_dbl(x, ~ plus(.x, runif(1)))
```
:::

### Argument names

当使用`...`传递参数时，推荐使用参数名称，而不是位置。例如，`map(x, mean, trim = 0.1)`要比`map(x, mean, 0.1)`更好。

`map()`函数的参数有两个——输入Vector，函数。考虑到尽量不与函数需要的参数名冲突，purrr 包分别使用了`.x`和`.f`作为参数名。如果使用了`x`,`f`（如最前面的`simple_map()`）作为参数名，那么就可能导致错误。此时只能使用匿名函数的形式来避免冲突。

```{r}
bootstrap_summary <- function(x, f) {
  f(sample(x, replace = TRUE))
}

simple_map(mtcars, bootstrap_summary, f = mean)

# simple_map(mtcars, f = function(x) bootstrap_summary(x, mean))
```

base R 中，也有类似`.x`和`.f`的处理，如：

-   aplly 系函数使用大写字母`X`和`FUN`作为参数名。
-   `transform()`函数参数前使用前缀`_`。

### Varying another argument

